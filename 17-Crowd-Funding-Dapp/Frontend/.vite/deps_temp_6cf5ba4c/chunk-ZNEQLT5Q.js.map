{
  "version": 3,
  "sources": ["../../node_modules/thirdweb/src/utils/ipfs.ts"],
  "sourcesContent": ["import type { ThirdwebClient } from \"../client/client.js\";\nimport type { FileOrBufferOrString } from \"../storage/upload/types.js\";\n\nexport type ResolveSchemeOptions = {\n  client: ThirdwebClient;\n  uri: string;\n};\n\nconst DEFAULT_GATEWAY = \"https://{clientId}.ipfscdn.io/ipfs/{cid}\";\n\n/**\n * Resolves the scheme of a given URI and returns the corresponding URL.\n * If the URI starts with \"ipfs://\", it constructs a URL using the IPFS client ID and the IPFS gateway.\n * If the URI starts with \"http\", it returns the URI as is.\n * Otherwise, it throws an error indicating an invalid URI scheme.\n * @param options - The options object containing the URI and the IPFS client.\n * @returns The resolved URL.\n * @throws Error if the URI scheme is invalid.\n * @example\n * ```ts\n * import { resolveScheme } from \"thirdweb/storage\";\n * const url = resolveScheme({\n *  client,\n *  uri: \"ipfs://Qm...\",\n * });\n * ```\n * @storage\n */\nexport function resolveScheme(options: ResolveSchemeOptions) {\n  if (options.uri.startsWith(\"ipfs://\")) {\n    const gateway =\n      options.client.config?.storage?.gatewayUrl ?? DEFAULT_GATEWAY;\n    const clientId = options.client.clientId;\n    const cid = findIPFSCidFromUri(options.uri);\n\n    let bundleId: string | undefined = undefined;\n    if (typeof globalThis !== \"undefined\" && \"Application\" in globalThis) {\n      // shims use wallet connect RN module which injects Application info in globalThis\n      // biome-ignore lint/suspicious/noExplicitAny: get around globalThis typing\n      bundleId = (globalThis as any).Application.applicationId;\n    }\n\n    // purposefully using SPLIT here and not replace for CID to avoid cases where users don't know the schema\n    // also only splitting on `/ipfs` to avoid cases where people pass non `/` terminated gateway urls\n    return `${\n      gateway.replace(\"{clientId}\", clientId).split(\"/ipfs\")[0]\n    }/ipfs/${cid}${bundleId ? `?bundleId=${bundleId}` : \"\"}`;\n  }\n  if (options.uri.startsWith(\"http\")) {\n    return options.uri;\n  }\n  throw new Error(`Invalid URI scheme, expected \"ipfs://\" or \"http(s)://\"`);\n}\n\n/**\n * @internal\n */\nexport function findIPFSCidFromUri(uri: string) {\n  if (!uri.startsWith(\"ipfs://\")) {\n    // do not touch URIs that are not ipfs URIs\n    return uri;\n  }\n\n  // first index of `/Qm` or `/bafy` in the uri (case insensitive)\n  const firstIndex = uri.search(/\\/(Qm|baf)/i);\n  // we start one character after the first `/` to avoid including it in the CID\n  return uri.slice(firstIndex + 1);\n}\n/**\n * Uploads or extracts URIs from the given files.\n * @template T - The type of the files (File, Buffer, String).\n * @param files - The files to upload or extract URIs from.\n * @param client - The Thirdweb client.\n * @param [startNumber] - The starting number for rewriting file names.\n * @returns - A promise that resolves to an array of URIs.\n * @throws {Error} - If the files are not all of the same type (all URI or all FileOrBufferOrString).\n * @internal\n *\n */\nexport async function uploadOrExtractURIs<\n  T extends FileOrBufferOrString | Record<string, unknown>,\n>(files: T[], client: ThirdwebClient, startNumber?: number): Promise<string[]> {\n  if (isUriList(files)) {\n    return files;\n  }\n  if (isMetadataList(files)) {\n    const { upload } = await import(\"../storage/upload.js\");\n    const uris = await upload({\n      client,\n      files,\n      rewriteFileNames: {\n        fileStartNumber: startNumber || 0,\n      },\n    });\n    return Array.isArray(uris) ? uris : [uris];\n  }\n  throw new Error(\n    \"Files must all be of the same type (all URI or all FileOrBufferOrString)\",\n  );\n}\n\n/**\n * Retrieves the base URI from a batch of URIs.\n *\n * @param uris - An array of URIs.\n * @returns The base URI shared by all URIs in the batch.\n * @throws If the batch contains URIs with different base URIs or if no base URI is found.\n * @internal\n */\nexport function getBaseUriFromBatch(uris: string | string[]): string {\n  // biome-ignore lint/style/noParameterAssign: lemme do my stuff\n  uris = Array.isArray(uris) ? uris : [uris];\n  const [base, ...rest] = uris.map((uri) => {\n    // remove query parameters\n    // biome-ignore lint/style/noParameterAssign: lemme do my stuff\n    [uri] = uri.split(\"?\") as [string];\n    // remove fragments\n    // biome-ignore lint/style/noParameterAssign: lemme do my stuff\n    [uri] = uri.split(\"#\") as [string];\n\n    // if the URI ends with a `/`, remove it\n    if (uri.endsWith(\"/\")) {\n      // biome-ignore lint/style/noParameterAssign: lemme do my stuff\n      uri = uri.slice(0, -1);\n    }\n\n    // remove the last part of the URI & add the trailing `/`\n    return `${uri.split(\"/\").slice(0, -1).join(\"/\")}/`;\n  });\n\n  if (!base) {\n    throw new Error(\"Batch of URIs is empty\");\n  }\n\n  if (rest.some((uri) => uri !== base)) {\n    throw new Error(\"All URIs in the batch must have the same base URI\");\n  }\n  return base;\n}\n\nfunction isUriList<T extends FileOrBufferOrString | Record<string, unknown>>(\n  metadatas: (string | T)[],\n): metadatas is string[] {\n  return metadatas.every((m) => typeof m === \"string\");\n}\n\nfunction isMetadataList<\n  T extends FileOrBufferOrString | Record<string, unknown>,\n>(metadatas: (string | T)[]): metadatas is T[] {\n  return metadatas.every((m) => typeof m !== \"string\");\n}\n"],
  "mappings": ";AAQA,IAAM,kBAAkB;AAoBlB,SAAU,cAAc,SAA6B;AApB3D;AAqBE,MAAI,QAAQ,IAAI,WAAW,SAAS,GAAG;AACrC,UAAM,YACJ,mBAAQ,OAAO,WAAf,mBAAuB,YAAvB,mBAAgC,eAAc;AAChD,UAAM,WAAW,QAAQ,OAAO;AAChC,UAAM,MAAM,mBAAmB,QAAQ,GAAG;AAE1C,QAAI,WAA+B;AACnC,QAAI,OAAO,eAAe,eAAe,iBAAiB,YAAY;AAGpE,iBAAY,WAAmB,YAAY;IAC7C;AAIA,WAAO,GACL,QAAQ,QAAQ,cAAc,QAAQ,EAAE,MAAM,OAAO,EAAE,CAAC,CAC1D,SAAS,GAAG,GAAG,WAAW,aAAa,QAAQ,KAAK,EAAE;EACxD;AACA,MAAI,QAAQ,IAAI,WAAW,MAAM,GAAG;AAClC,WAAO,QAAQ;EACjB;AACA,QAAM,IAAI,MAAM,wDAAwD;AAC1E;AAKM,SAAU,mBAAmB,KAAW;AAC5C,MAAI,CAAC,IAAI,WAAW,SAAS,GAAG;AAE9B,WAAO;EACT;AAGA,QAAM,aAAa,IAAI,OAAO,aAAa;AAE3C,SAAO,IAAI,MAAM,aAAa,CAAC;AACjC;",
  "names": []
}
