{
  "version": 3,
  "sources": ["../../node_modules/thirdweb/src/event/utils.ts", "../../node_modules/thirdweb/src/event/prepare-event.ts", "../../node_modules/thirdweb/src/event/actions/parse-logs.ts"],
  "sourcesContent": ["import type { AbiEvent } from \"abitype\";\n\n/**\n * @internal\n */\nexport function isAbiEvent(item: unknown): item is AbiEvent {\n  return !!(\n    item &&\n    typeof item === \"object\" &&\n    \"type\" in item &&\n    item.type === \"event\"\n  );\n}\n", "import { type AbiEvent, type ParseAbiItem, parseAbiItem } from \"abitype\";\nimport { type Hex, encodeEventTopics, toEventHash } from \"viem\";\nimport type { AbiEventParametersToPrimitiveTypes } from \"./types.js\";\nimport { isAbiEvent } from \"./utils.js\";\n\ntype ParseEvent<event extends AbiEvent | string> =\n  // if the method IS an AbiEvent, return it\n  event extends AbiEvent\n    ? event\n    : event extends string // we now know we are in \"string\" territory\n      ? // if the string starts with `function` then we can parse it\n        event extends `event ${string}`\n        ? ParseAbiItem<event>\n        : // do we have an ABI to check, check the length\n          AbiEvent\n      : // this means its neither have an AbiEvent NOR a string -> never\n        never;\n\ntype EventFilters<abiEvent extends AbiEvent> =\n  AbiEventParametersToPrimitiveTypes<abiEvent[\"inputs\"]>;\n\nexport type PrepareEventOptions<\n  TSignature extends `event ${string}` | AbiEvent,\n> = {\n  signature: TSignature;\n  filters?: Readonly<EventFilters<ParseEvent<TSignature>>>;\n};\n\nexport type PreparedEvent<abiEvent extends AbiEvent> = {\n  abiEvent: abiEvent;\n  hash: Hex;\n  topics: Hex[];\n};\n\n/**\n * Prepares an event by parsing the signature, generating the event hash, and encoding the event topics.\n * @param options - The options for preparing the event.\n * @returns The prepared event object.\n * @example\n * ```ts\n * import { prepareEvent } from \"thirdweb\";\n * const myEvent = prepareEvent({\n *  signature: \"event MyEvent(uint256 myArg)\",\n * });\n * ```\n * @contract\n */\nexport function prepareEvent<TSignature extends `event ${string}` | AbiEvent>(\n  options: PrepareEventOptions<TSignature>,\n): PreparedEvent<ParseEvent<TSignature>> {\n  const { signature } = options;\n  let resolvedSignature: ParseEvent<TSignature>;\n  if (isAbiEvent(signature)) {\n    resolvedSignature = signature as ParseEvent<TSignature>;\n  } else {\n    resolvedSignature = parseAbiItem(signature) as ParseEvent<TSignature>;\n  }\n\n  return {\n    abiEvent: resolvedSignature,\n    hash: toEventHash(resolvedSignature),\n    // @ts-expect-error - TODO: investiagte why this complains, it works fine however\n    topics: encodeEventTopics({\n      abi: [resolvedSignature],\n      args: options.filters,\n    }),\n  };\n}\n", "import type { AbiEvent } from \"abitype\";\nimport {\n  type Log,\n  type RpcLog,\n  parseEventLogs as viem_parseEventLogs,\n} from \"viem\";\nimport type { PreparedEvent } from \"../prepare-event.js\";\n\nexport type ParseEventLogsOptions<\n  abiEvents extends PreparedEvent<AbiEvent>[],\n  TStrict extends boolean,\n> = {\n  logs: (Log | RpcLog)[];\n  events: abiEvents;\n  strict?: TStrict;\n};\n\nexport type ParseEventLogsResult<\n  abiEvents extends PreparedEvent<AbiEvent>[],\n  TStrict extends boolean,\n  abiEvent extends AbiEvent = abiEvents[number][\"abiEvent\"],\n> = Array<Log<bigint, number, false, undefined, TStrict, abiEvent[]>>;\n\n/**\n * Parses logs and returns the corresponding events.\n * @param options - The options for parsing logs.\n * @returns The parsed events.\n * @example\n * ```ts\n * import { parseEventLogs } from \"thirdweb\";\n * const events = parseEventLogs({\n *  logs,\n *  events: [preparedEvent, preparedEvent2],\n * });\n * ```\n * @contract\n */\nexport function parseEventLogs<\n  const abiEvents extends PreparedEvent<AbiEvent>[],\n  const TStrict extends boolean = true,\n>(\n  options: ParseEventLogsOptions<abiEvents, TStrict>,\n): ParseEventLogsResult<abiEvents, TStrict> {\n  const { logs, events, strict } = options;\n  return viem_parseEventLogs({\n    logs,\n    abi: events.map((e) => e.abiEvent),\n    strict,\n  }) as unknown as ParseEventLogsResult<abiEvents, TStrict>;\n}\n"],
  "mappings": ";;;;;;;;;;AAKM,SAAU,WAAW,MAAa;AACtC,SAAO,CAAC,EACN,QACA,OAAO,SAAS,YAChB,UAAU,QACV,KAAK,SAAS;AAElB;;;ACmCM,SAAU,aACd,SAAwC;AAExC,QAAM,EAAE,UAAS,IAAK;AACtB,MAAI;AACJ,MAAI,WAAW,SAAS,GAAG;AACzB,wBAAoB;EACtB,OAAO;AACL,wBAAoB,aAAa,SAAS;EAC5C;AAEA,SAAO;IACL,UAAU;IACV,MAAM,gBAAY,iBAAiB;;IAEnC,QAAQ,kBAAkB;MACxB,KAAK,CAAC,iBAAiB;MACvB,MAAM,QAAQ;KACf;;AAEL;;;AC9BM,SAAUA,gBAId,SAAkD;AAElD,QAAM,EAAE,MAAM,QAAQ,OAAM,IAAK;AACjC,SAAO,eAAoB;IACzB;IACA,KAAK,OAAO,IAAI,CAAC,MAAM,EAAE,QAAQ;IACjC;GACD;AACH;",
  "names": ["parseEventLogs"]
}
