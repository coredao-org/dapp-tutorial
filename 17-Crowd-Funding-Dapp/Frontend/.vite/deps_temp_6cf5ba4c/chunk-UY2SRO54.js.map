{
  "version": 3,
  "sources": ["../../node_modules/thirdweb/src/utils/units.ts"],
  "sourcesContent": ["/**\n * Converts a given number of units to a string representation with a specified number of decimal places.\n * @param units - The number of units to convert.\n * @param decimals - The number of decimal places to include in the string representation.\n * @returns The string representation of the converted units.\n * @example\n * ```ts\n * import { toTokens } from \"thirdweb/utils\";\n * toTokens(1000000000000000000n, 18)\n * // '1'\n * ```\n * @utils\n */\nexport function toTokens(units: bigint, decimals: number): string {\n  // Convert to string once and handle negativity.\n  const stringValue = units.toString();\n  const prefix = stringValue[0] === \"-\" ? \"-\" : \"\";\n  // Abusing that string \"-\" is truthy\n  const absStringValue = prefix ? stringValue.slice(1) : stringValue;\n\n  // Ensure we have enough digits for the fractional part.\n  const paddedValue = absStringValue.padStart(decimals + 1, \"0\");\n  const splitIndex = paddedValue.length - decimals;\n\n  // Extract integer and fraction parts directly.\n  const integerPart = paddedValue.slice(0, splitIndex) || \"0\";\n  let fractionPart = paddedValue.slice(splitIndex);\n\n  // Manually trim trailing zeros from the fraction part.\n  for (let i = fractionPart.length - 1; i >= 0; i--) {\n    if (fractionPart[i] !== \"0\") {\n      fractionPart = fractionPart.slice(0, i + 1);\n      break;\n    }\n    // check if the next digit is a zero also\n    // If all zeros, make fraction part empty\n    if (i === 0) {\n      fractionPart = \"\";\n    }\n  }\n\n  // Construct and return the formatted string.\n  return `${prefix}${integerPart}${fractionPart ? `.${fractionPart}` : \"\"}`;\n}\n\n/**\n * Converts a value from wei to ether.\n * @param wei The value in wei to be converted.\n * @returns The converted value in ether.\n * @example\n * ```ts\n * import { toEther } from \"thirdweb/utils\";\n * toEther(1000000000000000000n)\n * // '1'\n * ```\n * @utils\n */\nexport function toEther(wei: bigint) {\n  return toTokens(wei, 18);\n}\n\n/**\n * Converts a string representation of a number with decimal places to a BigInt representation.\n * @param tokens - The string representation of the number, including the integer and fraction parts.\n * @param decimals - The number of decimal places to include in the BigInt representation.\n * @returns The BigInt representation of the number.\n * @example\n * ```ts\n * import { toUnits } from \"thirdweb/utils\";\n * toUnits('1', 18)\n * // 1000000000000000000n\n * ```\n * @utils\n */\nexport function toUnits(tokens: string, decimals: number): bigint {\n  let [integerPart, fractionPart = \"\"] = tokens.split(\".\") as [string, string];\n  const prefix = integerPart.startsWith(\"-\") ? \"-\" : \"\";\n  if (prefix) {\n    integerPart = integerPart.slice(1);\n  }\n\n  fractionPart = fractionPart.padEnd(decimals, \"0\"); // Ensure fraction part is at least 'decimals' long.\n\n  if (decimals === 0) {\n    // Check if there's any fraction part that would necessitate rounding up the integer part.\n    if (fractionPart[0] && Number.parseInt(fractionPart[0]) >= 5) {\n      integerPart = (BigInt(integerPart) + 1n).toString();\n    }\n    fractionPart = \"\"; // No fraction part is needed when decimals === 0.\n  } else {\n    // When decimals > 0, handle potential rounding based on the digit right after the specified decimal places.\n    if (fractionPart.length > decimals) {\n      const roundingDigit = fractionPart[decimals];\n      if (roundingDigit && Number.parseInt(roundingDigit, 10) >= 5) {\n        // If rounding is needed, add 1 to the last included digit of the fraction part.\n        const roundedFraction =\n          BigInt(fractionPart.substring(0, decimals)) + 1n;\n        fractionPart = roundedFraction.toString().padStart(decimals, \"0\");\n\n        if (fractionPart.length > decimals) {\n          // If rounding the fraction results in a length increase (e.g., .999 -> 1.000), increment the integer part.\n          integerPart = (BigInt(integerPart) + 1n).toString();\n          // Adjust the fraction part if it's longer than the specified decimals due to rounding up.\n          fractionPart = fractionPart.substring(fractionPart.length - decimals);\n        }\n      } else {\n        // If no rounding is necessary, just truncate the fraction part to the specified number of decimals.\n        fractionPart = fractionPart.substring(0, decimals);\n      }\n    }\n    // If the fraction part is shorter than the specified decimals, it's already handled by padEnd() above.\n  }\n\n  // Combine the integer and fraction parts into the final BigInt representation.\n  return BigInt(`${prefix}${integerPart}${fractionPart}`);\n}\n\n/**\n * Converts the specified number of tokens to Wei.\n * @param tokens The number of tokens to convert.\n * @returns The converted value in Wei.\n * @example\n * ```ts\n * import { toWei } from \"thirdweb/utils\";\n * toWei('1')\n * // 1000000000000000000n\n * ```\n * @utils\n */\nexport function toWei(tokens: string) {\n  return toUnits(tokens, 18);\n}\n\n/**\n * Converts the specified number from gwei to wei.\n * @param gwei The number of gwei to convert.\n * @returns The converted value in wei.\n * @example\n * ```ts\n * import { fromGwei } from \"thirdweb/utils\";\n * fromGwei('1')\n * // 1000000000n\n * ```\n * @utils\n */\nexport function fromGwei(gwei: string) {\n  return toUnits(gwei, 9);\n}\n"],
  "mappings": ";AAaM,SAAU,SAAS,OAAe,UAAgB;AAEtD,QAAM,cAAc,MAAM,SAAQ;AAClC,QAAM,SAAS,YAAY,CAAC,MAAM,MAAM,MAAM;AAE9C,QAAM,iBAAiB,SAAS,YAAY,MAAM,CAAC,IAAI;AAGvD,QAAM,cAAc,eAAe,SAAS,WAAW,GAAG,GAAG;AAC7D,QAAM,aAAa,YAAY,SAAS;AAGxC,QAAM,cAAc,YAAY,MAAM,GAAG,UAAU,KAAK;AACxD,MAAI,eAAe,YAAY,MAAM,UAAU;AAG/C,WAAS,IAAI,aAAa,SAAS,GAAG,KAAK,GAAG,KAAK;AACjD,QAAI,aAAa,CAAC,MAAM,KAAK;AAC3B,qBAAe,aAAa,MAAM,GAAG,IAAI,CAAC;AAC1C;IACF;AAGA,QAAI,MAAM,GAAG;AACX,qBAAe;IACjB;EACF;AAGA,SAAO,GAAG,MAAM,GAAG,WAAW,GAAG,eAAe,IAAI,YAAY,KAAK,EAAE;AACzE;AAcM,SAAU,QAAQ,KAAW;AACjC,SAAO,SAAS,KAAK,EAAE;AACzB;AAeM,SAAU,QAAQ,QAAgB,UAAgB;AACtD,MAAI,CAAC,aAAa,eAAe,EAAE,IAAI,OAAO,MAAM,GAAG;AACvD,QAAM,SAAS,YAAY,WAAW,GAAG,IAAI,MAAM;AACnD,MAAI,QAAQ;AACV,kBAAc,YAAY,MAAM,CAAC;EACnC;AAEA,iBAAe,aAAa,OAAO,UAAU,GAAG;AAEhD,MAAI,aAAa,GAAG;AAElB,QAAI,aAAa,CAAC,KAAK,OAAO,SAAS,aAAa,CAAC,CAAC,KAAK,GAAG;AAC5D,qBAAe,OAAO,WAAW,IAAI,IAAI,SAAQ;IACnD;AACA,mBAAe;EACjB,OAAO;AAEL,QAAI,aAAa,SAAS,UAAU;AAClC,YAAM,gBAAgB,aAAa,QAAQ;AAC3C,UAAI,iBAAiB,OAAO,SAAS,eAAe,EAAE,KAAK,GAAG;AAE5D,cAAM,kBACJ,OAAO,aAAa,UAAU,GAAG,QAAQ,CAAC,IAAI;AAChD,uBAAe,gBAAgB,SAAQ,EAAG,SAAS,UAAU,GAAG;AAEhE,YAAI,aAAa,SAAS,UAAU;AAElC,yBAAe,OAAO,WAAW,IAAI,IAAI,SAAQ;AAEjD,yBAAe,aAAa,UAAU,aAAa,SAAS,QAAQ;QACtE;MACF,OAAO;AAEL,uBAAe,aAAa,UAAU,GAAG,QAAQ;MACnD;IACF;EAEF;AAGA,SAAO,OAAO,GAAG,MAAM,GAAG,WAAW,GAAG,YAAY,EAAE;AACxD;AAcM,SAAU,MAAM,QAAc;AAClC,SAAO,QAAQ,QAAQ,EAAE;AAC3B;AAcM,SAAU,SAAS,MAAY;AACnC,SAAO,QAAQ,MAAM,CAAC;AACxB;",
  "names": []
}
