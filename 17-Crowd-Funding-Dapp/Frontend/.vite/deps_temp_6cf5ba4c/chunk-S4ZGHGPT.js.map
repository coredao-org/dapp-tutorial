{
  "version": 3,
  "sources": ["../../node_modules/thirdweb/src/rpc/actions/eth_getLogs.ts", "../../node_modules/thirdweb/src/transaction/types.ts", "../../node_modules/thirdweb/src/transaction/actions/simulate.ts", "../../node_modules/thirdweb/src/event/actions/get-events.ts", "../../node_modules/thirdweb/src/utils/retry.ts", "../../node_modules/thirdweb/src/event/actions/watch-events.ts", "../../node_modules/thirdweb/src/pay/buyWithCrypto/getHistory.ts"],
  "sourcesContent": ["import type { Address } from \"abitype\";\nimport {\n  type BlockNumber,\n  type BlockTag,\n  type EIP1193RequestFn,\n  type EIP1474Methods,\n  type Hash,\n  type LogTopic,\n  type RpcLog,\n  formatLog,\n} from \"viem\";\nimport { numberToHex } from \"../../utils/encoding/hex.js\";\n\nexport type GetLogsBlockParams =\n  | {\n      fromBlock?: BlockNumber | BlockTag;\n      toBlock?: BlockNumber | BlockTag;\n      blockHash?: never;\n      blockRange?: never;\n    }\n  | {\n      fromBlock?: never;\n      toBlock?: never;\n      blockHash?: Hash;\n      blockRange?: never;\n    }\n  | {\n      fromBlock?: BlockNumber | \"latest\";\n      toBlock?: never;\n      blockRange: BlockNumber;\n      blockHash?: never;\n    }\n  | {\n      fromBlock?: never;\n      toBlock?: BlockNumber | \"latest\";\n      blockRange: BlockNumber;\n      blockHash?: never;\n    }\n  | {\n      fromBlock?: never;\n      toBlock?: never;\n      blockRange: BlockNumber;\n      blockHash?: never;\n    };\n\nexport type GetLogsParams = {\n  topics?: LogTopic[];\n  address?: Address;\n} & GetLogsBlockParams;\n\n/**\n * Retrieves logs from the Ethereum blockchain based on the specified parameters.\n * @param request - The EIP1193 request function.\n * @param params - The parameters for retrieving logs.\n * @returns A promise that resolves to the retrieved logs.\n * @rpc\n * @example\n * ```ts\n * import { getRpcClient, eth_getLogs } from \"thirdweb/rpc\";\n * const rpcRequest = getRpcClient({ client, chain });\n * const logs = await eth_getLogs(rpcRequest, {\n *  address: \"0x...\",\n *  fromBlock: 123456n,\n *  toBlock: 123456n,\n * });\n * ```\n */\nexport async function eth_getLogs(\n  request: EIP1193RequestFn<EIP1474Methods>,\n  params: GetLogsParams = {},\n) {\n  const topics = params.topics ?? [];\n\n  let logs: RpcLog[];\n  // in the case we have a blockHash\n  if (params.blockHash) {\n    const param: {\n      address?: string | string[];\n      topics: LogTopic[];\n      blockHash: `0x${string}`;\n    } = {\n      topics,\n      blockHash: params.blockHash,\n    };\n    if (params.address) {\n      param.address = params.address;\n    }\n    logs = await request({\n      method: \"eth_getLogs\",\n      params: [param],\n    });\n  }\n  // otherwise\n  else {\n    const param: {\n      address?: string | string[];\n      topics?: LogTopic[];\n    } & (\n      | {\n          fromBlock?: BlockTag | `0x${string}`;\n          toBlock?: BlockTag | `0x${string}`;\n          blockHash?: never;\n        }\n      | {\n          fromBlock?: never;\n          toBlock?: never;\n          blockHash?: `0x${string}`;\n        }\n    ) = { topics };\n    if (params.address) {\n      param.address = params.address;\n    }\n\n    if (params.fromBlock) {\n      param.fromBlock =\n        typeof params.fromBlock === \"bigint\"\n          ? numberToHex(params.fromBlock)\n          : params.fromBlock;\n    }\n    if (params.toBlock) {\n      param.toBlock =\n        typeof params.toBlock === \"bigint\"\n          ? numberToHex(params.toBlock)\n          : params.toBlock;\n    }\n\n    logs = await request({\n      method: \"eth_getLogs\",\n      params: [param],\n    });\n  }\n\n  return logs.map((log) => formatLog(log));\n}\n", "import type {\n  Abi,\n  AbiFunction,\n  AbiParameter,\n  AbiParametersToPrimitiveTypes,\n  ExtractAbiFunction,\n  ParseAbiItem,\n} from \"abitype\";\nimport type { TransactionReceipt as ViemTransactionReceipt } from \"viem\";\nimport type { ThirdwebContract } from \"../contract/contract.js\";\nimport type { Hex } from \"../utils/encoding/hex.js\";\nimport { isObjectWithKeys } from \"../utils/type-guards.js\";\nimport type {\n  PreparedTransaction,\n  StaticPrepareTransactionOptions,\n} from \"./prepare-transaction.js\";\n\nexport type SendTransactionResult = {\n  readonly transactionHash: Hex;\n};\n\nexport type TransactionReceipt = ViemTransactionReceipt;\n\nexport type WithOverrides<T> = T & {\n  overrides?: Omit<\n    StaticPrepareTransactionOptions,\n    \"to\" | \"from\" | \"data\" | \"maxFeePerBlobGas\" | \"chain\" | \"client\"\n  >;\n};\n\nexport type ParamsOption<inputs extends readonly AbiParameter[]> =\n  inputs extends {\n    length: 0;\n  }\n    ? // allow omitting \"params\" if there are no inputs\n      { params?: readonly unknown[] }\n    : {\n        params:\n          | Readonly<AbiParametersToPrimitiveTypes<inputs>>\n          | (() => Promise<Readonly<AbiParametersToPrimitiveTypes<inputs>>>);\n      };\n\nexport type BaseTransactionOptions<\n  T extends object = object,\n  // biome-ignore lint/suspicious/noExplicitAny: TODO: fix later\n  abi extends Abi = any,\n> = {\n  contract: ThirdwebContract<abi>;\n} & T;\n// type-guard\n/**\n * Checks if the given value is of type TxOpts.\n * @param value - The value to check.\n * @returns True if the value is of type TxOpts, false otherwise.\n * @internal\n */\nexport function isBaseTransactionOptions(\n  value: unknown,\n): value is PreparedTransaction {\n  return (\n    isObjectWithKeys(value, [\"__contract\"]) &&\n    isObjectWithKeys(value.__contract, [\"address\", \"chain\"]) &&\n    typeof value.__contract.address === \"string\"\n  );\n}\n\nexport type ParseMethod<\n  abi extends Abi,\n  method extends\n    | AbiFunction\n    | string\n    | ((contract: ThirdwebContract<abi>) => Promise<AbiFunction>),\n> = method extends AbiFunction // if the method IS an AbiFunction, return it\n  ? method\n  : method extends string // we now know we are in \"string\" territory\n    ? // if the string starts with `function` then we can parse it\n      method extends `function ${string}`\n      ? ParseAbiItem<method> extends AbiFunction\n        ? ParseAbiItem<method>\n        : never\n      : // do we have an ABI to check, check the length\n        abi extends { length: 0 }\n        ? // if not, we return AbiFunction\n          AbiFunction\n        : // if we do have a length, extract the abi function\n          ExtractAbiFunction<abi, method>\n    : // this means its neither have an AbiFunction NOR a string -> never\n      AbiFunction;\n", "import type { Abi, AbiFunction } from \"abitype\";\nimport { decodeAbiParameters, formatTransactionRequest } from \"viem\";\nimport { eth_call } from \"../../rpc/actions/eth_call.js\";\nimport { getRpcClient } from \"../../rpc/rpc.js\";\nimport type { PreparedMethod } from \"../../utils/abi/prepare-method.js\";\nimport { resolvePromisedValue } from \"../../utils/promise/resolve-promised-value.js\";\nimport type { Prettify } from \"../../utils/type-utils.js\";\nimport type { Account } from \"../../wallets/interfaces/wallet.js\";\nimport { extractError } from \"../extract-error.js\";\nimport type { PreparedTransaction } from \"../prepare-transaction.js\";\nimport type { ReadContractResult } from \"../read-contract.js\";\nimport { encode } from \"./encode.js\";\n\nexport type SimulateOptions<\n  abi extends Abi,\n  abiFn extends AbiFunction,\n> = Prettify<\n  {\n    transaction: PreparedTransaction<abi, abiFn>;\n  } & (\n    | {\n        account: Account;\n        from?: never;\n      }\n    | {\n        account?: never;\n        from?: string;\n      }\n  )\n>;\n\n/**\n * Simulates the execution of a transaction.\n * @param options - The options for simulating the transaction.\n * @returns A promise that resolves to the result of the simulation.\n * @transaction\n * @example\n * ```ts\n * import { simulateTransaction } from \"thirdweb\";\n * const result = await simulateTransaction({\n *  transaction,\n * });\n * ```\n */\nexport async function simulateTransaction<\n  const abi extends Abi,\n  const abiFn extends AbiFunction,\n>(options: SimulateOptions<abi, abiFn>) {\n  const [data, to, accessList, value] = await Promise.all([\n    encode(options.transaction),\n    resolvePromisedValue(options.transaction.to),\n    resolvePromisedValue(options.transaction.accessList),\n    resolvePromisedValue(options.transaction.value),\n  ]);\n\n  // from is:\n  // 1. the user specified from address\n  // 2. the passed in account address\n  // 3. the passed in wallet's account address\n  const from = options.from ?? options.account?.address ?? undefined;\n\n  const serializedTx = formatTransactionRequest({\n    data,\n    from,\n    to,\n    value,\n    accessList,\n  });\n\n  const rpcRequest = getRpcClient(options.transaction);\n  try {\n    const result = await eth_call(rpcRequest, serializedTx);\n\n    if (!options.transaction.__preparedMethod) {\n      return result;\n    }\n\n    const prepared = await options.transaction.__preparedMethod();\n\n    const decoded = decodeAbiParameters(prepared[2], result);\n\n    if (Array.isArray(decoded) && decoded.length === 1) {\n      return decoded[0];\n    }\n\n    return decoded as ReadContractResult<PreparedMethod<abiFn>[2]>;\n  } catch (error) {\n    throw await extractError({\n      error,\n      contract: options.transaction.__contract,\n    });\n  }\n}\n", "/**\n * 1. blockTime + contract (with abi) + no events -> logs with types and parsing *if* contract has abi defined\n * 2. blockTime + contract (no abi) + no events -> logs with NO types but *with* parsing\n * 3. blockTime + no contract + events -> logs with types and parsing (across all \"addresses\") (no contract filter)\n * 4. blockTime + contract + events -> logs with types and parsing (filtered by contract address +  event topics)\n */\n\nimport type {\n  Abi,\n  AbiEvent,\n  ExtractAbiEvent,\n  ExtractAbiEventNames,\n} from \"abitype\";\nimport { resolveContractAbi } from \"../../contract/actions/resolve-abi.js\";\nimport type { ThirdwebContract } from \"../../contract/contract.js\";\nimport { eth_blockNumber } from \"../../rpc/actions/eth_blockNumber.js\";\nimport {\n  type GetLogsBlockParams,\n  type GetLogsParams,\n  eth_getLogs,\n} from \"../../rpc/actions/eth_getLogs.js\";\nimport { getRpcClient } from \"../../rpc/rpc.js\";\nimport type { Prettify } from \"../../utils/type-utils.js\";\nimport { type PreparedEvent, prepareEvent } from \"../prepare-event.js\";\nimport { isAbiEvent } from \"../utils.js\";\nimport { type ParseEventLogsResult, parseEventLogs } from \"./parse-logs.js\";\n\nexport type GetContractEventsOptionsDirect<\n  abi extends Abi,\n  abiEvents extends PreparedEvent<AbiEvent>[],\n  TStrict extends boolean,\n> = {\n  contract: ThirdwebContract<abi>;\n  events?: abiEvents;\n  strict?: TStrict;\n};\n\nexport type GetContractEventsOptions<\n  abi extends Abi,\n  abiEvents extends PreparedEvent<AbiEvent>[],\n  TStrict extends boolean,\n> = Prettify<\n  GetContractEventsOptionsDirect<abi, abiEvents, TStrict> & GetLogsBlockParams\n>;\n\nexport type GetContractEventsResult<\n  abiEvents extends PreparedEvent<AbiEvent>[],\n  TStrict extends boolean,\n> = ParseEventLogsResult<abiEvents, TStrict>;\n\n/**\n * Retrieves events from a contract based on the provided options.\n * @param options - The options for retrieving events.\n * @returns A promise that resolves to an array of parsed event logs.\n * Note: toBlock and fromBlock are both inclusive.\n * @example\n * ```ts\n * import { getContractEvents } from \"thirdweb\";\n * const events = await getContractEvents({\n *  contract: myContract,\n *  fromBlock: 123456n,\n *  toBlock: 123456n,\n *  events: [preparedEvent, preparedEvent2],\n * });\n * ```\n * @example\n * Optionally specify a blockRange as the number of blocks to retrieve. toBlock will default to the current block number.\n * ```ts\n * import { getContractEvents } from \"thirdweb\";\n * const events = await getContractEvents({\n *  contract: myContract,\n *  blockRange: 123456n,\n *  events: [preparedEvent, preparedEvent2],\n * });\n * ```\n * @example\n * Use fromBlock with blockRange for pagination.\n * ```ts\n * import { getContractEvents } from \"thirdweb\";\n * const events = await getContractEvents({\n *  contract: myContract,\n *  fromBlock: lastBlockFetched,\n *  blockRange: 123456n,\n *  events: [preparedEvent, preparedEvent2],\n * });\n * ```\n * @example\n * Retrieve events for a specific block hash.\n * ```ts\n * import { getContractEvents } from \"thirdweb\";\n * const events = await getContractEvents({\n *  contract: myContract,\n *  blockHash: \"0x...\",\n *  events: [preparedEvent, preparedEvent2],\n * });\n * ```\n * @contract\n */\nexport async function getContractEvents<\n  const abi extends Abi,\n  const abiEvents extends PreparedEvent<AbiEvent>[] = PreparedEvent<\n    ExtractAbiEvent<abi, ExtractAbiEventNames<abi>>\n  >[],\n  const TStrict extends boolean = true,\n>(\n  options: GetContractEventsOptions<abi, abiEvents, TStrict>,\n): Promise<GetContractEventsResult<abiEvents, TStrict>> {\n  const { contract, events, blockRange, ...restParams } = options;\n\n  const rpcRequest = getRpcClient(contract);\n\n  if (\n    restParams.blockHash &&\n    (blockRange || restParams.fromBlock || restParams.toBlock)\n  ) {\n    throw new Error(\"Cannot specify blockHash and range simultaneously,\");\n  }\n\n  const latestBlockNumber = await eth_blockNumber(rpcRequest);\n\n  // Compute toBlock and fromBlock if blockRange was passed\n  if (blockRange) {\n    const { fromBlock, toBlock } = restParams;\n\n    // Make sure the inputs were properly defined\n    if (\n      fromBlock !== undefined &&\n      toBlock !== undefined &&\n      BigInt(toBlock) - BigInt(fromBlock) !== BigInt(blockRange)\n    ) {\n      throw new Error(\n        \"Incompatible blockRange with specified fromBlock and toBlock. Please only define fromBlock or toBlock when specifying blockRange.\",\n      );\n    }\n\n    if (fromBlock !== undefined) {\n      restParams.toBlock = BigInt(fromBlock) + BigInt(blockRange) - 1n; // Subtract one because toBlock is inclusive\n    } else if (toBlock !== undefined) {\n      restParams.fromBlock = BigInt(toBlock) - BigInt(blockRange) + 1n; // Add one because fromBlock is inclusive\n    } else {\n      // If no from or to block specified, use the latest block as the to block\n      restParams.toBlock = latestBlockNumber;\n      restParams.fromBlock = latestBlockNumber - BigInt(blockRange) + 1n; // Add one because fromBlock is inclusive\n    }\n  }\n\n  let resolvedEvents = events ?? [];\n\n  // if we have an abi on the contract, we can encode the topics with it\n  if (!events?.length && !!contract) {\n    // if we have a contract *WITH* an abi we can use that\n    if (contract.abi?.length) {\n      // @ts-expect-error - we can't make typescript happy here, but we know this is an abi event\n      resolvedEvents = contract.abi\n        .filter(isAbiEvent)\n        .map((abiEvent) => prepareEvent({ signature: abiEvent }));\n    } else {\n      const runtimeAbi = await resolveContractAbi(contract);\n      // @ts-expect-error - we can't make typescript happy here, but we know this is an abi event\n      resolvedEvents = runtimeAbi\n        .filter(isAbiEvent)\n        .map((abiEvent) => prepareEvent({ signature: abiEvent }));\n    }\n  }\n\n  const logsParams: GetLogsParams[] =\n    events && events.length > 0\n      ? // if we have events passed in then we use those\n        events.map((e) => ({\n          ...restParams,\n          address: contract?.address,\n          topics: e.topics,\n        }))\n      : // otherwise we want \"all\" events (aka not pass any topics at all)\n        [{ ...restParams, address: contract?.address }];\n\n  const logs = await Promise.all(\n    logsParams.map((ethLogParams) => eth_getLogs(rpcRequest, ethLogParams)),\n  );\n  const flattenLogs = logs\n    .flat()\n    .sort((a, b) => Number((a.blockNumber ?? 0n) - (b.blockNumber ?? 0n)));\n  return parseEventLogs({\n    logs: flattenLogs,\n    events: resolvedEvents,\n  });\n}\n", "/**\n * Attempts to execute a function that returns a promise and retries if the function throws an error.\n *\n * @param {Function} fn - A function that returns a promise to be executed.\n * @param {Object} options - Configuration options for the retry behavior.\n * @param {number} [options.retries=1] - The number of times to retry the function before failing.\n * @param {number} [options.delay=0] - The delay in milliseconds between retries.\n * @returns {Promise<void>} The result of the function execution if successful.\n */\n\nexport async function retry<T>(\n  fn: () => Promise<T>,\n  options: { retries?: number; delay?: number },\n): Promise<T> {\n  const retries = options.retries ?? 1;\n  const delay = options.delay ?? 0;\n  let lastError: Error | null = null;\n  for (let i = 0; i < retries; i++) {\n    try {\n      return await fn();\n    } catch (error) {\n      lastError = error as Error;\n      if (delay > 0) {\n        await new Promise((resolve) => setTimeout(resolve, delay));\n      }\n    }\n  }\n  throw lastError;\n}\n", "import type { Abi, AbiEvent } from \"abitype\";\nimport {\n  type GetContractEventsOptionsDirect,\n  getContractEvents,\n} from \"./get-events.js\";\n\nimport { watchBlockNumber } from \"../../rpc/watchBlockNumber.js\";\nimport { retry } from \"../../utils/retry.js\";\nimport type { Prettify } from \"../../utils/type-utils.js\";\nimport type { PreparedEvent } from \"../prepare-event.js\";\nimport type { ParseEventLogsResult } from \"./parse-logs.js\";\n\nexport type WatchContractEventsOptions<\n  abi extends Abi,\n  abiEvents extends PreparedEvent<AbiEvent>[],\n  TStrict extends boolean,\n> = Prettify<\n  GetContractEventsOptionsDirect<abi, abiEvents, TStrict> & {\n    onEvents: (events: ParseEventLogsResult<abiEvents, TStrict>) => void;\n    latestBlockNumber?: bigint;\n  }\n>;\n\n/**\n * Listens for  contract events from the blockchain.\n * @param options - The options for retrieving contract events.\n * @returns The unwatch function.\n * @example\n * ### Listen to all events for a contract\n * ```ts\n * import { watchContractEvents } from \"thirdweb\";\n * const unwatch = watchContractEvents({\n *  contract: myContract,\n *  onEvents: (events) => {\n *   // do something with the events\n *  },\n * });\n * ```\n *\n * ### Listen to specific events for a contract\n * ```ts\n * import { prepareEvent, watchContractEvents } from \"thirdweb\";\n * const myEvent = prepareEvent({\n *  event: \"event MyEvent(uint256 myArg)\",\n * });\n * const events = await watchContractEvents({\n *  contract: myContract,\n *  events: [myEvent],\n *  onEvents: (events) => {\n *   // do something with the events\n *  },\n * });\n * ```\n * @contract\n */\nexport function watchContractEvents<\n  const abi extends Abi,\n  const abiEvents extends PreparedEvent<AbiEvent>[],\n  const TStrict extends boolean = true,\n>(options: WatchContractEventsOptions<abi, abiEvents, TStrict>) {\n  // returning this returns the underlying \"unwatch\" function\n  return watchBlockNumber({\n    ...options.contract,\n\n    /**\n     * This function is called every time a new block is mined.\n     * @param blockNumber - The block number of the new block.\n     * @returns A promise that resolves when the function is finished.\n     * @internal\n     */\n    onNewBlockNumber: async (blockNumber) => {\n      const logs = await retry(\n        async () =>\n          getContractEvents({\n            ...options,\n            // fromBlock is inclusive\n            fromBlock: blockNumber,\n            // toBlock is inclusive\n            toBlock: blockNumber,\n          }),\n        {\n          retries: 3,\n          delay: 500,\n        },\n      );\n      // if there were any logs associated with our event(s)\n      if (logs.length) {\n        options.onEvents(logs);\n      }\n    },\n    latestBlockNumber: options.latestBlockNumber,\n  });\n}\n", "import type { ThirdwebClient } from \"../../client/client.js\";\nimport { getClientFetch } from \"../../utils/fetch.js\";\nimport { getPayBuyWithCryptoHistoryEndpoint } from \"../utils/definitions.js\";\nimport type { BuyWithCryptoStatus } from \"./getStatus.js\";\n\n/**\n * The parameters for [`getBuyWithCryptoHistory`](https://portal.thirdweb.com/references/typescript/v5/getBuyWithCryptoHistory) function\n * It takes the wallet history address and optional cursor and page size. for paginated results.\n * @buyCrypto\n */\nexport type BuyWithCryptoHistoryParams = {\n  /**\n   * A client is the entry point to the thirdweb SDK. It is required for all other actions.\n   *\n   * You can create a client using the `createThirdwebClient` function.\n   * Refer to the [Creating a Client](https://portal.thirdweb.com/typescript/v5/client) documentation for more information.\n   *\n   */\n  client: ThirdwebClient;\n  /**\n   * The address of the wallet to get the wallet history for\n   */\n  walletAddress: string;\n  /**\n   * The number of results to return in a single page. The default value is 10.\n   */\n  count: number;\n  /**\n   * The cursor for the page of results to return. The default value is `undefined`.\n   */\n  start: number;\n};\n\n/**\n * The results for [`getBuyWithCryptoHistory`](https://portal.thirdweb.com/references/typescript/v5/getBuyWithCryptoHistory) function\n * It includes information about transactions that the wallet address has made through thirdweb buy with crypto.\n * @buyCrypto\n */\nexport type BuyWithCryptoHistoryData = {\n  page: BuyWithCryptoStatus[];\n  hasNextPage: boolean;\n};\n\n/**\n * Gets the History of purchases for a given wallet address\n * @param params Object of type [`BuyWithCryptoHistoryParams`](https://portal.thirdweb.com/references/typescript/v5/BuyWithCryptoHistoryParams)\n * @example\n *\n * ```ts\n * import { createThirdwebClient } from \"thirdweb\";\n * import { BuyWithCryptoHistoryData } from \"thirdweb/pay\";\n *\n * const client = createThirdwebClient({ clientId: \"...\" });\n * const walletAddress = \"0x...\";\n * const params = {\n *  client,\n *  walletAddress,\n * };\n *\n * // grabs the history of purchase transactions for the wallet address\n * const status = await getBuyWithCryptoHistory(params)\n * ```\n * @returns Object of type [`BuyWithCryptoHistoryData`](https://portal.thirdweb.com/references/typescript/v5/BuyWithCryptoHistoryData)\n * @buyCrypto\n */\nexport async function getBuyWithCryptoHistory(\n  params: BuyWithCryptoHistoryParams,\n): Promise<BuyWithCryptoHistoryData> {\n  try {\n    const queryParams = new URLSearchParams();\n    queryParams.append(\"walletAddress\", params.walletAddress);\n    queryParams.append(\"start\", params.start.toString());\n    queryParams.append(\"count\", params.count.toString());\n\n    const queryString = queryParams.toString();\n    const url = `${getPayBuyWithCryptoHistoryEndpoint()}?${queryString}`;\n\n    const response = await getClientFetch(params.client)(url);\n\n    // Assuming the response directly matches the SwapResponse interface\n    if (!response.ok) {\n      response.body?.cancel();\n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n\n    const data: BuyWithCryptoHistoryData = (await response.json()).result;\n    return data;\n  } catch (error) {\n    throw new Error(`Fetch failed: ${error}`);\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
