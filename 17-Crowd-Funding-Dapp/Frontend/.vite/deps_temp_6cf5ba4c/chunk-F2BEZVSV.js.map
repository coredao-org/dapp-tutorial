{
  "version": 3,
  "sources": ["../../node_modules/thirdweb/src/extensions/erc4337/__generated__/IEntryPoint/events/UserOperationRevertReason.ts", "../../node_modules/thirdweb/src/extensions/erc4337/__generated__/IEntryPoint_v07/events/PostOpRevertReason.ts", "../../node_modules/thirdweb/src/wallets/smart/types.ts", "../../node_modules/thirdweb/src/wallets/smart/lib/utils.ts", "../../node_modules/thirdweb/src/wallets/smart/lib/bundler.ts", "../../node_modules/thirdweb/src/wallets/smart/lib/calls.ts", "../../node_modules/thirdweb/src/extensions/erc4337/__generated__/IEntryPoint/read/getNonce.ts", "../../node_modules/thirdweb/src/extensions/erc4337/__generated__/IEntryPoint/read/getUserOpHash.ts", "../../node_modules/thirdweb/src/extensions/erc4337/__generated__/IEntryPoint_v07/read/getUserOpHash.ts", "../../node_modules/thirdweb/src/wallets/smart/lib/packUserOp.ts", "../../node_modules/thirdweb/src/wallets/smart/lib/paymaster.ts", "../../node_modules/thirdweb/src/wallets/smart/lib/userop.ts", "../../node_modules/thirdweb/src/wallets/smart/index.ts"],
  "sourcesContent": ["import { prepareEvent } from \"../../../../../event/prepare-event.js\";\nimport type { AbiParameterToPrimitiveType } from \"abitype\";\n\n/**\n * Represents the filters for the \"UserOperationRevertReason\" event.\n */\nexport type UserOperationRevertReasonEventFilters = Partial<{\n  userOpHash: AbiParameterToPrimitiveType<{\n    type: \"bytes32\";\n    name: \"userOpHash\";\n    indexed: true;\n  }>;\n  sender: AbiParameterToPrimitiveType<{\n    type: \"address\";\n    name: \"sender\";\n    indexed: true;\n  }>;\n}>;\n\n/**\n * Creates an event object for the UserOperationRevertReason event.\n * @param filters - Optional filters to apply to the event.\n * @returns The prepared event object.\n * @extension ERC4337\n * @example\n * ```ts\n * import { getContractEvents } from \"thirdweb\";\n * import { userOperationRevertReasonEvent } from \"thirdweb/extensions/erc4337\";\n *\n * const events = await getContractEvents({\n * contract,\n * events: [\n *  userOperationRevertReasonEvent({\n *  userOpHash: ...,\n *  sender: ...,\n * })\n * ],\n * });\n * ```\n */\nexport function userOperationRevertReasonEvent(\n  filters: UserOperationRevertReasonEventFilters = {},\n) {\n  return prepareEvent({\n    signature:\n      \"event UserOperationRevertReason(bytes32 indexed userOpHash, address indexed sender, uint256 nonce, bytes revertReason)\",\n    filters,\n  });\n}\n", "import { prepareEvent } from \"../../../../../event/prepare-event.js\";\nimport type { AbiParameterToPrimitiveType } from \"abitype\";\n\n/**\n * Represents the filters for the \"PostOpRevertReason\" event.\n */\nexport type PostOpRevertReasonEventFilters = Partial<{\n  userOpHash: AbiParameterToPrimitiveType<{\n    type: \"bytes32\";\n    name: \"userOpHash\";\n    indexed: true;\n  }>;\n  sender: AbiParameterToPrimitiveType<{\n    type: \"address\";\n    name: \"sender\";\n    indexed: true;\n  }>;\n}>;\n\n/**\n * Creates an event object for the PostOpRevertReason event.\n * @param filters - Optional filters to apply to the event.\n * @returns The prepared event object.\n * @extension ERC4337\n * @example\n * ```ts\n * import { getContractEvents } from \"thirdweb\";\n * import { postOpRevertReasonEvent } from \"thirdweb/extensions/erc4337\";\n *\n * const events = await getContractEvents({\n * contract,\n * events: [\n *  postOpRevertReasonEvent({\n *  userOpHash: ...,\n *  sender: ...,\n * })\n * ],\n * });\n * ```\n */\nexport function postOpRevertReasonEvent(\n  filters: PostOpRevertReasonEventFilters = {},\n) {\n  return prepareEvent({\n    signature:\n      \"event PostOpRevertReason(bytes32 indexed userOpHash, address indexed sender, uint256 nonce, bytes revertReason)\",\n    filters,\n  });\n}\n", "import type { Address } from \"abitype\";\nimport type { Chain } from \"../../chains/types.js\";\nimport type { ThirdwebClient } from \"../../client/client.js\";\nimport type { ThirdwebContract } from \"../../contract/contract.js\";\nimport type { PreparedTransaction } from \"../../transaction/prepare-transaction.js\";\nimport type { TransactionReceipt } from \"../../transaction/types.js\";\nimport type { Hex } from \"../../utils/encoding/hex.js\";\nimport type { Prettify } from \"../../utils/type-utils.js\";\nimport type { Account, SendTransactionOption } from \"../interfaces/wallet.js\";\n\nexport type SmartWalletOptions = Prettify<\n  {\n    chain: Chain; // TODO consider making default chain optional\n    factoryAddress?: string;\n    overrides?: {\n      bundlerUrl?: string;\n      accountAddress?: string;\n      accountSalt?: string;\n      entrypointAddress?: string;\n      erc20Paymaster?: {\n        address: string;\n        token: string;\n      };\n      paymaster?: (\n        userOp: UserOperationV06 | UserOperationV07,\n      ) => Promise<PaymasterResult>;\n      predictAddress?: (factoryContract: ThirdwebContract) => Promise<string>;\n      createAccount?: (\n        factoryContract: ThirdwebContract,\n      ) => PreparedTransaction;\n      execute?: (\n        accountContract: ThirdwebContract,\n        transaction: SendTransactionOption,\n      ) => PreparedTransaction;\n      executeBatch?: (\n        accountContract: ThirdwebContract,\n        transactions: SendTransactionOption[],\n      ) => PreparedTransaction;\n      getAccountNonce?: (accountContract: ThirdwebContract) => Promise<bigint>;\n    };\n  } & (\n    | {\n        /**\n         * @deprecated use 'sponsorGas' instead\n         */\n        gasless: boolean;\n      }\n    | {\n        sponsorGas: boolean;\n      }\n  )\n>;\n\n// internal type\nexport type SmartAccountOptions = Prettify<\n  Omit<SmartWalletOptions, \"chain\" | \"gasless\" | \"sponsorGas\"> & {\n    chain: Chain;\n    sponsorGas: boolean;\n    personalAccount: Account;\n    factoryContract: ThirdwebContract;\n    accountContract: ThirdwebContract;\n    client: ThirdwebClient;\n  }\n>;\n\nexport type BundlerOptions = {\n  bundlerUrl?: string;\n  entrypointAddress?: string;\n  chain: Chain;\n  client: ThirdwebClient;\n};\n\nexport type SmartWalletConnectionOptions = {\n  personalAccount: Account;\n  client: ThirdwebClient;\n  chain?: Chain;\n};\n\nexport type UserOperationV06 = {\n  sender: Address;\n  nonce: bigint;\n  initCode: Hex;\n  callData: Hex;\n  callGasLimit: bigint;\n  verificationGasLimit: bigint;\n  preVerificationGas: bigint;\n  maxFeePerGas: bigint;\n  maxPriorityFeePerGas: bigint;\n  paymasterAndData: Hex;\n  signature: Hex;\n};\n\nexport type UserOperationV07 = {\n  sender: string; // address\n  nonce: bigint; // uint256\n  factory: string | undefined; // address\n  factoryData: Hex; // bytes\n  callData: Hex; // bytes\n  callGasLimit: bigint; // uint256\n  verificationGasLimit: bigint; // uint256\n  preVerificationGas: bigint; // uint256\n  maxFeePerGas: bigint; // uint256\n  maxPriorityFeePerGas: bigint; // uint256\n  paymaster: string | undefined; // address\n  paymasterData: Hex; // bytes\n  paymasterVerificationGasLimit: bigint; // uint256\n  paymasterPostOpGasLimit: bigint; // uint256\n  signature: Hex; // bytes\n};\n\nexport type PackedUserOperation = {\n  sender: string; // address\n  nonce: bigint; // uint256\n  initCode: Hex; // bytes\n  callData: Hex; // bytes\n  accountGasLimits: Hex; // bytes32\n  preVerificationGas: bigint; // uint256\n  gasFees: Hex; // bytes32\n  paymasterAndData: Hex; // bytes\n  signature: Hex; // bytes\n};\n\nexport type UserOperationV06Hexed = {\n  sender: Address;\n  nonce: Hex;\n  initCode: Hex;\n  callData: Hex;\n  callGasLimit: Hex;\n  verificationGasLimit: Hex;\n  preVerificationGas: Hex;\n  maxFeePerGas: Hex;\n  maxPriorityFeePerGas: Hex;\n  paymasterAndData: Hex;\n  signature: Hex;\n};\n\nexport type UserOperationV07Hexed = {\n  sender: Hex;\n  nonce: Hex;\n  factory: Hex;\n  factoryData: Hex;\n  callData: Hex;\n  callGasLimit: Hex;\n  verificationGasLimit: Hex;\n  preVerificationGas: Hex;\n  maxFeePerGas: Hex;\n  maxPriorityFeePerGas: Hex;\n  paymaster: Hex;\n  paymasterVerificationGasLimit: Hex;\n  paymasterPostOpGasLimit: Hex;\n  paymasterData: Hex;\n  signature: Hex;\n};\n\nexport type PaymasterResult = {\n  preVerificationGas?: bigint;\n  verificationGasLimit?: bigint;\n  callGasLimit?: bigint;\n} & (\n  | {\n      // v0.6 types\n      paymasterAndData: string;\n    }\n  | {\n      // v0.7 types\n      paymaster: string;\n      paymasterData: string;\n      paymasterVerificationGasLimit?: bigint;\n      paymasterPostOpGasLimit?: bigint;\n    }\n);\n\nexport type EstimationResult = {\n  preVerificationGas: bigint;\n  verificationGas?: bigint;\n  verificationGasLimit: bigint;\n  callGasLimit: bigint;\n  // v0.7 types\n  paymasterVerificationGasLimit?: bigint;\n  paymasterPostOpGasLimit?: bigint;\n};\n\nexport type GasPriceResult = {\n  maxFeePerGas: bigint;\n  maxPriorityFeePerGas: bigint;\n};\n\nexport type PmTransactionData = {\n  paymaster: Address;\n  paymasterInput: Hex;\n};\n\nexport type UserOperationReceipt = {\n  receipt: TransactionReceipt;\n  logs: TransactionReceipt[\"logs\"];\n  userOpHash: Hex;\n  entryPoint: Address;\n  sender: Address;\n  nonce: bigint;\n  paymaster: Address;\n  actualGasUsed: bigint;\n  actualGasCost: bigint;\n  success: boolean;\n};\n\nexport function formatUserOperationReceipt(\n  userOpReceiptRaw: UserOperationReceipt,\n) {\n  const { receipt: transactionReceipt } = userOpReceiptRaw;\n\n  const receipt = {\n    ...transactionReceipt,\n    transactionHash: transactionReceipt.transactionHash,\n    blockNumber: transactionReceipt.blockNumber\n      ? BigInt(transactionReceipt.blockNumber)\n      : null,\n    contractAddress: transactionReceipt.contractAddress\n      ? transactionReceipt.contractAddress\n      : null,\n    cumulativeGasUsed: transactionReceipt.cumulativeGasUsed\n      ? BigInt(transactionReceipt.cumulativeGasUsed)\n      : null,\n    effectiveGasPrice: transactionReceipt.effectiveGasPrice\n      ? BigInt(transactionReceipt.effectiveGasPrice)\n      : null,\n    gasUsed: transactionReceipt.gasUsed\n      ? BigInt(transactionReceipt.gasUsed)\n      : null,\n    logs: transactionReceipt.logs,\n    to: transactionReceipt.to ? transactionReceipt.to : null,\n    transactionIndex: transactionReceipt.transactionIndex,\n    status: transactionReceipt.status,\n    type: transactionReceipt.type,\n  } as TransactionReceipt;\n\n  if (transactionReceipt.blobGasPrice)\n    receipt.blobGasPrice = BigInt(transactionReceipt.blobGasPrice);\n  if (transactionReceipt.blobGasUsed)\n    receipt.blobGasUsed = BigInt(transactionReceipt.blobGasUsed);\n\n  const userOpReceipt = {\n    ...userOpReceiptRaw,\n    receipt,\n    userOpHash: userOpReceiptRaw.userOpHash,\n    actualGasCost: BigInt(userOpReceiptRaw.actualGasCost),\n    actualGasUsed: BigInt(userOpReceiptRaw.actualGasUsed),\n    nonce: BigInt(userOpReceiptRaw.nonce),\n  } as UserOperationReceipt;\n  return userOpReceipt;\n}\n", "import { isHex, toHex } from \"../../../utils/encoding/hex.js\";\nimport type {\n  UserOperationV06,\n  UserOperationV06Hexed,\n  UserOperationV07,\n  UserOperationV07Hexed,\n} from \"../types.js\";\n\nexport const generateRandomUint192 = (): bigint => {\n  const rand1 = BigInt(Math.floor(Math.random() * 0x100000000));\n  const rand2 = BigInt(Math.floor(Math.random() * 0x100000000));\n  const rand3 = BigInt(Math.floor(Math.random() * 0x100000000));\n  const rand4 = BigInt(Math.floor(Math.random() * 0x100000000));\n  const rand5 = BigInt(Math.floor(Math.random() * 0x100000000));\n  const rand6 = BigInt(Math.floor(Math.random() * 0x100000000));\n  return (\n    (rand1 << BigInt(160)) |\n    (rand2 << BigInt(128)) |\n    (rand3 << BigInt(96)) |\n    (rand4 << BigInt(64)) |\n    (rand5 << BigInt(32)) |\n    rand6\n  );\n};\n\n/**\n * @internal\n */\nexport function hexlifyUserOp(\n  userOp: UserOperationV06 | UserOperationV07,\n): UserOperationV06Hexed | UserOperationV07Hexed {\n  return Object.fromEntries(\n    Object.entries(userOp).map(([key, val]) => [\n      key,\n      // turn any value that's not hex into hex\n      val === undefined || val === null || isHex(val) ? val : toHex(val),\n    ]),\n  ) as UserOperationV06Hexed | UserOperationV07Hexed;\n}\n", "import { type TransactionSerializable, decodeErrorResult } from \"viem\";\nimport { parseEventLogs } from \"../../../event/actions/parse-logs.js\";\nimport { userOperationRevertReasonEvent } from \"../../../extensions/erc4337/__generated__/IEntryPoint/events/UserOperationRevertReason.js\";\nimport { postOpRevertReasonEvent } from \"../../../extensions/erc4337/__generated__/IEntryPoint_v07/events/PostOpRevertReason.js\";\nimport type { TransactionReceipt } from \"../../../transaction/types.js\";\nimport { type Hex, hexToBigInt } from \"../../../utils/encoding/hex.js\";\nimport { getClientFetch } from \"../../../utils/fetch.js\";\nimport { stringify } from \"../../../utils/json.js\";\nimport {\n  type BundlerOptions,\n  type EstimationResult,\n  type GasPriceResult,\n  type PmTransactionData,\n  type UserOperationReceipt,\n  type UserOperationV06,\n  type UserOperationV07,\n  formatUserOperationReceipt,\n} from \"../types.js\";\nimport {\n  DEBUG,\n  ENTRYPOINT_ADDRESS_v0_6,\n  MANAGED_ACCOUNT_GAS_BUFFER,\n  getDefaultBundlerUrl,\n} from \"./constants.js\";\nimport { hexlifyUserOp } from \"./utils.js\";\n\n/**\n * Bundle a user operation.\n * @param args - The options for bundling a user operation.\n * @returns The bundle hash of the user operation.\n * @example\n * ```ts\n * import { bundleUserOp } from \"thirdweb/wallets/smart\";\n *\n * const userOpHash = await bundleUserOp({\n *  userOp,\n *  options,\n * });\n * ```\n * @walletUtils\n */\nexport async function bundleUserOp(args: {\n  userOp: UserOperationV06 | UserOperationV07;\n  options: BundlerOptions;\n}): Promise<Hex> {\n  return sendBundlerRequest({\n    ...args,\n    operation: \"eth_sendUserOperation\",\n    params: [\n      hexlifyUserOp(args.userOp),\n      args.options.entrypointAddress ?? ENTRYPOINT_ADDRESS_v0_6,\n    ],\n  });\n}\n\n/**\n * Estimate the gas cost of a user operation.\n * @param args - The options for estimating the gas cost of a user operation.\n * @returns The estimated gas cost of the user operation.\n * @example\n * ```ts\n * import { estimateUserOpGas } from \"thirdweb/wallets/smart\";\n *\n * const gasCost = await estimateUserOpGas({\n *  userOp,\n *  options,\n * });\n * ```\n * @walletUtils\n */\nexport async function estimateUserOpGas(args: {\n  userOp: UserOperationV06 | UserOperationV07;\n  options: BundlerOptions;\n}): Promise<EstimationResult> {\n  const res = await sendBundlerRequest({\n    ...args,\n    operation: \"eth_estimateUserOperationGas\",\n    params: [\n      hexlifyUserOp(args.userOp),\n      args.options.entrypointAddress ?? ENTRYPOINT_ADDRESS_v0_6,\n    ],\n  });\n\n  // add gas buffer for managed account factory delegate calls\n  return {\n    preVerificationGas: hexToBigInt(res.preVerificationGas),\n    verificationGas:\n      res.verificationGas !== undefined\n        ? hexToBigInt(res.verificationGas)\n        : undefined,\n    verificationGasLimit: hexToBigInt(res.verificationGasLimit),\n    callGasLimit: hexToBigInt(res.callGasLimit) + MANAGED_ACCOUNT_GAS_BUFFER,\n    paymasterVerificationGasLimit:\n      res.paymasterVerificationGasLimit !== undefined\n        ? hexToBigInt(res.paymasterVerificationGasLimit)\n        : undefined,\n    paymasterPostOpGasLimit:\n      res.paymasterPostOpGasLimit !== undefined\n        ? hexToBigInt(res.paymasterPostOpGasLimit)\n        : undefined,\n  };\n}\n\n/**\n * Get the gas fees of a user operation.\n * @param args - The options for getting the gas price of a user operation.\n * @returns The gas price of the user operation.\n * @example\n * ```ts\n * import { getUserOpGasPrice } from \"thirdweb/wallets/smart\";\n *\n * const fees = await getUserOpGasPrice({\n *  options,\n * });\n * ```\n * @walletUtils\n */\nexport async function getUserOpGasFees(args: {\n  options: BundlerOptions;\n}): Promise<GasPriceResult> {\n  const res = await sendBundlerRequest({\n    ...args,\n    operation: \"thirdweb_getUserOperationGasPrice\",\n    params: [],\n  });\n\n  return {\n    maxPriorityFeePerGas: hexToBigInt(res.maxPriorityFeePerGas),\n    maxFeePerGas: hexToBigInt(res.maxFeePerGas),\n  };\n}\n\n/**\n * Get the receipt of a user operation.\n * @param args - The options for getting the receipt of a user operation.\n * @returns The receipt of the user operation.\n * @example\n * ```ts\n * import { getUserOpReceipt } from \"thirdweb/wallets/smart\";\n *\n * const receipt = await getUserOpReceipt({\n *  client,\n *  chain,\n *  userOpHash,\n * });\n * ```\n * @walletUtils\n */\nexport async function getUserOpReceipt(\n  args: BundlerOptions & {\n    userOpHash: Hex;\n  },\n): Promise<TransactionReceipt | undefined> {\n  const res = await getUserOpReceiptRaw(args);\n\n  if (!res) {\n    return undefined;\n  }\n\n  if (res.success === false) {\n    // parse revert reason\n    const logs = parseEventLogs({\n      events: [userOperationRevertReasonEvent(), postOpRevertReasonEvent()],\n      logs: res.logs,\n    });\n    const revertReason = logs[0]?.args?.revertReason;\n    if (!revertReason) {\n      throw new Error(\n        `UserOp failed at txHash: ${res.receipt.transactionHash}`,\n      );\n    }\n    const revertMsg = decodeErrorResult({\n      data: revertReason,\n    });\n    throw new Error(\n      `UserOp failed with reason: '${revertMsg.args.join(\",\")}' at txHash: ${\n        res.receipt.transactionHash\n      }`,\n    );\n  }\n  return res.receipt;\n}\n\n/**\n * Get the receipt of a user operation.\n * @param args - The options for getting the receipt of a user operation.\n * @returns The raw receipt of the user operation.\n * @example\n * ```ts\n * import { getUserOpReceiptRaw } from \"thirdweb/wallets/smart\";\n *\n * const receipt = await getUserOpReceiptRaw({\n *  client,\n *  chain,\n *  userOpHash,\n * });\n * ```\n * @walletUtils\n */\nexport async function getUserOpReceiptRaw(\n  args: BundlerOptions & {\n    userOpHash: Hex;\n  },\n): Promise<UserOperationReceipt | undefined> {\n  const res = await sendBundlerRequest({\n    options: args,\n    operation: \"eth_getUserOperationReceipt\",\n    params: [args.userOpHash],\n  });\n  if (!res) {\n    return undefined;\n  }\n  return formatUserOperationReceipt(res as UserOperationReceipt);\n}\n\n/**\n * @internal\n */\nexport async function getZkPaymasterData(args: {\n  options: BundlerOptions;\n  transaction: TransactionSerializable;\n}): Promise<PmTransactionData> {\n  const res = await sendBundlerRequest({\n    options: args.options,\n    operation: \"zk_paymasterData\",\n    params: [args.transaction],\n  });\n\n  return {\n    paymaster: res.paymaster,\n    paymasterInput: res.paymasterInput,\n  };\n}\n\nexport async function broadcastZkTransaction(args: {\n  options: BundlerOptions;\n  transaction: TransactionSerializable;\n  signedTransaction: Hex;\n}): Promise<{ transactionHash: Hex }> {\n  const res = await sendBundlerRequest({\n    options: args.options,\n    operation: \"zk_broadcastTransaction\",\n    params: [\n      {\n        ...args.transaction,\n        signedTransaction: args.signedTransaction,\n      },\n    ],\n  });\n\n  return {\n    transactionHash: res.transactionHash,\n  };\n}\n\nasync function sendBundlerRequest(args: {\n  options: BundlerOptions;\n  operation:\n    | \"eth_estimateUserOperationGas\"\n    | \"eth_sendUserOperation\"\n    | \"eth_getUserOperationReceipt\"\n    | \"thirdweb_getUserOperationGasPrice\"\n    | \"zk_paymasterData\"\n    | \"zk_broadcastTransaction\";\n  // biome-ignore lint/suspicious/noExplicitAny: TODO: fix any\n  params: any[];\n}) {\n  const { options, operation, params } = args;\n\n  if (DEBUG) {\n    console.debug(`>>> sending ${operation} with payload:`, params);\n  }\n\n  const bundlerUrl = options.bundlerUrl ?? getDefaultBundlerUrl(options.chain);\n  const fetchWithHeaders = getClientFetch(options.client);\n  const response = await fetchWithHeaders(bundlerUrl, {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n    },\n    body: stringify({\n      jsonrpc: \"2.0\",\n      id: 1,\n      method: operation,\n      params,\n    }),\n  });\n  const res = await response.json();\n\n  if (!response.ok || res.error) {\n    let error = res.error || response.statusText;\n    if (typeof error === \"object\") {\n      error = stringify(error);\n    }\n    const code = res.code || \"UNKNOWN\";\n\n    throw new Error(\n      `${operation} error: ${error}\nStatus: ${response.status}\nCode: ${code}`,\n    );\n  }\n\n  if (DEBUG) {\n    console.debug(`<<< ${operation} result:`, res);\n  }\n\n  return res.result;\n}\n", "import type { Chain } from \"../../../chains/types.js\";\nimport type { ThirdwebClient } from \"../../../client/client.js\";\nimport {\n  type ThirdwebContract,\n  getContract,\n} from \"../../../contract/contract.js\";\nimport { prepareContractCall } from \"../../../transaction/prepare-contract-call.js\";\nimport type { PreparedTransaction } from \"../../../transaction/prepare-transaction.js\";\nimport { readContract } from \"../../../transaction/read-contract.js\";\nimport { isHex, stringToHex } from \"../../../utils/encoding/hex.js\";\nimport type { SendTransactionOption } from \"../../interfaces/wallet.js\";\nimport { DEFAULT_ACCOUNT_FACTORY_V0_6 } from \"./constants.js\";\n\n/**\n * Predict the address of a smart account.\n * @param args - The options for predicting the address of a smart account.\n * @returns The predicted address of the smart account.\n * @example\n * ```ts\n * import { predictSmartAccountAddress } from \"thirdweb/wallets/smart\";\n *\n * const predictedAddress = await predictSmartAccountAddress({\n *  client,\n *  chain,\n *  adminAddress,\n * });\n * ```\n * @walletUtils\n */\nexport async function predictSmartAccountAddress(args: {\n  client: ThirdwebClient;\n  chain: Chain;\n  adminAddress: string;\n  factoryAddress?: string;\n  accountSalt?: string;\n}): Promise<string> {\n  return predictAddress({\n    adminAddress: args.adminAddress,\n    accountSalt: args.accountSalt,\n    factoryContract: getContract({\n      address: args.factoryAddress ?? DEFAULT_ACCOUNT_FACTORY_V0_6,\n      chain: args.chain,\n      client: args.client,\n    }),\n  });\n}\n\n/**\n * Predict the address of a smart account.\n * @param args - The options for predicting the address of a smart account.\n * @returns The predicted address of the smart account.\n * @example\n * ```ts\n * import { predictAddress } from \"thirdweb/wallets/smart\";\n *\n * const predictedAddress = await predictAddress({\n *  factoryContract,\n *  adminAddress,\n *  accountSalt,\n * });\n * ```\n * @walletUtils\n * @deprecated Use `predictSmartAccountAddress` instead.\n */\nexport async function predictAddress(args: {\n  factoryContract: ThirdwebContract;\n  predictAddressOverride?: (\n    factoryContract: ThirdwebContract,\n  ) => Promise<string>;\n  adminAddress: string;\n  accountSalt?: string;\n  accountAddress?: string;\n}): Promise<string> {\n  const {\n    factoryContract,\n    predictAddressOverride: predictAddress,\n    adminAddress,\n    accountSalt,\n    accountAddress,\n  } = args;\n  if (predictAddress) {\n    return predictAddress(factoryContract);\n  }\n  if (accountAddress) {\n    return accountAddress;\n  }\n  if (!adminAddress) {\n    throw new Error(\n      \"Account address is required to predict the smart wallet address.\",\n    );\n  }\n  const saltHex =\n    accountSalt && isHex(accountSalt)\n      ? accountSalt\n      : stringToHex(accountSalt ?? \"\");\n  return readContract({\n    contract: factoryContract,\n    method: \"function getAddress(address, bytes) returns (address)\",\n    params: [adminAddress, saltHex],\n  });\n}\n\n/**\n * @internal\n */\nexport function prepareCreateAccount(args: {\n  factoryContract: ThirdwebContract;\n  adminAddress: string;\n  accountSalt?: string;\n  createAccountOverride?: (\n    factoryContract: ThirdwebContract,\n  ) => PreparedTransaction;\n}): PreparedTransaction {\n  const {\n    adminAddress,\n    factoryContract,\n    createAccountOverride: createAccount,\n    accountSalt,\n  } = args;\n  if (createAccount) {\n    return createAccount(factoryContract);\n  }\n  const saltHex =\n    accountSalt && isHex(accountSalt)\n      ? accountSalt\n      : stringToHex(accountSalt ?? \"\");\n  return prepareContractCall({\n    contract: factoryContract,\n    method: \"function createAccount(address, bytes) returns (address)\",\n    params: [adminAddress, saltHex],\n  });\n}\n\n/**\n * @internal\n */\nexport function prepareExecute(args: {\n  accountContract: ThirdwebContract;\n  transaction: SendTransactionOption;\n  executeOverride?: (\n    accountContract: ThirdwebContract,\n    transaction: SendTransactionOption,\n  ) => PreparedTransaction;\n}): PreparedTransaction {\n  const { accountContract, transaction, executeOverride: execute } = args;\n  if (execute) {\n    return execute(accountContract, transaction);\n  }\n  return prepareContractCall({\n    contract: accountContract,\n    method: \"function execute(address, uint256, bytes)\",\n    params: [\n      transaction.to || \"\",\n      transaction.value || 0n,\n      transaction.data || \"0x\",\n    ],\n    // if gas is specified for the inner tx, use that and add 21k for the execute call on the account contract\n    // this avoids another estimateGas call when bundling the userOp\n    // and also allows for passing custom gas limits for the inner tx\n    gas: transaction.gas ? transaction.gas + 21000n : undefined,\n  });\n}\n\n/**\n * @internal\n */\nexport function prepareBatchExecute(args: {\n  accountContract: ThirdwebContract;\n  transactions: SendTransactionOption[];\n  executeBatchOverride?: (\n    accountContract: ThirdwebContract,\n    transactions: SendTransactionOption[],\n  ) => PreparedTransaction;\n}): PreparedTransaction {\n  const {\n    accountContract,\n    transactions,\n    executeBatchOverride: executeBatch,\n  } = args;\n  if (executeBatch) {\n    return executeBatch(accountContract, transactions);\n  }\n  return prepareContractCall({\n    contract: accountContract,\n    method: \"function executeBatch(address[], uint256[], bytes[])\",\n    params: [\n      transactions.map((tx) => tx.to || \"\"),\n      transactions.map((tx) => tx.value || 0n),\n      transactions.map((tx) => tx.data || \"0x\"),\n    ],\n  });\n}\n", "import type { AbiParameterToPrimitiveType } from \"abitype\";\nimport { readContract } from \"../../../../../transaction/read-contract.js\";\nimport type { BaseTransactionOptions } from \"../../../../../transaction/types.js\";\nimport { encodeAbiParameters } from \"../../../../../utils/abi/encodeAbiParameters.js\";\nimport { decodeAbiParameters } from \"viem\";\nimport type { Hex } from \"../../../../../utils/encoding/hex.js\";\nimport { detectMethod } from \"../../../../../utils/bytecode/detectExtension.js\";\n\n/**\n * Represents the parameters for the \"getNonce\" function.\n */\nexport type GetNonceParams = {\n  sender: AbiParameterToPrimitiveType<{ type: \"address\"; name: \"sender\" }>;\n  key: AbiParameterToPrimitiveType<{ type: \"uint192\"; name: \"key\" }>;\n};\n\nexport const FN_SELECTOR = \"0x35567e1a\" as const;\nconst FN_INPUTS = [\n  {\n    type: \"address\",\n    name: \"sender\",\n  },\n  {\n    type: \"uint192\",\n    name: \"key\",\n  },\n] as const;\nconst FN_OUTPUTS = [\n  {\n    type: \"uint256\",\n    name: \"nonce\",\n  },\n] as const;\n\n/**\n * Checks if the `getNonce` method is supported by the given contract.\n * @param availableSelectors An array of 4byte function selectors of the contract. You can get this in various ways, such as using \"whatsabi\" or if you have the ABI of the contract available you can use it to generate the selectors.\n * @returns A boolean indicating if the `getNonce` method is supported.\n * @extension ERC4337\n * @example\n * ```ts\n * import { isGetNonceSupported } from \"thirdweb/extensions/erc4337\";\n * const supported = isGetNonceSupported([\"0x...\"]);\n * ```\n */\nexport function isGetNonceSupported(availableSelectors: string[]) {\n  return detectMethod({\n    availableSelectors,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n  });\n}\n\n/**\n * Encodes the parameters for the \"getNonce\" function.\n * @param options - The options for the getNonce function.\n * @returns The encoded ABI parameters.\n * @extension ERC4337\n * @example\n * ```ts\n * import { encodeGetNonceParams } from \"thirdweb/extensions/erc4337\";\n * const result = encodeGetNonceParams({\n *  sender: ...,\n *  key: ...,\n * });\n * ```\n */\nexport function encodeGetNonceParams(options: GetNonceParams) {\n  return encodeAbiParameters(FN_INPUTS, [options.sender, options.key]);\n}\n\n/**\n * Encodes the \"getNonce\" function into a Hex string with its parameters.\n * @param options - The options for the getNonce function.\n * @returns The encoded hexadecimal string.\n * @extension ERC4337\n * @example\n * ```ts\n * import { encodeGetNonce } from \"thirdweb/extensions/erc4337\";\n * const result = encodeGetNonce({\n *  sender: ...,\n *  key: ...,\n * });\n * ```\n */\nexport function encodeGetNonce(options: GetNonceParams) {\n  // we do a \"manual\" concat here to avoid the overhead of the \"concatHex\" function\n  // we can do this because we know the specific formats of the values\n  return (FN_SELECTOR +\n    encodeGetNonceParams(options).slice(2)) as `${typeof FN_SELECTOR}${string}`;\n}\n\n/**\n * Decodes the result of the getNonce function call.\n * @param result - The hexadecimal result to decode.\n * @returns The decoded result as per the FN_OUTPUTS definition.\n * @extension ERC4337\n * @example\n * ```ts\n * import { decodeGetNonceResult } from \"thirdweb/extensions/erc4337\";\n * const result = decodeGetNonceResultResult(\"...\");\n * ```\n */\nexport function decodeGetNonceResult(result: Hex) {\n  return decodeAbiParameters(FN_OUTPUTS, result)[0];\n}\n\n/**\n * Calls the \"getNonce\" function on the contract.\n * @param options - The options for the getNonce function.\n * @returns The parsed result of the function call.\n * @extension ERC4337\n * @example\n * ```ts\n * import { getNonce } from \"thirdweb/extensions/erc4337\";\n *\n * const result = await getNonce({\n *  contract,\n *  sender: ...,\n *  key: ...,\n * });\n *\n * ```\n */\nexport async function getNonce(\n  options: BaseTransactionOptions<GetNonceParams>,\n) {\n  return readContract({\n    contract: options.contract,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n    params: [options.sender, options.key],\n  });\n}\n", "import type { AbiParameterToPrimitiveType } from \"abitype\";\nimport { readContract } from \"../../../../../transaction/read-contract.js\";\nimport type { BaseTransactionOptions } from \"../../../../../transaction/types.js\";\nimport { encodeAbiParameters } from \"../../../../../utils/abi/encodeAbiParameters.js\";\nimport { decodeAbiParameters } from \"viem\";\nimport type { Hex } from \"../../../../../utils/encoding/hex.js\";\nimport { detectMethod } from \"../../../../../utils/bytecode/detectExtension.js\";\n\n/**\n * Represents the parameters for the \"getUserOpHash\" function.\n */\nexport type GetUserOpHashParams = {\n  userOp: AbiParameterToPrimitiveType<{\n    type: \"tuple\";\n    name: \"userOp\";\n    components: [\n      { type: \"address\"; name: \"sender\" },\n      { type: \"uint256\"; name: \"nonce\" },\n      { type: \"bytes\"; name: \"initCode\" },\n      { type: \"bytes\"; name: \"callData\" },\n      { type: \"uint256\"; name: \"callGasLimit\" },\n      { type: \"uint256\"; name: \"verificationGasLimit\" },\n      { type: \"uint256\"; name: \"preVerificationGas\" },\n      { type: \"uint256\"; name: \"maxFeePerGas\" },\n      { type: \"uint256\"; name: \"maxPriorityFeePerGas\" },\n      { type: \"bytes\"; name: \"paymasterAndData\" },\n      { type: \"bytes\"; name: \"signature\" },\n    ];\n  }>;\n};\n\nexport const FN_SELECTOR = \"0xa6193531\" as const;\nconst FN_INPUTS = [\n  {\n    type: \"tuple\",\n    name: \"userOp\",\n    components: [\n      {\n        type: \"address\",\n        name: \"sender\",\n      },\n      {\n        type: \"uint256\",\n        name: \"nonce\",\n      },\n      {\n        type: \"bytes\",\n        name: \"initCode\",\n      },\n      {\n        type: \"bytes\",\n        name: \"callData\",\n      },\n      {\n        type: \"uint256\",\n        name: \"callGasLimit\",\n      },\n      {\n        type: \"uint256\",\n        name: \"verificationGasLimit\",\n      },\n      {\n        type: \"uint256\",\n        name: \"preVerificationGas\",\n      },\n      {\n        type: \"uint256\",\n        name: \"maxFeePerGas\",\n      },\n      {\n        type: \"uint256\",\n        name: \"maxPriorityFeePerGas\",\n      },\n      {\n        type: \"bytes\",\n        name: \"paymasterAndData\",\n      },\n      {\n        type: \"bytes\",\n        name: \"signature\",\n      },\n    ],\n  },\n] as const;\nconst FN_OUTPUTS = [\n  {\n    type: \"bytes32\",\n  },\n] as const;\n\n/**\n * Checks if the `getUserOpHash` method is supported by the given contract.\n * @param availableSelectors An array of 4byte function selectors of the contract. You can get this in various ways, such as using \"whatsabi\" or if you have the ABI of the contract available you can use it to generate the selectors.\n * @returns A boolean indicating if the `getUserOpHash` method is supported.\n * @extension ERC4337\n * @example\n * ```ts\n * import { isGetUserOpHashSupported } from \"thirdweb/extensions/erc4337\";\n * const supported = isGetUserOpHashSupported([\"0x...\"]);\n * ```\n */\nexport function isGetUserOpHashSupported(availableSelectors: string[]) {\n  return detectMethod({\n    availableSelectors,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n  });\n}\n\n/**\n * Encodes the parameters for the \"getUserOpHash\" function.\n * @param options - The options for the getUserOpHash function.\n * @returns The encoded ABI parameters.\n * @extension ERC4337\n * @example\n * ```ts\n * import { encodeGetUserOpHashParams } from \"thirdweb/extensions/erc4337\";\n * const result = encodeGetUserOpHashParams({\n *  userOp: ...,\n * });\n * ```\n */\nexport function encodeGetUserOpHashParams(options: GetUserOpHashParams) {\n  return encodeAbiParameters(FN_INPUTS, [options.userOp]);\n}\n\n/**\n * Encodes the \"getUserOpHash\" function into a Hex string with its parameters.\n * @param options - The options for the getUserOpHash function.\n * @returns The encoded hexadecimal string.\n * @extension ERC4337\n * @example\n * ```ts\n * import { encodeGetUserOpHash } from \"thirdweb/extensions/erc4337\";\n * const result = encodeGetUserOpHash({\n *  userOp: ...,\n * });\n * ```\n */\nexport function encodeGetUserOpHash(options: GetUserOpHashParams) {\n  // we do a \"manual\" concat here to avoid the overhead of the \"concatHex\" function\n  // we can do this because we know the specific formats of the values\n  return (FN_SELECTOR +\n    encodeGetUserOpHashParams(options).slice(\n      2,\n    )) as `${typeof FN_SELECTOR}${string}`;\n}\n\n/**\n * Decodes the result of the getUserOpHash function call.\n * @param result - The hexadecimal result to decode.\n * @returns The decoded result as per the FN_OUTPUTS definition.\n * @extension ERC4337\n * @example\n * ```ts\n * import { decodeGetUserOpHashResult } from \"thirdweb/extensions/erc4337\";\n * const result = decodeGetUserOpHashResultResult(\"...\");\n * ```\n */\nexport function decodeGetUserOpHashResult(result: Hex) {\n  return decodeAbiParameters(FN_OUTPUTS, result)[0];\n}\n\n/**\n * Calls the \"getUserOpHash\" function on the contract.\n * @param options - The options for the getUserOpHash function.\n * @returns The parsed result of the function call.\n * @extension ERC4337\n * @example\n * ```ts\n * import { getUserOpHash } from \"thirdweb/extensions/erc4337\";\n *\n * const result = await getUserOpHash({\n *  contract,\n *  userOp: ...,\n * });\n *\n * ```\n */\nexport async function getUserOpHash(\n  options: BaseTransactionOptions<GetUserOpHashParams>,\n) {\n  return readContract({\n    contract: options.contract,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n    params: [options.userOp],\n  });\n}\n", "import type { AbiParameterToPrimitiveType } from \"abitype\";\nimport { readContract } from \"../../../../../transaction/read-contract.js\";\nimport type { BaseTransactionOptions } from \"../../../../../transaction/types.js\";\nimport { encodeAbiParameters } from \"../../../../../utils/abi/encodeAbiParameters.js\";\nimport { decodeAbiParameters } from \"viem\";\nimport type { Hex } from \"../../../../../utils/encoding/hex.js\";\nimport { detectMethod } from \"../../../../../utils/bytecode/detectExtension.js\";\n\n/**\n * Represents the parameters for the \"getUserOpHash\" function.\n */\nexport type GetUserOpHashParams = {\n  userOp: AbiParameterToPrimitiveType<{\n    type: \"tuple\";\n    name: \"userOp\";\n    components: [\n      { type: \"address\"; name: \"sender\" },\n      { type: \"uint256\"; name: \"nonce\" },\n      { type: \"bytes\"; name: \"initCode\" },\n      { type: \"bytes\"; name: \"callData\" },\n      { type: \"bytes32\"; name: \"accountGasLimits\" },\n      { type: \"uint256\"; name: \"preVerificationGas\" },\n      { type: \"bytes32\"; name: \"gasFees\" },\n      { type: \"bytes\"; name: \"paymasterAndData\" },\n      { type: \"bytes\"; name: \"signature\" },\n    ];\n  }>;\n};\n\nexport const FN_SELECTOR = \"0x22cdde4c\" as const;\nconst FN_INPUTS = [\n  {\n    type: \"tuple\",\n    name: \"userOp\",\n    components: [\n      {\n        type: \"address\",\n        name: \"sender\",\n      },\n      {\n        type: \"uint256\",\n        name: \"nonce\",\n      },\n      {\n        type: \"bytes\",\n        name: \"initCode\",\n      },\n      {\n        type: \"bytes\",\n        name: \"callData\",\n      },\n      {\n        type: \"bytes32\",\n        name: \"accountGasLimits\",\n      },\n      {\n        type: \"uint256\",\n        name: \"preVerificationGas\",\n      },\n      {\n        type: \"bytes32\",\n        name: \"gasFees\",\n      },\n      {\n        type: \"bytes\",\n        name: \"paymasterAndData\",\n      },\n      {\n        type: \"bytes\",\n        name: \"signature\",\n      },\n    ],\n  },\n] as const;\nconst FN_OUTPUTS = [\n  {\n    type: \"bytes32\",\n  },\n] as const;\n\n/**\n * Checks if the `getUserOpHash` method is supported by the given contract.\n * @param availableSelectors An array of 4byte function selectors of the contract. You can get this in various ways, such as using \"whatsabi\" or if you have the ABI of the contract available you can use it to generate the selectors.\n * @returns A boolean indicating if the `getUserOpHash` method is supported.\n * @extension ERC4337\n * @example\n * ```ts\n * import { isGetUserOpHashSupported } from \"thirdweb/extensions/erc4337\";\n * const supported = isGetUserOpHashSupported([\"0x...\"]);\n * ```\n */\nexport function isGetUserOpHashSupported(availableSelectors: string[]) {\n  return detectMethod({\n    availableSelectors,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n  });\n}\n\n/**\n * Encodes the parameters for the \"getUserOpHash\" function.\n * @param options - The options for the getUserOpHash function.\n * @returns The encoded ABI parameters.\n * @extension ERC4337\n * @example\n * ```ts\n * import { encodeGetUserOpHashParams } from \"thirdweb/extensions/erc4337\";\n * const result = encodeGetUserOpHashParams({\n *  userOp: ...,\n * });\n * ```\n */\nexport function encodeGetUserOpHashParams(options: GetUserOpHashParams) {\n  return encodeAbiParameters(FN_INPUTS, [options.userOp]);\n}\n\n/**\n * Encodes the \"getUserOpHash\" function into a Hex string with its parameters.\n * @param options - The options for the getUserOpHash function.\n * @returns The encoded hexadecimal string.\n * @extension ERC4337\n * @example\n * ```ts\n * import { encodeGetUserOpHash } from \"thirdweb/extensions/erc4337\";\n * const result = encodeGetUserOpHash({\n *  userOp: ...,\n * });\n * ```\n */\nexport function encodeGetUserOpHash(options: GetUserOpHashParams) {\n  // we do a \"manual\" concat here to avoid the overhead of the \"concatHex\" function\n  // we can do this because we know the specific formats of the values\n  return (FN_SELECTOR +\n    encodeGetUserOpHashParams(options).slice(\n      2,\n    )) as `${typeof FN_SELECTOR}${string}`;\n}\n\n/**\n * Decodes the result of the getUserOpHash function call.\n * @param result - The hexadecimal result to decode.\n * @returns The decoded result as per the FN_OUTPUTS definition.\n * @extension ERC4337\n * @example\n * ```ts\n * import { decodeGetUserOpHashResult } from \"thirdweb/extensions/erc4337\";\n * const result = decodeGetUserOpHashResultResult(\"...\");\n * ```\n */\nexport function decodeGetUserOpHashResult(result: Hex) {\n  return decodeAbiParameters(FN_OUTPUTS, result)[0];\n}\n\n/**\n * Calls the \"getUserOpHash\" function on the contract.\n * @param options - The options for the getUserOpHash function.\n * @returns The parsed result of the function call.\n * @extension ERC4337\n * @example\n * ```ts\n * import { getUserOpHash } from \"thirdweb/extensions/erc4337\";\n *\n * const result = await getUserOpHash({\n *  contract,\n *  userOp: ...,\n * });\n *\n * ```\n */\nexport async function getUserOpHash(\n  options: BaseTransactionOptions<GetUserOpHashParams>,\n) {\n  return readContract({\n    contract: options.contract,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n    params: [options.userOp],\n  });\n}\n", "import { type Hex, concat, pad, toHex } from \"viem\";\nimport type { PackedUserOperation, UserOperationV07 } from \"../types.js\";\n\nfunction getInitCode(unpackedUserOperation: UserOperationV07) {\n  return unpackedUserOperation.factory\n    ? concat([\n        unpackedUserOperation.factory as Hex,\n        unpackedUserOperation.factoryData || (\"0x\" as Hex),\n      ])\n    : \"0x\";\n}\n\nfunction getAccountGasLimits(unpackedUserOperation: UserOperationV07) {\n  return concat([\n    pad(toHex(unpackedUserOperation.verificationGasLimit), {\n      size: 16,\n    }),\n    pad(toHex(unpackedUserOperation.callGasLimit), { size: 16 }),\n  ]) as Hex;\n}\n\nfunction getGasLimits(unpackedUserOperation: UserOperationV07) {\n  return concat([\n    pad(toHex(unpackedUserOperation.maxPriorityFeePerGas), {\n      size: 16,\n    }),\n    pad(toHex(unpackedUserOperation.maxFeePerGas), { size: 16 }),\n  ]) as Hex;\n}\n\nfunction getPaymasterAndData(unpackedUserOperation: UserOperationV07) {\n  return unpackedUserOperation.paymaster\n    ? concat([\n        unpackedUserOperation.paymaster as Hex,\n        pad(\n          toHex(\n            unpackedUserOperation.paymasterVerificationGasLimit || BigInt(0),\n          ),\n          {\n            size: 16,\n          },\n        ),\n        pad(toHex(unpackedUserOperation.paymasterPostOpGasLimit || BigInt(0)), {\n          size: 16,\n        }),\n        unpackedUserOperation.paymasterData || (\"0x\" as Hex),\n      ])\n    : \"0x\";\n}\n\nexport const getPackedUserOperation = (\n  userOperation: UserOperationV07,\n): PackedUserOperation => {\n  return {\n    sender: userOperation.sender,\n    nonce: userOperation.nonce,\n    initCode: getInitCode(userOperation),\n    callData: userOperation.callData,\n    accountGasLimits: getAccountGasLimits(userOperation),\n    preVerificationGas: userOperation.preVerificationGas,\n    gasFees: getGasLimits(userOperation),\n    paymasterAndData: getPaymasterAndData(userOperation),\n    signature: userOperation.signature,\n  };\n};\n", "import type { Chain } from \"../../../chains/types.js\";\nimport type { ThirdwebClient } from \"../../../client/client.js\";\nimport { hexToBigInt } from \"../../../utils/encoding/hex.js\";\nimport { getClientFetch } from \"../../../utils/fetch.js\";\nimport { stringify } from \"../../../utils/json.js\";\nimport type {\n  PaymasterResult,\n  UserOperationV06,\n  UserOperationV07,\n} from \"../types.js\";\nimport {\n  DEBUG,\n  ENTRYPOINT_ADDRESS_v0_6,\n  getDefaultBundlerUrl,\n} from \"./constants.js\";\nimport { hexlifyUserOp } from \"./utils.js\";\n\n/**\n * Get paymaster and data details for a user operation.\n * @param args - The userOp and options\n * @returns - The paymaster and data details for the user operation.\n * @example\n * ```ts\n * import { getPaymasterAndData } from \"thirdweb/wallets/smart\";\n *\n * const userOp = createUnsignedUserOp(...);\n *\n * const paymasterAndData = await getPaymasterAndData({\n *  userOp,\n *  client,\n *  chain,\n * });\n * ```\n * @walletUtils\n */\nexport async function getPaymasterAndData(args: {\n  userOp: UserOperationV06 | UserOperationV07;\n  client: ThirdwebClient;\n  chain: Chain;\n  entrypointAddress?: string;\n  paymasterOverride?: (\n    userOp: UserOperationV06 | UserOperationV07,\n  ) => Promise<PaymasterResult>;\n}): Promise<PaymasterResult> {\n  const { userOp, paymasterOverride, client, chain, entrypointAddress } = args;\n\n  if (paymasterOverride) {\n    return paymasterOverride(userOp);\n  }\n\n  const headers: Record<string, string> = {\n    \"Content-Type\": \"application/json\",\n  };\n\n  const entrypoint = entrypointAddress ?? ENTRYPOINT_ADDRESS_v0_6;\n  const paymasterUrl = getDefaultBundlerUrl(chain);\n\n  // Ask the paymaster to sign the transaction and return a valid paymasterAndData value.\n  const fetchWithHeaders = getClientFetch(client);\n  const response = await fetchWithHeaders(paymasterUrl, {\n    method: \"POST\",\n    headers,\n    body: stringify({\n      jsonrpc: \"2.0\",\n      id: 1,\n      method: \"pm_sponsorUserOperation\",\n      params: [hexlifyUserOp(userOp), entrypoint],\n    }),\n  });\n  const res = await response.json();\n\n  if (!response.ok) {\n    const error = res.error || response.statusText;\n    const code = res.code || \"UNKNOWN\";\n\n    throw new Error(\n      `Paymaster error: ${error}\nStatus: ${response.status}\nCode: ${code}`,\n    );\n  }\n\n  if (DEBUG) {\n    console.debug(\"Paymaster result:\", res);\n  }\n\n  if (res.result) {\n    // some paymasters return a string, some return an object with more data\n    if (typeof res.result === \"string\") {\n      return {\n        paymasterAndData: res.result,\n      };\n    }\n    return {\n      paymasterAndData: res.result.paymasterAndData,\n      verificationGasLimit: res.result.verificationGasLimit\n        ? hexToBigInt(res.result.verificationGasLimit)\n        : undefined,\n      preVerificationGas: res.result.preVerificationGas\n        ? hexToBigInt(res.result.preVerificationGas)\n        : undefined,\n      callGasLimit: res.result.callGasLimit\n        ? hexToBigInt(res.result.callGasLimit)\n        : undefined,\n      paymaster: res.result.paymaster,\n      paymasterData: res.result.paymasterData,\n      paymasterVerificationGasLimit: res.result.paymasterVerificationGasLimit\n        ? hexToBigInt(res.result.paymasterVerificationGasLimit)\n        : undefined,\n      paymasterPostOpGasLimit: res.result.paymasterPostOpGasLimit\n        ? hexToBigInt(res.result.paymasterPostOpGasLimit)\n        : undefined,\n    };\n  }\n  const error =\n    res.error?.message || res.error || response.statusText || \"unknown error\";\n  throw new Error(`Paymaster error from ${paymasterUrl}: ${error}`);\n}\n", "import { concat } from \"viem\";\nimport type { Chain } from \"../../../chains/types.js\";\nimport type { ThirdwebClient } from \"../../../client/client.js\";\nimport {\n  type ThirdwebContract,\n  getContract,\n} from \"../../../contract/contract.js\";\nimport { getNonce } from \"../../../extensions/erc4337/__generated__/IEntryPoint/read/getNonce.js\";\nimport { getUserOpHash as getUserOpHashV06 } from \"../../../extensions/erc4337/__generated__/IEntryPoint/read/getUserOpHash.js\";\nimport { getUserOpHash as getUserOpHashV07 } from \"../../../extensions/erc4337/__generated__/IEntryPoint_v07/read/getUserOpHash.js\";\nimport { getDefaultGasOverrides } from \"../../../gas/fee-data.js\";\nimport { encode } from \"../../../transaction/actions/encode.js\";\nimport { toSerializableTransaction } from \"../../../transaction/actions/to-serializable-transaction.js\";\nimport type { PreparedTransaction } from \"../../../transaction/prepare-transaction.js\";\nimport type { TransactionReceipt } from \"../../../transaction/types.js\";\nimport { isContractDeployed } from \"../../../utils/bytecode/is-contract-deployed.js\";\nimport type { Hex } from \"../../../utils/encoding/hex.js\";\nimport { hexToBytes } from \"../../../utils/encoding/to-bytes.js\";\nimport { isThirdwebUrl } from \"../../../utils/fetch.js\";\nimport { resolvePromisedValue } from \"../../../utils/promise/resolve-promised-value.js\";\nimport type { Account } from \"../../interfaces/wallet.js\";\nimport type {\n  BundlerOptions,\n  PaymasterResult,\n  SmartWalletOptions,\n  UserOperationV06,\n  UserOperationV07,\n} from \"../types.js\";\nimport {\n  estimateUserOpGas,\n  getUserOpGasFees,\n  getUserOpReceipt,\n} from \"./bundler.js\";\nimport {\n  predictAddress,\n  prepareBatchExecute,\n  prepareCreateAccount,\n  prepareExecute,\n} from \"./calls.js\";\nimport {\n  DUMMY_SIGNATURE,\n  ENTRYPOINT_ADDRESS_v0_6,\n  ENTRYPOINT_ADDRESS_v0_7,\n  getDefaultAccountFactory,\n  getDefaultBundlerUrl,\n  getEntryPointVersion,\n} from \"./constants.js\";\nimport { getPackedUserOperation } from \"./packUserOp.js\";\nimport { getPaymasterAndData } from \"./paymaster.js\";\nimport { generateRandomUint192 } from \"./utils.js\";\n\nconst isDeployingSet: Set<string> = new Set();\n\nconst getKey = (accountContract: ThirdwebContract) => {\n  return `${accountContract.chain.id}:${accountContract.address}`;\n};\n\nconst markAccountDeploying = (accountContract: ThirdwebContract) => {\n  isDeployingSet.add(getKey(accountContract));\n};\n\nexport const clearAccountDeploying = (accountContract: ThirdwebContract) => {\n  isDeployingSet.delete(getKey(accountContract));\n};\n\nconst isAccountDeploying = (accountContract: ThirdwebContract) => {\n  return isDeployingSet.has(getKey(accountContract));\n};\n\n/**\n * Wait for the user operation to be mined.\n * @param args - The options and user operation hash\n * @returns - The transaction receipt\n *\n * @example\n * ```ts\n * import { waitForUserOpReceipt } from \"thirdweb/wallets/smart\";\n *\n * const receipt = await waitForUserOpReceipt({\n *  chain,\n *  client,\n *  userOpHash,\n * });\n * ```\n * @walletUtils\n */\nexport async function waitForUserOpReceipt(\n  args: BundlerOptions & {\n    userOpHash: Hex;\n    timeoutMs?: number;\n    intervalMs?: number;\n  },\n): Promise<TransactionReceipt> {\n  const timeout = args.timeoutMs || 120000; // 2mins\n  const interval = args.intervalMs || 1000; // 1s\n  const endtime = Date.now() + timeout;\n  while (Date.now() < endtime) {\n    const userOpReceipt = await getUserOpReceipt(args);\n    if (userOpReceipt) {\n      return userOpReceipt;\n    }\n    await new Promise((resolve) => setTimeout(resolve, interval));\n  }\n  throw new Error(\"Timeout waiting for userOp to be mined\");\n}\n\n/**\n * Creates an unsigned user operation from a prepared transaction.\n * @param args - The prepared transaction and options\n * @returns - The unsigned user operation\n * @example\n * ```ts\n * import { createUnsignedUserOp } from \"thirdweb/wallets/smart\";\n *\n * const transaction = prepareContractCall(...);\n *\n * const userOp = await createUnsignedUserOp({\n *  transaction,\n *  factoryContract,\n *  accountContract,\n *  adminAddress,\n *  sponsorGas,\n *  overrides,\n * });\n * ```\n * @walletUtils\n */\nexport async function createUnsignedUserOp(args: {\n  transaction: PreparedTransaction;\n  factoryContract: ThirdwebContract;\n  accountContract: ThirdwebContract;\n  adminAddress: string;\n  sponsorGas: boolean;\n  waitForDeployment?: boolean;\n  overrides?: SmartWalletOptions[\"overrides\"];\n}): Promise<UserOperationV06 | UserOperationV07> {\n  const {\n    transaction: executeTx,\n    accountContract,\n    factoryContract,\n    adminAddress,\n    overrides,\n    sponsorGas,\n    waitForDeployment = true,\n  } = args;\n  const chain = executeTx.chain;\n  const client = executeTx.client;\n\n  const bundlerOptions = {\n    client,\n    chain,\n    bundlerUrl: overrides?.bundlerUrl,\n    entrypointAddress: overrides?.entrypointAddress,\n  };\n\n  const entrypointVersion = getEntryPointVersion(\n    args.overrides?.entrypointAddress || ENTRYPOINT_ADDRESS_v0_6,\n  );\n\n  const [isDeployed, callData, callGasLimit, gasFees, nonce] =\n    await Promise.all([\n      isContractDeployed(accountContract),\n      encode(executeTx),\n      resolvePromisedValue(executeTx.gas),\n      getGasFees({\n        executeTx,\n        bundlerOptions,\n        chain,\n        client,\n      }),\n      getAccountNonce({\n        accountContract,\n        chain,\n        client,\n        entrypointAddress: overrides?.entrypointAddress,\n        getNonceOverride: overrides?.getAccountNonce,\n      }),\n    ]);\n\n  const { maxFeePerGas, maxPriorityFeePerGas } = gasFees;\n\n  if (entrypointVersion === \"v0.7\") {\n    return populateUserOp_v0_7({\n      bundlerOptions,\n      factoryContract,\n      accountContract,\n      adminAddress,\n      sponsorGas,\n      overrides,\n      isDeployed,\n      nonce,\n      callData,\n      callGasLimit,\n      maxFeePerGas,\n      maxPriorityFeePerGas,\n      waitForDeployment,\n    });\n  }\n\n  // default to v0.6\n  return populateUserOp_v0_6({\n    bundlerOptions,\n    factoryContract,\n    accountContract,\n    adminAddress,\n    sponsorGas,\n    overrides,\n    isDeployed,\n    nonce,\n    callData,\n    callGasLimit,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    waitForDeployment,\n  });\n}\n\nasync function getGasFees(args: {\n  executeTx: PreparedTransaction;\n  bundlerOptions: BundlerOptions;\n  chain: Chain;\n  client: ThirdwebClient;\n}): Promise<{\n  maxFeePerGas: bigint;\n  maxPriorityFeePerGas: bigint;\n}> {\n  const { executeTx, bundlerOptions, chain, client } = args;\n  let { maxFeePerGas, maxPriorityFeePerGas } = executeTx;\n\n  const bundlerUrl = bundlerOptions?.bundlerUrl ?? getDefaultBundlerUrl(chain);\n\n  if (isThirdwebUrl(bundlerUrl)) {\n    // get gas prices from bundler\n    const bundlerGasPrice = await getUserOpGasFees({\n      options: bundlerOptions,\n    });\n    maxFeePerGas = bundlerGasPrice.maxFeePerGas;\n    maxPriorityFeePerGas = bundlerGasPrice.maxPriorityFeePerGas;\n  } else {\n    // Check for explicity values\n    const [resolvedMaxFeePerGas, resolvedMaxPriorityFeePerGas] =\n      await Promise.all([\n        resolvePromisedValue(maxFeePerGas),\n        resolvePromisedValue(maxPriorityFeePerGas),\n      ]);\n\n    if (resolvedMaxFeePerGas && resolvedMaxPriorityFeePerGas) {\n      // Save a network call if the values are provided\n      maxFeePerGas = resolvedMaxFeePerGas;\n      maxPriorityFeePerGas = resolvedMaxPriorityFeePerGas;\n    } else {\n      // Fallback to RPC gas prices if no explicit values provided\n      const feeData = await getDefaultGasOverrides(client, chain);\n\n      // Still check for explicit values in case one is provided and not the other\n      maxPriorityFeePerGas =\n        resolvedMaxPriorityFeePerGas ?? feeData.maxPriorityFeePerGas ?? 0n;\n      maxFeePerGas = resolvedMaxFeePerGas ?? feeData.maxFeePerGas ?? 0n;\n    }\n  }\n  return { maxFeePerGas, maxPriorityFeePerGas };\n}\n\nasync function populateUserOp_v0_7(args: {\n  bundlerOptions: BundlerOptions;\n  factoryContract: ThirdwebContract;\n  accountContract: ThirdwebContract;\n  adminAddress: string;\n  sponsorGas: boolean;\n  overrides?: SmartWalletOptions[\"overrides\"];\n  isDeployed: boolean;\n  nonce: bigint;\n  callData: Hex;\n  callGasLimit?: bigint;\n  maxFeePerGas: bigint;\n  maxPriorityFeePerGas: bigint;\n  waitForDeployment: boolean;\n}): Promise<UserOperationV07> {\n  const {\n    bundlerOptions,\n    isDeployed,\n    factoryContract,\n    accountContract,\n    adminAddress,\n    sponsorGas,\n    overrides,\n    nonce,\n    callData,\n    callGasLimit,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    waitForDeployment,\n  } = args;\n  const { chain, client } = bundlerOptions;\n\n  let factory: string | undefined;\n  let factoryData: Hex;\n  if (isDeployed || isAccountDeploying(accountContract)) {\n    factoryData = \"0x\";\n    if (waitForDeployment) {\n      // lock until account is deployed if needed to avoid 'sender already created' errors when sending multiple transactions in parallel\n      await waitForAccountDeployed(accountContract);\n    }\n  } else {\n    factory = factoryContract.address;\n    factoryData = await encode(\n      prepareCreateAccount({\n        factoryContract: factoryContract,\n        adminAddress,\n        accountSalt: overrides?.accountSalt,\n        createAccountOverride: overrides?.createAccount,\n      }),\n    );\n    markAccountDeploying(accountContract);\n  }\n\n  const partialOp: UserOperationV07 = {\n    sender: accountContract.address,\n    nonce,\n    callData,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    callGasLimit: callGasLimit ?? 0n,\n    verificationGasLimit: 0n,\n    preVerificationGas: 0n,\n    factory,\n    factoryData,\n    paymaster: undefined,\n    paymasterData: \"0x\",\n    paymasterVerificationGasLimit: 0n,\n    paymasterPostOpGasLimit: 0n,\n    signature: DUMMY_SIGNATURE,\n  };\n\n  if (sponsorGas) {\n    const paymasterResult = (await getPaymasterAndData({\n      userOp: partialOp,\n      chain,\n      client,\n      entrypointAddress: overrides?.entrypointAddress,\n      paymasterOverride: overrides?.paymaster,\n    })) as Extract<PaymasterResult, { paymaster: string }>;\n    if (paymasterResult.paymaster && paymasterResult.paymasterData) {\n      partialOp.paymaster = paymasterResult.paymaster;\n      partialOp.paymasterData = paymasterResult.paymasterData as Hex;\n    }\n    // paymaster can have the gas limits in the response\n    if (\n      paymasterResult.callGasLimit &&\n      paymasterResult.verificationGasLimit &&\n      paymasterResult.preVerificationGas &&\n      paymasterResult.paymasterPostOpGasLimit &&\n      paymasterResult.paymasterVerificationGasLimit\n    ) {\n      partialOp.callGasLimit = paymasterResult.callGasLimit;\n      partialOp.verificationGasLimit = paymasterResult.verificationGasLimit;\n      partialOp.preVerificationGas = paymasterResult.preVerificationGas;\n      partialOp.paymasterPostOpGasLimit =\n        paymasterResult.paymasterPostOpGasLimit;\n      partialOp.paymasterVerificationGasLimit =\n        paymasterResult.paymasterVerificationGasLimit;\n    } else {\n      // otherwise fallback to bundler for gas limits\n      const estimates = await estimateUserOpGas({\n        userOp: partialOp,\n        options: bundlerOptions,\n      });\n      partialOp.callGasLimit = estimates.callGasLimit;\n      partialOp.verificationGasLimit = estimates.verificationGasLimit;\n      partialOp.preVerificationGas = estimates.preVerificationGas;\n      partialOp.paymasterPostOpGasLimit =\n        paymasterResult.paymasterPostOpGasLimit || 0n;\n      partialOp.paymasterVerificationGasLimit =\n        paymasterResult.paymasterVerificationGasLimit || 0n;\n      // need paymaster to re-sign after estimates\n      const paymasterResult2 = (await getPaymasterAndData({\n        userOp: partialOp,\n        chain,\n        client,\n        entrypointAddress: overrides?.entrypointAddress,\n        paymasterOverride: overrides?.paymaster,\n      })) as Extract<PaymasterResult, { paymaster: string }>;\n      if (paymasterResult2.paymaster && paymasterResult2.paymasterData) {\n        partialOp.paymaster = paymasterResult2.paymaster;\n        partialOp.paymasterData = paymasterResult2.paymasterData as Hex;\n      }\n    }\n  } else {\n    // not gasless, so we just need to estimate gas limits\n    const estimates = await estimateUserOpGas({\n      userOp: partialOp,\n      options: bundlerOptions,\n    });\n    partialOp.callGasLimit = estimates.callGasLimit;\n    partialOp.verificationGasLimit = estimates.verificationGasLimit;\n    partialOp.preVerificationGas = estimates.preVerificationGas;\n    partialOp.paymasterPostOpGasLimit = estimates.paymasterPostOpGasLimit || 0n;\n    partialOp.paymasterVerificationGasLimit =\n      estimates.paymasterVerificationGasLimit || 0n;\n  }\n  return {\n    ...partialOp,\n    signature: \"0x\" as Hex,\n  };\n}\n\nasync function populateUserOp_v0_6(args: {\n  bundlerOptions: BundlerOptions;\n  factoryContract: ThirdwebContract;\n  accountContract: ThirdwebContract;\n  adminAddress: string;\n  sponsorGas: boolean;\n  overrides?: SmartWalletOptions[\"overrides\"];\n  isDeployed: boolean;\n  nonce: bigint;\n  callData: Hex;\n  callGasLimit?: bigint;\n  maxFeePerGas: bigint;\n  maxPriorityFeePerGas: bigint;\n  waitForDeployment: boolean;\n}): Promise<UserOperationV06> {\n  const {\n    bundlerOptions,\n    isDeployed,\n    factoryContract,\n    accountContract,\n    adminAddress,\n    sponsorGas,\n    overrides,\n    nonce,\n    callData,\n    callGasLimit,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    waitForDeployment,\n  } = args;\n  const { chain, client } = bundlerOptions;\n  let initCode: Hex;\n\n  if (isDeployed || isAccountDeploying(accountContract)) {\n    initCode = \"0x\";\n    if (waitForDeployment) {\n      // lock until account is deployed if needed to avoid 'sender already created' errors when sending multiple transactions in parallel\n      await waitForAccountDeployed(accountContract);\n    }\n  } else {\n    initCode = await getAccountInitCode({\n      factoryContract: factoryContract,\n      adminAddress,\n      accountSalt: overrides?.accountSalt,\n      createAccountOverride: overrides?.createAccount,\n    });\n    markAccountDeploying(accountContract);\n  }\n\n  const partialOp: UserOperationV06 = {\n    sender: accountContract.address,\n    nonce,\n    initCode,\n    callData,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    callGasLimit: callGasLimit ?? 0n,\n    verificationGasLimit: 0n,\n    preVerificationGas: 0n,\n    paymasterAndData: \"0x\",\n    signature: DUMMY_SIGNATURE,\n  };\n\n  if (sponsorGas) {\n    const paymasterResult = await getPaymasterAndData({\n      userOp: partialOp,\n      chain,\n      client,\n      entrypointAddress: overrides?.entrypointAddress,\n      paymasterOverride: overrides?.paymaster,\n    });\n    const paymasterAndData =\n      \"paymasterAndData\" in paymasterResult\n        ? paymasterResult.paymasterAndData\n        : \"0x\";\n    if (paymasterAndData && paymasterAndData !== \"0x\") {\n      partialOp.paymasterAndData = paymasterAndData as Hex;\n    }\n    // paymaster can have the gas limits in the response\n    if (\n      paymasterResult.callGasLimit &&\n      paymasterResult.verificationGasLimit &&\n      paymasterResult.preVerificationGas\n    ) {\n      partialOp.callGasLimit = paymasterResult.callGasLimit;\n      partialOp.verificationGasLimit = paymasterResult.verificationGasLimit;\n      partialOp.preVerificationGas = paymasterResult.preVerificationGas;\n    } else {\n      // otherwise fallback to bundler for gas limits\n      const estimates = await estimateUserOpGas({\n        userOp: partialOp,\n        options: bundlerOptions,\n      });\n      partialOp.callGasLimit = estimates.callGasLimit;\n      partialOp.verificationGasLimit = estimates.verificationGasLimit;\n      partialOp.preVerificationGas = estimates.preVerificationGas;\n      // need paymaster to re-sign after estimates\n      if (paymasterAndData && paymasterAndData !== \"0x\") {\n        const paymasterResult2 = await getPaymasterAndData({\n          userOp: partialOp,\n          chain,\n          client,\n          entrypointAddress: overrides?.entrypointAddress,\n          paymasterOverride: overrides?.paymaster,\n        });\n        const paymasterAndData2 =\n          \"paymasterAndData\" in paymasterResult2\n            ? paymasterResult2.paymasterAndData\n            : \"0x\";\n        if (paymasterAndData2 && paymasterAndData2 !== \"0x\") {\n          partialOp.paymasterAndData = paymasterAndData2 as Hex;\n        }\n      }\n    }\n  } else {\n    // not gasless, so we just need to estimate gas limits\n    const estimates = await estimateUserOpGas({\n      userOp: partialOp,\n      options: bundlerOptions,\n    });\n    partialOp.callGasLimit = estimates.callGasLimit;\n    partialOp.verificationGasLimit = estimates.verificationGasLimit;\n    partialOp.preVerificationGas = estimates.preVerificationGas;\n  }\n  return {\n    ...partialOp,\n    signature: \"0x\" as Hex,\n  };\n}\n\n/**\n * Sign a user operation.\n * @param userOp - The UserOperation to sign (with signature field ignored)\n * @returns - The user operation with the signature field populated\n * @example\n * ```ts\n * import { signUserOp } from \"thirdweb/wallets/smart\";\n *\n * const userOp = await createUnsignedUserOp(...);\n *\n * const signedUserOp = await signUserOp({\n *  client,\n *  userOp,\n *  chain,\n *  adminAccount,\n * });\n * ```\n * @walletUtils\n */\nexport async function signUserOp(args: {\n  client: ThirdwebClient;\n  userOp: UserOperationV06 | UserOperationV07;\n  chain: Chain;\n  entrypointAddress?: string;\n  adminAccount: Account;\n}): Promise<UserOperationV06 | UserOperationV07> {\n  const { userOp, chain, entrypointAddress, adminAccount } = args;\n\n  const entrypointVersion = getEntryPointVersion(\n    entrypointAddress || ENTRYPOINT_ADDRESS_v0_6,\n  );\n\n  let userOpHash: Hex;\n\n  if (entrypointVersion === \"v0.7\") {\n    const packedUserOp = getPackedUserOperation(userOp as UserOperationV07);\n    userOpHash = await getUserOpHashV07({\n      contract: getContract({\n        address: entrypointAddress || ENTRYPOINT_ADDRESS_v0_7,\n        chain,\n        client: args.client,\n      }),\n      userOp: packedUserOp,\n    });\n  } else {\n    userOpHash = await getUserOpHashV06({\n      contract: getContract({\n        address: entrypointAddress || ENTRYPOINT_ADDRESS_v0_6,\n        chain,\n        client: args.client,\n      }),\n      userOp: userOp as UserOperationV06,\n    });\n  }\n\n  if (adminAccount.signMessage) {\n    const signature = await adminAccount.signMessage({\n      message: {\n        raw: hexToBytes(userOpHash),\n      },\n    });\n    return {\n      ...userOp,\n      signature,\n    };\n  }\n  throw new Error(\"signMessage not implemented in signingAccount\");\n}\n\nasync function getAccountInitCode(options: {\n  factoryContract: ThirdwebContract;\n  adminAddress: string;\n  accountSalt?: string;\n  createAccountOverride?: (\n    factoryContract: ThirdwebContract,\n  ) => PreparedTransaction;\n}): Promise<Hex> {\n  const { factoryContract, adminAddress, accountSalt, createAccountOverride } =\n    options;\n  const deployTx = prepareCreateAccount({\n    factoryContract,\n    adminAddress,\n    accountSalt,\n    createAccountOverride,\n  });\n  return concat([factoryContract.address as Hex, await encode(deployTx)]);\n}\n\nasync function getAccountNonce(options: {\n  accountContract: ThirdwebContract;\n  chain: Chain;\n  client: ThirdwebClient;\n  entrypointAddress?: string;\n  getNonceOverride?: (accountContract: ThirdwebContract) => Promise<bigint>;\n}) {\n  const {\n    accountContract,\n    chain,\n    client,\n    entrypointAddress,\n    getNonceOverride,\n  } = options;\n  if (getNonceOverride) {\n    return getNonceOverride(accountContract);\n  }\n  return getNonce({\n    contract: getContract({\n      address: entrypointAddress || ENTRYPOINT_ADDRESS_v0_6,\n      chain,\n      client,\n    }),\n    key: generateRandomUint192(),\n    sender: accountContract.address,\n  });\n}\n\n/**\n * Create and sign a user operation.\n * @param options - The options for creating and signing the user operation\n * @returns - The signed user operation\n * @example\n * ```ts\n * import { createAndSignUserOp } from \"thirdweb/wallets/smart\";\n *\n * const userOp = await createAndSignUserOp({\n *  client,\n *  adminAccount,\n *  smartWalletOptions,\n *  transactions,\n * });\n * ```\n * @walletUtils\n */\nexport async function createAndSignUserOp(options: {\n  transactions: PreparedTransaction[];\n  adminAccount: Account;\n  client: ThirdwebClient;\n  smartWalletOptions: SmartWalletOptions;\n  waitForDeployment?: boolean;\n}) {\n  const config = options.smartWalletOptions;\n  const factoryContract = getContract({\n    address:\n      config.factoryAddress ||\n      getDefaultAccountFactory(config.overrides?.entrypointAddress),\n    chain: config.chain,\n    client: options.client,\n  });\n  const accountAddress = await predictAddress({\n    factoryContract,\n    adminAddress: options.adminAccount.address,\n    predictAddressOverride: config.overrides?.predictAddress,\n    accountSalt: config.overrides?.accountSalt,\n    accountAddress: config.overrides?.accountAddress,\n  });\n  const accountContract = getContract({\n    address: accountAddress,\n    chain: config.chain,\n    client: options.client,\n  });\n\n  let executeTx: PreparedTransaction;\n  if (options.transactions.length === 1) {\n    const tx = options.transactions[0] as PreparedTransaction;\n    const serializedTx = await toSerializableTransaction({\n      transaction: tx,\n      from: accountAddress,\n    });\n    executeTx = prepareExecute({\n      accountContract,\n      transaction: serializedTx,\n      executeOverride: config.overrides?.execute,\n    });\n  } else {\n    const serializedTxs = await Promise.all(\n      options.transactions.map((tx) =>\n        toSerializableTransaction({\n          transaction: tx,\n          from: accountAddress,\n        }),\n      ),\n    );\n    executeTx = prepareBatchExecute({\n      accountContract,\n      transactions: serializedTxs,\n      executeBatchOverride: config.overrides?.executeBatch,\n    });\n  }\n\n  const unsignedUserOp = await createUnsignedUserOp({\n    transaction: executeTx,\n    factoryContract,\n    accountContract,\n    adminAddress: options.adminAccount.address,\n    sponsorGas: \"sponsorGas\" in config ? config.sponsorGas : config.gasless,\n    overrides: config.overrides,\n    waitForDeployment: options.waitForDeployment,\n  });\n  const signedUserOp = await signUserOp({\n    client: options.client,\n    chain: config.chain,\n    adminAccount: options.adminAccount,\n    entrypointAddress: config.overrides?.entrypointAddress,\n    userOp: unsignedUserOp,\n  });\n  return signedUserOp;\n}\n\nasync function waitForAccountDeployed(accountContract: ThirdwebContract) {\n  const startTime = Date.now();\n  while (isAccountDeploying(accountContract)) {\n    if (Date.now() - startTime > 60000) {\n      clearAccountDeploying(accountContract); // clear the flag so it doesnt stay stuck in this state\n      throw new Error(\n        \"Account deployment is taking too long (over 1 minute). Please try again.\",\n      );\n    }\n    await new Promise((resolve) => setTimeout(resolve, 500));\n  }\n}\n", "import {\n  type SignableMessage,\n  type TypedData,\n  type TypedDataDefinition,\n  type TypedDataDomain,\n  hashTypedData,\n  maxUint96,\n} from \"viem\";\nimport type { Chain } from \"../../chains/types.js\";\nimport { getCachedChain } from \"../../chains/utils.js\";\nimport type { ThirdwebClient } from \"../../client/client.js\";\nimport { type ThirdwebContract, getContract } from \"../../contract/contract.js\";\nimport { allowance } from \"../../extensions/erc20/__generated__/IERC20/read/allowance.js\";\nimport { approve } from \"../../extensions/erc20/write/approve.js\";\nimport { toSerializableTransaction } from \"../../transaction/actions/to-serializable-transaction.js\";\nimport type { WaitForReceiptOptions } from \"../../transaction/actions/wait-for-tx-receipt.js\";\nimport {\n  populateEip712Transaction,\n  signEip712Transaction,\n} from \"../../transaction/actions/zksync/send-eip712-transaction.js\";\nimport type { PreparedTransaction } from \"../../transaction/prepare-transaction.js\";\nimport { readContract } from \"../../transaction/read-contract.js\";\nimport { getAddress } from \"../../utils/address.js\";\nimport { isZkSyncChain } from \"../../utils/any-evm/zksync/isZkSyncChain.js\";\nimport { concatHex } from \"../../utils/encoding/helpers/concat-hex.js\";\nimport type { Hex } from \"../../utils/encoding/hex.js\";\nimport { parseTypedData } from \"../../utils/signatures/helpers/parseTypedData.js\";\nimport type {\n  Account,\n  SendTransactionOption,\n  Wallet,\n} from \"../interfaces/wallet.js\";\nimport type {\n  CreateWalletArgs,\n  WalletConnectionOption,\n  WalletId,\n} from \"../wallet-types.js\";\nimport {\n  broadcastZkTransaction,\n  bundleUserOp,\n  getZkPaymasterData,\n} from \"./lib/bundler.js\";\nimport {\n  predictAddress,\n  prepareBatchExecute,\n  prepareExecute,\n} from \"./lib/calls.js\";\nimport { getDefaultAccountFactory } from \"./lib/constants.js\";\nimport {\n  clearAccountDeploying,\n  createUnsignedUserOp,\n  signUserOp,\n  waitForUserOpReceipt,\n} from \"./lib/userop.js\";\nimport type {\n  BundlerOptions,\n  PaymasterResult,\n  SmartAccountOptions,\n  SmartWalletConnectionOptions,\n  SmartWalletOptions,\n  UserOperationV06,\n  UserOperationV07,\n} from \"./types.js\";\n/**\n * Checks if the provided wallet is a smart wallet.\n *\n * @param wallet - The wallet to check.\n * @returns True if the wallet is a smart wallet, false otherwise.\n */\nexport function isSmartWallet(\n  wallet: Wallet<WalletId>,\n): wallet is Wallet<\"smart\"> {\n  return wallet.id === \"smart\";\n}\n\n/**\n * We can get the personal account for given smart account but not the other way around - this map gives us the reverse lookup\n * @internal\n */\nconst personalAccountToSmartAccountMap = new WeakMap<\n  Account,\n  Wallet<\"smart\">\n>();\n\nconst smartWalletToPersonalAccountMap = new WeakMap<Wallet<\"smart\">, Account>();\n\n/**\n * @internal\n */\nexport async function connectSmartWallet(\n  wallet: Wallet<\"smart\">,\n  connectionOptions: WalletConnectionOption<\"smart\">,\n  creationOptions: CreateWalletArgs<\"smart\">[1],\n): Promise<[Account, Chain]> {\n  const { personalAccount, client, chain: connectChain } = connectionOptions;\n\n  if (!personalAccount) {\n    throw new Error(\"Personal wallet does not have an account\");\n  }\n\n  const options = creationOptions;\n  const chain = connectChain ?? options.chain;\n\n  // if factory is passed, but no entrypoint, try to resolve entrypoint from factory\n  if (options.factoryAddress && !options.overrides?.entrypointAddress) {\n    const entrypointAddress = await getEntrypointFromFactory(\n      options.factoryAddress,\n      client,\n      chain,\n    );\n    if (entrypointAddress) {\n      options.overrides = {\n        ...options.overrides,\n        entrypointAddress,\n      };\n    }\n  }\n\n  const factoryAddress =\n    options.factoryAddress ??\n    getDefaultAccountFactory(options.overrides?.entrypointAddress);\n  const sponsorGas =\n    \"gasless\" in options ? options.gasless : options.sponsorGas;\n\n  if (await isZkSyncChain(chain)) {\n    return [\n      createZkSyncAccount({\n        creationOptions,\n        connectionOptions,\n        chain,\n        sponsorGas,\n      }),\n      chain,\n    ];\n  }\n\n  const factoryContract = getContract({\n    client: client,\n    address: factoryAddress,\n    chain: chain,\n  });\n\n  // TODO: listen for chainChanged event on the personal wallet and emit the disconnect event on the smart wallet\n  const accountAddress = await predictAddress({\n    factoryContract,\n    adminAddress: personalAccount.address,\n    predictAddressOverride: options.overrides?.predictAddress,\n    accountSalt: options.overrides?.accountSalt,\n    accountAddress: options.overrides?.accountAddress,\n  })\n    .then((address) => address)\n    .catch((err) => {\n      throw new Error(\n        `Failed to get account address with factory contract ${factoryContract.address} on chain ID ${chain.id}: ${err?.message || \"unknown error\"}`,\n        { cause: err },\n      );\n    });\n\n  const accountContract = getContract({\n    client,\n    address: accountAddress,\n    chain,\n  });\n\n  const account = await createSmartAccount({\n    ...options,\n    chain,\n    sponsorGas,\n    personalAccount,\n    accountContract,\n    factoryContract,\n    client,\n  });\n\n  personalAccountToSmartAccountMap.set(personalAccount, wallet);\n  smartWalletToPersonalAccountMap.set(wallet, personalAccount);\n\n  return [account, chain] as const;\n}\n\n/**\n * @internal\n */\nexport async function disconnectSmartWallet(\n  wallet: Wallet<\"smart\">,\n): Promise<void> {\n  // look up the personalAccount for the smart wallet\n  const personalAccount = smartWalletToPersonalAccountMap.get(wallet);\n  if (personalAccount) {\n    // remove the mappings\n    personalAccountToSmartAccountMap.delete(personalAccount);\n    smartWalletToPersonalAccountMap.delete(wallet);\n  }\n}\n\nasync function createSmartAccount(\n  options: SmartAccountOptions,\n): Promise<Account> {\n  const { accountContract } = options;\n  const account: Account = {\n    address: getAddress(accountContract.address),\n    async sendTransaction(transaction: SendTransactionOption) {\n      // if erc20 paymaster - check allowance and approve if needed\n      const erc20Paymaster = options.overrides?.erc20Paymaster;\n      let paymasterOverride:\n        | undefined\n        | ((\n            userOp: UserOperationV06 | UserOperationV07,\n          ) => Promise<PaymasterResult>) = undefined;\n      if (erc20Paymaster) {\n        await approveERC20({\n          accountContract,\n          erc20Paymaster,\n          options,\n        });\n        const paymasterCallback = async (): Promise<PaymasterResult> => {\n          return {\n            paymasterAndData: concatHex([\n              erc20Paymaster.address as Hex,\n              erc20Paymaster?.token as Hex,\n            ]),\n            // for 0.7 compatibility\n            paymaster: erc20Paymaster.address as Hex,\n            paymasterData: \"0x\",\n          };\n        };\n        paymasterOverride = options.overrides?.paymaster || paymasterCallback;\n      } else {\n        paymasterOverride = options.overrides?.paymaster;\n      }\n      const executeTx = prepareExecute({\n        accountContract,\n        transaction,\n        executeOverride: options.overrides?.execute,\n      });\n      return _sendUserOp({\n        executeTx,\n        options: {\n          ...options,\n          overrides: {\n            ...options.overrides,\n            paymaster: paymasterOverride,\n          },\n        },\n      });\n    },\n    async sendBatchTransaction(transactions: SendTransactionOption[]) {\n      const executeTx = prepareBatchExecute({\n        accountContract,\n        transactions,\n        executeBatchOverride: options.overrides?.executeBatch,\n      });\n      return _sendUserOp({\n        executeTx,\n        options,\n      });\n    },\n    async signMessage({ message }: { message: SignableMessage }) {\n      const [\n        { isContractDeployed },\n        { readContract },\n        { encodeAbiParameters },\n        { hashMessage },\n        { checkContractWalletSignature },\n      ] = await Promise.all([\n        import(\"../../utils/bytecode/is-contract-deployed.js\"),\n        import(\"../../transaction/read-contract.js\"),\n        import(\"../../utils/abi/encodeAbiParameters.js\"),\n        import(\"../../utils/hashing/hashMessage.js\"),\n        import(\"../../extensions/erc1271/checkContractWalletSignature.js\"),\n      ]);\n      const isDeployed = await isContractDeployed(accountContract);\n      if (!isDeployed) {\n        await _deployAccount({\n          options,\n          account,\n          accountContract,\n        });\n        // the bundler and rpc might not be in sync, so while the bundler has a transaction hash for the deployment,\n        // the rpc might not have it yet, so we wait until the rpc confirms the contract is deployed\n        await confirmContractDeployment({\n          accountContract,\n        });\n      }\n\n      const originalMsgHash = hashMessage(message);\n      // check if the account contract supports EIP721 domain separator based signing\n      let factorySupports712 = false;\n      try {\n        // this will throw if the contract does not support it (old factories)\n        await readContract({\n          contract: accountContract,\n          method:\n            \"function getMessageHash(bytes32 _hash) public view returns (bytes32)\",\n          params: [originalMsgHash],\n        });\n        factorySupports712 = true;\n      } catch {\n        // ignore\n      }\n\n      let sig: `0x${string}`;\n      if (factorySupports712) {\n        const wrappedMessageHash = encodeAbiParameters(\n          [{ type: \"bytes32\" }],\n          [originalMsgHash],\n        );\n        sig = await options.personalAccount.signTypedData({\n          domain: {\n            name: \"Account\",\n            version: \"1\",\n            chainId: options.chain.id,\n            verifyingContract: accountContract.address,\n          },\n          primaryType: \"AccountMessage\",\n          types: { AccountMessage: [{ name: \"message\", type: \"bytes\" }] },\n          message: { message: wrappedMessageHash },\n        });\n      } else {\n        sig = await options.personalAccount.signMessage({ message });\n      }\n\n      const isValid = await checkContractWalletSignature({\n        contract: accountContract,\n        message,\n        signature: sig,\n      });\n\n      if (isValid) {\n        return sig;\n      }\n      throw new Error(\n        \"Unable to verify signature on smart account, please make sure the smart account is deployed and the signature is valid.\",\n      );\n    },\n    async signTypedData<\n      const typedData extends TypedData | Record<string, unknown>,\n      primaryType extends keyof typedData | \"EIP712Domain\" = keyof typedData,\n    >(_typedData: TypedDataDefinition<typedData, primaryType>) {\n      const typedData = parseTypedData(_typedData);\n      const [\n        { isContractDeployed },\n        { readContract },\n        { encodeAbiParameters },\n        { checkContractWalletSignedTypedData },\n      ] = await Promise.all([\n        import(\"../../utils/bytecode/is-contract-deployed.js\"),\n        import(\"../../transaction/read-contract.js\"),\n        import(\"../../utils/abi/encodeAbiParameters.js\"),\n        import(\n          \"../../extensions/erc1271/checkContractWalletSignedTypedData.js\"\n        ),\n      ]);\n      const isSelfVerifyingContract =\n        (\n          typedData.domain as TypedDataDomain\n        )?.verifyingContract?.toLowerCase() ===\n        accountContract.address?.toLowerCase();\n\n      if (isSelfVerifyingContract) {\n        // if the contract is self-verifying, we can just sign the message with the EOA (ie. adding a session key)\n        return options.personalAccount.signTypedData(typedData);\n      }\n\n      const isDeployed = await isContractDeployed(accountContract);\n      if (!isDeployed) {\n        await _deployAccount({\n          options,\n          account,\n          accountContract,\n        });\n        // the bundler and rpc might not be in sync, so while the bundler has a transaction hash for the deployment,\n        // the rpc might not have it yet, so we wait until the rpc confirms the contract is deployed\n        await confirmContractDeployment({\n          accountContract,\n        });\n      }\n\n      const originalMsgHash = hashTypedData(typedData);\n      // check if the account contract supports EIP721 domain separator based signing\n      let factorySupports712 = false;\n      try {\n        // this will throw if the contract does not support it (old factories)\n        await readContract({\n          contract: accountContract,\n          method:\n            \"function getMessageHash(bytes32 _hash) public view returns (bytes32)\",\n          params: [originalMsgHash],\n        });\n        factorySupports712 = true;\n      } catch {\n        // ignore\n      }\n\n      let sig: `0x${string}`;\n      if (factorySupports712) {\n        const wrappedMessageHash = encodeAbiParameters(\n          [{ type: \"bytes32\" }],\n          [originalMsgHash],\n        );\n        sig = await options.personalAccount.signTypedData({\n          domain: {\n            name: \"Account\",\n            version: \"1\",\n            chainId: options.chain.id,\n            verifyingContract: accountContract.address,\n          },\n          primaryType: \"AccountMessage\",\n          types: { AccountMessage: [{ name: \"message\", type: \"bytes\" }] },\n          message: { message: wrappedMessageHash },\n        });\n      } else {\n        sig = await options.personalAccount.signTypedData(typedData);\n      }\n\n      const isValid = await checkContractWalletSignedTypedData({\n        contract: accountContract,\n        data: typedData,\n        signature: sig,\n      });\n\n      if (isValid) {\n        return sig;\n      }\n      throw new Error(\n        \"Unable to verify signature on smart account, please make sure the smart account is deployed and the signature is valid.\",\n      );\n    },\n    async onTransactionRequested(transaction) {\n      return options.personalAccount.onTransactionRequested?.(transaction);\n    },\n  };\n  return account;\n}\n\nasync function approveERC20(args: {\n  accountContract: ThirdwebContract;\n  options: SmartAccountOptions;\n  erc20Paymaster: {\n    address: string;\n    token: string;\n  };\n}) {\n  const { accountContract, erc20Paymaster, options } = args;\n  const tokenAddress = erc20Paymaster.token;\n  const tokenContract = getContract({\n    address: tokenAddress,\n    chain: accountContract.chain,\n    client: accountContract.client,\n  });\n  const accountAllowance = await allowance({\n    contract: tokenContract,\n    owner: accountContract.address,\n    spender: erc20Paymaster.address,\n  });\n\n  if (accountAllowance > 0n) {\n    return;\n  }\n\n  const approveTx = approve({\n    contract: tokenContract,\n    spender: erc20Paymaster.address,\n    amountWei: maxUint96 - 1n,\n  });\n  const transaction = await toSerializableTransaction({\n    transaction: approveTx,\n    from: accountContract.address,\n  });\n  const executeTx = prepareExecute({\n    accountContract,\n    transaction,\n    executeOverride: options.overrides?.execute,\n  });\n  await _sendUserOp({\n    executeTx,\n    options: {\n      ...options,\n      overrides: {\n        ...options.overrides,\n        erc20Paymaster: undefined,\n      },\n    },\n  });\n}\n\nfunction createZkSyncAccount(args: {\n  creationOptions: SmartWalletOptions;\n  connectionOptions: SmartWalletConnectionOptions;\n  chain: Chain;\n  sponsorGas: boolean;\n}): Account {\n  const { creationOptions, connectionOptions, chain } = args;\n  const account: Account = {\n    address: connectionOptions.personalAccount.address,\n    async sendTransaction(transaction: SendTransactionOption) {\n      // override passed tx, we have to refetch gas and fees always\n      const prepTx = {\n        data: transaction.data,\n        to: transaction.to ?? undefined,\n        value: transaction.value ?? 0n,\n        chain: getCachedChain(transaction.chainId),\n        client: connectionOptions.client,\n        eip712: transaction.eip712,\n      };\n\n      let serializableTransaction = await populateEip712Transaction({\n        account,\n        transaction: prepTx,\n      });\n\n      if (args.sponsorGas && !serializableTransaction.paymaster) {\n        // get paymaster input\n        const pmData = await getZkPaymasterData({\n          options: {\n            client: connectionOptions.client,\n            chain,\n            bundlerUrl: creationOptions.overrides?.bundlerUrl,\n            entrypointAddress: creationOptions.overrides?.entrypointAddress,\n          },\n          transaction: serializableTransaction,\n        });\n        serializableTransaction = {\n          ...serializableTransaction,\n          ...pmData,\n        };\n      }\n\n      // sign\n      const signedTransaction = await signEip712Transaction({\n        account,\n        chainId: chain.id,\n        eip712Transaction: serializableTransaction,\n      });\n\n      // broadcast via bundler\n      const txHash = await broadcastZkTransaction({\n        options: {\n          client: connectionOptions.client,\n          chain,\n          bundlerUrl: creationOptions.overrides?.bundlerUrl,\n          entrypointAddress: creationOptions.overrides?.entrypointAddress,\n        },\n        transaction: serializableTransaction,\n        signedTransaction,\n      });\n      return {\n        transactionHash: txHash.transactionHash,\n        client: connectionOptions.client,\n        chain: chain,\n      };\n    },\n    async signMessage({ message }: { message: SignableMessage }) {\n      return connectionOptions.personalAccount.signMessage({ message });\n    },\n    async signTypedData<\n      const typedData extends TypedData | Record<string, unknown>,\n      primaryType extends keyof typedData | \"EIP712Domain\" = keyof typedData,\n    >(_typedData: TypedDataDefinition<typedData, primaryType>) {\n      const typedData = parseTypedData(_typedData);\n      return connectionOptions.personalAccount.signTypedData(typedData);\n    },\n    async onTransactionRequested(transaction) {\n      return connectionOptions.personalAccount.onTransactionRequested?.(\n        transaction,\n      );\n    },\n  };\n  return account;\n}\n\nasync function _deployAccount(args: {\n  options: SmartAccountOptions;\n  account: Account;\n  accountContract: ThirdwebContract;\n}) {\n  const { options, account, accountContract } = args;\n  const [{ sendTransaction }, { prepareTransaction }] = await Promise.all([\n    import(\"../../transaction/actions/send-transaction.js\"),\n    import(\"../../transaction/prepare-transaction.js\"),\n  ]);\n  const dummyTx = prepareTransaction({\n    client: options.client,\n    chain: options.chain,\n    to: accountContract.address,\n    value: 0n,\n    gas: 50000n, // force gas to avoid simulation error\n  });\n  const deployResult = await sendTransaction({\n    transaction: dummyTx,\n    account,\n  });\n  return deployResult;\n}\n\nasync function _sendUserOp(args: {\n  executeTx: PreparedTransaction;\n  options: SmartAccountOptions;\n}): Promise<WaitForReceiptOptions> {\n  const { executeTx, options } = args;\n  const unsignedUserOp = await createUnsignedUserOp({\n    transaction: executeTx,\n    factoryContract: options.factoryContract,\n    accountContract: options.accountContract,\n    adminAddress: options.personalAccount.address,\n    sponsorGas: options.sponsorGas,\n    overrides: options.overrides,\n  });\n  const signedUserOp = await signUserOp({\n    client: options.client,\n    chain: options.chain,\n    adminAccount: options.personalAccount,\n    entrypointAddress: options.overrides?.entrypointAddress,\n    userOp: unsignedUserOp,\n  });\n  const bundlerOptions: BundlerOptions = {\n    chain: options.chain,\n    client: options.client,\n    bundlerUrl: options.overrides?.bundlerUrl,\n    entrypointAddress: options.overrides?.entrypointAddress,\n  };\n  const userOpHash = await bundleUserOp({\n    options: bundlerOptions,\n    userOp: signedUserOp,\n  });\n  // wait for tx receipt rather than return the userOp hash\n  const receipt = await waitForUserOpReceipt({\n    ...bundlerOptions,\n    userOpHash,\n  });\n\n  // reset the isDeploying flag after every transaction\n  clearAccountDeploying(options.accountContract);\n\n  return {\n    client: options.client,\n    chain: options.chain,\n    transactionHash: receipt.transactionHash,\n  };\n}\n\nasync function confirmContractDeployment(args: {\n  accountContract: ThirdwebContract;\n}) {\n  const { accountContract } = args;\n  const startTime = Date.now();\n  const timeout = 60000; // wait 1 minute max\n  const { isContractDeployed } = await import(\n    \"../../utils/bytecode/is-contract-deployed.js\"\n  );\n  let isDeployed = await isContractDeployed(accountContract);\n  while (!isDeployed) {\n    if (Date.now() - startTime > timeout) {\n      throw new Error(\n        \"Timeout: Smart account deployment not confirmed after 1 minute\",\n      );\n    }\n    await new Promise((resolve) => setTimeout(resolve, 500));\n    isDeployed = await isContractDeployed(accountContract);\n  }\n}\nasync function getEntrypointFromFactory(\n  factoryAddress: string,\n  client: ThirdwebClient,\n  chain: Chain,\n) {\n  const factoryContract = getContract({\n    address: factoryAddress,\n    client,\n    chain,\n  });\n  try {\n    const entrypointAddress = await readContract({\n      contract: factoryContract,\n      method: \"function entrypoint() public view returns (address)\",\n    });\n    return entrypointAddress;\n  } catch {\n    return undefined;\n  }\n}\n"],
  "mappings": "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",
  "names": ["predictAddress", "FN_SELECTOR", "FN_INPUTS", "FN_OUTPUTS", "FN_SELECTOR", "FN_INPUTS", "FN_OUTPUTS", "FN_SELECTOR", "FN_INPUTS", "FN_OUTPUTS", "getUserOpHash", "FN_SELECTOR", "FN_INPUTS", "FN_OUTPUTS", "toHex", "getPaymasterAndData", "error", "getPaymasterAndData", "getUserOpHash", "isContractDeployed", "readContract", "encodeAbiParameters"]
}
