{
  "version": 3,
  "sources": ["../../node_modules/thirdweb/src/wallets/in-app/core/wallet/in-app-core.ts"],
  "sourcesContent": ["import { trackConnect } from \"../../../../analytics/track/connect.js\";\nimport type { Chain } from \"../../../../chains/types.js\";\nimport { getCachedChainIfExists } from \"../../../../chains/utils.js\";\nimport type { ThirdwebClient } from \"../../../../client/client.js\";\nimport { stringify } from \"../../../../utils/json.js\";\nimport { getEcosystemInfo } from \"../../../ecosystem/get-ecosystem-wallet-auth-options.js\";\nimport type { Account, Wallet } from \"../../../interfaces/wallet.js\";\nimport { createWalletEmitter } from \"../../../wallet-emitter.js\";\nimport type {\n  CreateWalletArgs,\n  EcosystemWalletId,\n} from \"../../../wallet-types.js\";\nimport type { InAppConnector } from \"../interfaces/connector.js\";\nimport type { Ecosystem } from \"./types.js\";\n\nconst connectorCache = new Map<string, InAppConnector>();\n\n/**\n * @internal\n */\nexport async function getOrCreateInAppWalletConnector(\n  client: ThirdwebClient,\n  connectorFactory: (client: ThirdwebClient) => Promise<InAppConnector>,\n  ecosystem?: Ecosystem,\n) {\n  const key = stringify({ clientId: client.clientId, ecosystem });\n  if (connectorCache.has(key)) {\n    return connectorCache.get(key) as InAppConnector;\n  }\n  const connector = await connectorFactory(client);\n  connectorCache.set(key, connector);\n  return connector;\n}\n\n/**\n * @internal\n */\nexport function createInAppWallet(args: {\n  createOptions?: CreateWalletArgs<\"inApp\">[1];\n  connectorFactory: (client: ThirdwebClient) => Promise<InAppConnector>;\n  ecosystem?: Ecosystem;\n}): Wallet<\"inApp\" | EcosystemWalletId> {\n  const { createOptions: _createOptions, connectorFactory, ecosystem } = args;\n  const walletId = ecosystem ? ecosystem.id : \"inApp\";\n  const emitter = createWalletEmitter<\"inApp\">();\n  let createOptions = _createOptions;\n  let account: Account | undefined = undefined;\n  let chain: Chain | undefined = undefined;\n  let client: ThirdwebClient | undefined;\n\n  return {\n    id: walletId,\n    subscribe: emitter.subscribe,\n    getChain() {\n      if (!chain) {\n        return undefined;\n      }\n\n      chain = getCachedChainIfExists(chain.id) || chain;\n      return chain;\n    },\n    getConfig: () => createOptions,\n    getAccount: () => account,\n    autoConnect: async (options) => {\n      const { autoConnectInAppWallet } = await import(\"./index.js\");\n\n      const connector = await getOrCreateInAppWalletConnector(\n        options.client,\n        connectorFactory,\n        ecosystem,\n      );\n\n      if (ecosystem) {\n        const ecosystemOptions = await getEcosystemInfo(ecosystem.id);\n        const smartAccountOptions = ecosystemOptions?.smartAccountOptions;\n        if (smartAccountOptions) {\n          const preferredChain = options.chain;\n          if (!preferredChain) {\n            throw new Error(\n              \"Chain is required for ecosystem smart accounts, pass it via connect() or via UI components\",\n            );\n          }\n          createOptions = {\n            ...createOptions,\n            smartAccount: {\n              chain: preferredChain,\n              sponsorGas: smartAccountOptions.sponsorGas,\n              factoryAddress: smartAccountOptions.accountFactoryAddress,\n            },\n          };\n        }\n      }\n\n      const [connectedAccount, connectedChain] = await autoConnectInAppWallet(\n        options,\n        createOptions,\n        connector,\n      );\n\n      // set the states\n      client = options.client;\n      account = connectedAccount;\n      chain = connectedChain;\n      trackConnect({\n        client: options.client,\n        ecosystem,\n        walletType: walletId,\n        walletAddress: account.address,\n        chainId: chain.id,\n      });\n      // return only the account\n      return account;\n    },\n    connect: async (options) => {\n      const { connectInAppWallet } = await import(\"./index.js\");\n      const connector = await getOrCreateInAppWalletConnector(\n        options.client,\n        connectorFactory,\n        ecosystem,\n      );\n\n      if (ecosystem) {\n        const ecosystemOptions = await getEcosystemInfo(ecosystem.id);\n        const smartAccountOptions = ecosystemOptions?.smartAccountOptions;\n        if (smartAccountOptions) {\n          const preferredChain = options.chain;\n          if (!preferredChain) {\n            throw new Error(\n              \"Chain is required for ecosystem smart accounts, pass it via connect() or via UI components\",\n            );\n          }\n          createOptions = {\n            ...createOptions,\n            smartAccount: {\n              chain: preferredChain,\n              sponsorGas: smartAccountOptions.sponsorGas,\n              factoryAddress: smartAccountOptions.accountFactoryAddress,\n            },\n          };\n        }\n      }\n\n      const [connectedAccount, connectedChain] = await connectInAppWallet(\n        options,\n        createOptions,\n        connector,\n      );\n      // set the states\n      client = options.client;\n      account = connectedAccount;\n      chain = connectedChain;\n      trackConnect({\n        client: options.client,\n        ecosystem,\n        walletType: walletId,\n        walletAddress: account.address,\n        chainId: chain.id,\n      });\n      // return only the account\n      return account;\n    },\n    disconnect: async () => {\n      // If no client is assigned, we should be fine just unsetting the states\n      if (client) {\n        const connector = await getOrCreateInAppWalletConnector(\n          client,\n          connectorFactory,\n          ecosystem,\n        );\n        const result = await connector.logout();\n        if (!result.success) {\n          throw new Error(\"Failed to logout\");\n        }\n      }\n      account = undefined;\n      chain = undefined;\n      emitter.emit(\"disconnect\", undefined);\n    },\n    switchChain: async (newChain) => {\n      if (createOptions?.smartAccount && client && account) {\n        // if account abstraction is enabled, reconnect to smart account on the new chain\n        const { autoConnectInAppWallet } = await import(\"./index.js\");\n        const connector = await getOrCreateInAppWalletConnector(\n          client,\n          connectorFactory,\n          ecosystem,\n        );\n\n        if (ecosystem) {\n          const ecosystemOptions = await getEcosystemInfo(ecosystem.id);\n          const smartAccountOptions = ecosystemOptions?.smartAccountOptions;\n          if (smartAccountOptions) {\n            createOptions = {\n              ...createOptions,\n              smartAccount: {\n                chain: newChain,\n                sponsorGas: smartAccountOptions.sponsorGas,\n                factoryAddress: smartAccountOptions.accountFactoryAddress,\n              },\n            };\n          }\n        }\n\n        const [connectedAccount, connectedChain] = await autoConnectInAppWallet(\n          {\n            chain: newChain,\n            client,\n          },\n          createOptions,\n          connector,\n        );\n        account = connectedAccount;\n        chain = connectedChain;\n      } else {\n        // if not, simply set the new chain\n        chain = newChain;\n      }\n      emitter.emit(\"chainChanged\", newChain);\n    },\n  };\n}\n"],
  "mappings": "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",
  "names": []
}
