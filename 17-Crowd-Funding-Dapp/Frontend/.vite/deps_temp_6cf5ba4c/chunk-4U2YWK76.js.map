{
  "version": 3,
  "sources": ["../../node_modules/thirdweb/src/utils/nft/fetchTokenMetadata.ts"],
  "sourcesContent": ["import type { ThirdwebClient } from \"../../client/client.js\";\nimport { isBase64JSON, parseBase64String } from \"../base64/base64.js\";\nimport { numberToHex } from \"../encoding/hex.js\";\nimport type { NFTMetadata } from \"./parseNft.js\";\n\n/**\n * @internal\n */\nexport type FetchTokenMetadataOptions = {\n  client: ThirdwebClient;\n  tokenId: bigint;\n  tokenUri: string;\n};\n\n/**\n * Fetches the metadata for a token.\n *\n * @param options - The options for fetching the token metadata.\n * @returns The token metadata.\n * @internal\n */\nexport async function fetchTokenMetadata(\n  options: FetchTokenMetadataOptions,\n): Promise<NFTMetadata> {\n  const { client, tokenId, tokenUri } = options;\n  // handle case where the URI is a base64 encoded JSON (onchain nft)\n  if (isBase64JSON(tokenUri)) {\n    try {\n      return JSON.parse(parseBase64String(tokenUri));\n    } catch (e) {\n      console.error(\n        \"Failed to fetch base64 encoded NFT\",\n        { tokenId, tokenUri },\n        e,\n      );\n      throw e;\n    }\n  }\n\n  // in all other cases we will need the `download` function from storage\n  const { download } = await import(\"../../storage/download.js\");\n\n  // handle non-dynamic uris (most common case -> skip the other checks)\n  try {\n    if (!tokenUri.includes(\"{id}\")) {\n      return await (await download({ client, uri: tokenUri })).json();\n    }\n  } catch (e) {\n    console.error(\"Failed to fetch non-dynamic NFT\", { tokenId, tokenUri }, e);\n    throw e;\n  }\n\n  // DYNAMIC NFT FORMATS (2 options, sadly has to be waterfall)\n  try {\n    try {\n      // try first dynamic id format\n      return await (\n        await download({\n          client,\n          uri: tokenUri.replace(\n            \"{id}\",\n            numberToHex(tokenId, { size: 32 }).slice(2),\n          ),\n        })\n      ).json();\n    } catch {\n      // otherwise attempt the second format\n      return await (\n        await download({\n          client,\n          uri: tokenUri.replace(\"{id}\", tokenId.toString()),\n        })\n      ).json();\n    }\n  } catch (e) {\n    console.error(\"Failed to fetch dynamic NFT\", { tokenId, tokenUri }, e);\n    throw e;\n  }\n}\n"],
  "mappings": ";;;;;;;;;AAqBA,eAAsB,mBACpB,SAAkC;AAElC,QAAM,EAAE,QAAQ,SAAS,SAAQ,IAAK;AAEtC,MAAI,aAAa,QAAQ,GAAG;AAC1B,QAAI;AACF,aAAO,KAAK,MAAM,kBAAkB,QAAQ,CAAC;IAC/C,SAAS,GAAG;AACV,cAAQ,MACN,sCACA,EAAE,SAAS,SAAQ,GACnB,CAAC;AAEH,YAAM;IACR;EACF;AAGA,QAAM,EAAE,SAAQ,IAAK,MAAM,OAAO,wBAA2B;AAG7D,MAAI;AACF,QAAI,CAAC,SAAS,SAAS,MAAM,GAAG;AAC9B,aAAO,OAAO,MAAM,SAAS,EAAE,QAAQ,KAAK,SAAQ,CAAE,GAAG,KAAI;IAC/D;EACF,SAAS,GAAG;AACV,YAAQ,MAAM,mCAAmC,EAAE,SAAS,SAAQ,GAAI,CAAC;AACzE,UAAM;EACR;AAGA,MAAI;AACF,QAAI;AAEF,aAAO,OACL,MAAM,SAAS;QACb;QACA,KAAK,SAAS,QACZ,QACA,YAAY,SAAS,EAAE,MAAM,GAAE,CAAE,EAAE,MAAM,CAAC,CAAC;OAE9C,GACD,KAAI;IACR,QAAQ;AAEN,aAAO,OACL,MAAM,SAAS;QACb;QACA,KAAK,SAAS,QAAQ,QAAQ,QAAQ,SAAQ,CAAE;OACjD,GACD,KAAI;IACR;EACF,SAAS,GAAG;AACV,YAAQ,MAAM,+BAA+B,EAAE,SAAS,SAAQ,GAAI,CAAC;AACrE,UAAM;EACR;AACF;",
  "names": []
}
