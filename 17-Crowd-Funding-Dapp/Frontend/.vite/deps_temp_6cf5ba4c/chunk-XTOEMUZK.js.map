{
  "version": 3,
  "sources": ["../../node_modules/@passwordless-id/webauthn/src/client.ts", "../../node_modules/@passwordless-id/webauthn/src/utils.ts", "../../node_modules/@passwordless-id/webauthn/src/server.ts", "../../node_modules/@passwordless-id/webauthn/src/parsers.ts", "../../node_modules/@passwordless-id/webauthn/src/authenticatorMetadata.ts", "../../node_modules/@passwordless-id/webauthn/src/authenticators.ts", "../../node_modules/@passwordless-id/webauthn/src/index.ts", "../../node_modules/thirdweb/src/wallets/in-app/web/lib/auth/passkeys.ts"],
  "sourcesContent": ["import * as utils from './utils.js'\nimport { AuthenticateOptions, AuthenticationEncoded, AuthType, NamedAlgo, NumAlgo, RegisterOptions, RegistrationEncoded } from './types.js'\n\n/**\n * Returns whether passwordless authentication is available on this browser/platform or not.\n */\n export function isAvailable() :boolean {\n    return !!window.PublicKeyCredential\n}\n\n/**\n * Returns whether the device itself can be used as authenticator.\n */\nexport async function isLocalAuthenticator() :Promise<boolean> {\n    return await PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable()\n}\n\n\n\n\nasync function getAuthAttachment(authType :AuthType) :Promise<AuthenticatorAttachment|undefined> {\n    if(authType === \"local\")\n        return \"platform\";\n    if(authType === \"roaming\" || authType === \"extern\")\n        return \"cross-platform\";\n    if(authType === \"both\")\n        return undefined // The webauthn protocol considers `null` as invalid but `undefined` as \"both\"!\n\n    // the default case: \"auto\", depending on device capabilities\n    try {\n        if(await isLocalAuthenticator())\n            return \"platform\"\n        else\n            return \"cross-platform\"\n    } catch(e) {\n        // might happen due to some security policies\n        // see https://w3c.github.io/webauthn/#sctn-isUserVerifyingPlatformAuthenticatorAvailable\n        return undefined // The webauthn protocol considers `null` as invalid but `undefined` as \"both\"!\n    }\n}\n\n\n\nfunction getAlgoName(num :NumAlgo) :NamedAlgo {\n    switch(num) {\n        case -7: return \"ES256\"\n        // case -8 ignored to to its rarity\n        case -257: return \"RS256\"\n        default: throw new Error(`Unknown algorithm code: ${num}`)\n    }\n}\n\n\n\n/**\n * Creates a cryptographic key pair, in order to register the public key for later passwordless authentication.\n *\n * @param {string} username\n * @param {string} challenge A server-side randomly generated string.\n * @param {Object} [options] Optional parameters.\n * @param {number} [options.timeout=60000] Number of milliseconds the user has to respond to the biometric/PIN check.\n * @param {'required'|'preferred'|'discouraged'} [options.userVerification='required'] Whether to prompt for biometric/PIN check or not.\n * @param {'auto'|'local'|'roaming'|'both'}       [options.authenticatorType='auto'] Which device to use as authenticator.\n *          'auto': if the local device can be used as authenticator it will be preferred. Otherwise it will prompt for a roaming device.\n *          'local': use the local device (using TouchID, FaceID, Windows Hello or PIN)\n *          'roaming': use a roaming device (security key or connected phone)\n *          'both': prompt the user to choose between local or roaming device. The UI and user interaction in this case is platform specific.\n * @param {boolean} [options.attestation=false] If enabled, the device attestation and clientData will be provided as Base64url encoded binary data.\n *                                Note that this is not available on some platforms.\n * @param {'discouraged'|'preferred'|'required'} [options.discoverable] A \"discoverable\" credential can be selected using `authenticate(...)` without providing credential IDs.\n *              Instead, a native pop-up will appear for user selection.\n *              This may have an impact on the \"passkeys\" user experience and syncing behavior of the key.\n */\nexport async function register(username :string, challenge :string, options? :RegisterOptions) :Promise<RegistrationEncoded> {\n    options = options ?? {}\n\n    if(!utils.isBase64url(challenge))\n        throw new Error('Provided challenge is not properly encoded in Base64url')\n\n    const creationOptions :PublicKeyCredentialCreationOptions = {\n        challenge: utils.parseBase64url(challenge),\n        rp: {\n            id: options.domain ?? window.location.hostname,\n            name: options.domain ?? window.location.hostname\n        },\n        user: {\n            id: options.userHandle ? utils.toBuffer(options.userHandle) : await utils.sha256(new TextEncoder().encode('passwordless.id-user:' + username)), // ID should not be directly \"identifiable\" for privacy concerns\n            name: username,\n            displayName: username,\n        },\n        pubKeyCredParams: [\n            {alg: -7, type: \"public-key\"},   // ES256 (Webauthn's default algorithm)\n            {alg: -257, type: \"public-key\"}, // RS256 (for Windows Hello and others)\n        ],\n        timeout: options.timeout ?? 60000,\n        authenticatorSelection: {\n            userVerification: options.userVerification ?? \"required\", // Webauthn default is \"preferred\"\n            authenticatorAttachment: await getAuthAttachment(options.authenticatorType ?? \"auto\"),\n            residentKey: options.discoverable ?? 'preferred', // official default is 'discouraged'\n            requireResidentKey: (options.discoverable === 'required') // mainly for backwards compatibility, see https://www.w3.org/TR/webauthn/#dictionary-authenticatorSelection\n        },\n        attestation: \"direct\"\n    }\n\n    if(options.debug)\n        console.debug(creationOptions)\n\n    const credential = await navigator.credentials.create({publicKey: creationOptions, signal: options.signal}) as any //PublicKeyCredential\n    \n    if(options.debug)\n        console.debug(credential)\n   \n    const response = credential.response as any // AuthenticatorAttestationResponse\n    \n    let registration :RegistrationEncoded = {\n        username: username,\n        credential: {\n            id: credential.id,\n            publicKey: utils.toBase64url(response.getPublicKey()),\n            algorithm: getAlgoName(credential.response.getPublicKeyAlgorithm())\n        },\n        authenticatorData: utils.toBase64url(response.getAuthenticatorData()),\n        clientData: utils.toBase64url(response.clientDataJSON),\n    }\n\n    if(options.attestation) {\n        registration.attestationData = utils.toBase64url(response.attestationObject)\n    }\n\n    return registration\n}\n\n\nasync function getTransports(authType :AuthType) :Promise<AuthenticatorTransport[]> {\n    const local  :AuthenticatorTransport[] = ['internal']\n\n    // 'hybrid' was added mid-2022 in the specs and currently not yet available in the official dom types\n    // @ts-ignore\n    const roaming :AuthenticatorTransport[] = ['hybrid', 'usb', 'ble', 'nfc']\n    \n    if(authType === \"local\")\n        return local\n    if(authType == \"roaming\" || authType === \"extern\")\n        return roaming\n    if(authType === \"both\")\n        return [...local, ...roaming]\n\n    // the default case: \"auto\", depending on device capabilities\n    try {\n        if(await isLocalAuthenticator())\n            return local\n        else\n            return roaming\n    } catch(e) {\n        return [...local, ...roaming]\n    }\n}\n\n\n/**\n * Signs a challenge using one of the provided credentials IDs in order to authenticate the user.\n *\n * @param {string[]} credentialIds The list of credential IDs that can be used for signing.\n * @param {string} challenge A server-side randomly generated string, the base64 encoded version will be signed.\n * @param {Object} [options] Optional parameters.\n * @param {number} [options.timeout=60000] Number of milliseconds the user has to respond to the biometric/PIN check.\n * @param {'required'|'preferred'|'discouraged'} [options.userVerification='required'] Whether to prompt for biometric/PIN check or not.\n * @param {'optional'|'conditional'|'required'|'silent'} [options.mediation='optional'] https://developer.mozilla.org/en-US/docs/Web/API/CredentialsContainer/get#mediation\n */\nexport async function authenticate(credentialIds :string[], challenge :string, options? :AuthenticateOptions) :Promise<AuthenticationEncoded> {\n    options = options ?? {}\n\n    if(!utils.isBase64url(challenge))\n        throw new Error('Provided challenge is not properly encoded in Base64url')\n\n    const transports = await getTransports(options.authenticatorType ?? \"auto\");\n\n    let authOptions :PublicKeyCredentialRequestOptions = {\n        challenge: utils.parseBase64url(challenge),\n        rpId: options.domain ?? window.location.hostname,\n        allowCredentials: credentialIds.map(id => { return {\n            id: utils.parseBase64url(id),\n            type: 'public-key',\n            transports: transports,\n        }}),\n        userVerification: options.userVerification ?? \"required\",\n        timeout: options.timeout ?? 60000,\n    }\n\n    if(options.debug)\n        console.debug(authOptions)\n\n    let auth = await navigator.credentials.get({\n      publicKey: authOptions,\n      mediation: options.mediation,\n      signal: options.signal,\n    }) as PublicKeyCredential\n    \n    if(options.debug)\n        console.debug(auth)\n\n    const response = auth.response as AuthenticatorAssertionResponse\n    \n    const authentication :AuthenticationEncoded = {\n        credentialId: auth.id,\n        authenticatorData: utils.toBase64url(response.authenticatorData),\n        clientData: utils.toBase64url(response.clientDataJSON),\n        signature: utils.toBase64url(response.signature),\n        userHandle: response.userHandle ? utils.toBase64url(response.userHandle) : undefined // may not be returned by every authenticator\n    }\n\n    return authentication\n}\n\n", "/********************************\n     Encoding/Decoding Utils\n********************************/\n\nexport function randomChallenge() {\n    return crypto.randomUUID()\n}\n\n\nexport function toBuffer(txt :string) :ArrayBuffer {\n    return Uint8Array.from(txt, c => c.charCodeAt(0)).buffer\n}\n\nexport function parseBuffer(buffer :ArrayBuffer) :string {\n    return String.fromCharCode(...new Uint8Array(buffer))\n}\n\n\nexport function isBase64url(txt :string) :boolean {\n    return txt.match(/^[a-zA-Z0-9\\-_]+=*$/) !== null\n}\n\nexport function toBase64url(buffer :ArrayBuffer) :string {\n    const txt = btoa(parseBuffer(buffer)) // base64\n    return txt.replaceAll('+', '-').replaceAll('/', '_')\n}\n\nexport function parseBase64url(txt :string) :ArrayBuffer {\n    txt = txt.replaceAll('-', '+').replaceAll('_', '/') // base64url -> base64\n    return toBuffer(atob(txt))\n}\n\n\nexport async function sha256(buffer :ArrayBuffer) :Promise<ArrayBuffer> {\n    return await crypto.subtle.digest('SHA-256', buffer)\n}\n\nexport function bufferToHex (buffer :ArrayBuffer) :string {\n    return [...new Uint8Array (buffer)]\n        .map (b => b.toString (16).padStart (2, \"0\"))\n        .join (\"\");\n}\n\n\nexport function concatenateBuffers(buffer1 :ArrayBuffer, buffer2  :ArrayBuffer) {\n    var tmp = new Uint8Array(buffer1.byteLength + buffer2.byteLength);\n    tmp.set(new Uint8Array(buffer1), 0);\n    tmp.set(new Uint8Array(buffer2), buffer1.byteLength);\n    return tmp;\n  };", "import { parseAuthentication, parseRegistration } from \"./parsers.js\";\nimport { AuthenticationEncoded, AuthenticationParsed, CredentialKey, NamedAlgo, RegistrationEncoded, RegistrationParsed } from \"./types.js\";\nimport * as utils from './utils.js'\n\n\nasync function isValid(validator :any, value :any) :Promise<boolean> {\n   if(typeof validator === 'function') {\n        const res = validator(value)\n        if(res instanceof Promise)\n            return await res\n        else\n            return res\n    }\n    // the validator can be a single value too\n    return validator === value\n}\n\nasync function isNotValid(validator :any, value :any) :Promise<boolean> {\n    return !(await isValid(validator, value))\n}\n\ninterface RegistrationChecks {\n    challenge: string | Function,\n    origin: string | Function\n}\n\n\nexport async function verifyRegistration(registrationRaw: RegistrationEncoded, expected: RegistrationChecks): Promise<RegistrationParsed> {\n    const registration = parseRegistration(registrationRaw)\n\n    if (registration.client.type !== \"webauthn.create\")\n        throw new Error(`Unexpected ClientData type: ${registration.client.type}`)\n\n    if (await isNotValid(expected.origin, registration.client.origin))\n        throw new Error(`Unexpected ClientData origin: ${registration.client.origin}`)\n\n    if (await isNotValid(expected.challenge, registration.client.challenge))\n        throw new Error(`Unexpected ClientData challenge: ${registration.client.challenge}`)\n\n    return registration\n}\n\n\ninterface AuthenticationChecks {\n    challenge: string | Function,\n    origin: string | Function,\n    userVerified: boolean,\n    counter?: number, // Made optional according to https://github.com/passwordless-id/webauthn/issues/38\n    domain ?:string, // Same as `rp.id`\n    verbose?: boolean\n}\n\n\nexport async function verifyAuthentication(authenticationRaw: AuthenticationEncoded, credential: CredentialKey, expected: AuthenticationChecks): Promise<AuthenticationParsed> {\n    if (authenticationRaw.credentialId !== credential.id)\n        throw new Error(`Credential ID mismatch: ${authenticationRaw.credentialId} vs ${credential.id}`)\n\n    const isValidSignature: boolean = await verifySignature({\n        algorithm: credential.algorithm,\n        publicKey: credential.publicKey,\n        authenticatorData: authenticationRaw.authenticatorData,\n        clientData: authenticationRaw.clientData,\n        signature: authenticationRaw.signature,\n        verbose: expected.verbose\n    })\n\n    if(!isValidSignature)\n        throw new Error(`Invalid signature: ${authenticationRaw.signature}`)\n\n    const authentication = parseAuthentication(authenticationRaw)\n    if(expected.verbose)\n        console.debug(authentication)\n\n    if (authentication.client.type !== \"webauthn.get\")\n        throw new Error(`Unexpected clientData type: ${authentication.client.type}`)\n\n    if (await isNotValid(expected.origin, authentication.client.origin))\n        throw new Error(`Unexpected ClientData origin: ${authentication.client.origin}`)\n\n    if (await isNotValid(expected.challenge, authentication.client.challenge))\n        throw new Error(`Unexpected ClientData challenge: ${authentication.client.challenge}`)\n\n    // this only works because we consider `rp.origin` and `rp.id` to be the same during authentication/registration\n    const rpId = expected.domain ?? new URL(authentication.client.origin).hostname\n    const expectedRpIdHash = utils.toBase64url(await utils.sha256(utils.toBuffer(rpId)))\n    if (authentication.authenticator.rpIdHash !== expectedRpIdHash)\n        throw new Error(`Unexpected RpIdHash: ${authentication.authenticator.rpIdHash} vs ${expectedRpIdHash}`)\n\n    if (!authentication.authenticator.flags.userPresent)\n        throw new Error(`Unexpected authenticator flags: missing userPresent`)\n\n    if (!authentication.authenticator.flags.userVerified && expected.userVerified)\n        throw new Error(`Unexpected authenticator flags: missing userVerified`)\n\n    if (expected.counter && authentication.authenticator.counter <= expected.counter)\n        throw new Error(`Unexpected authenticator counter: ${authentication.authenticator.counter} (should be > ${expected.counter})`)\n\n    return authentication\n}\n\n\n// https://w3c.github.io/webauthn/#sctn-public-key-easy\n// https://www.iana.org/assignments/cose/cose.xhtml#algorithms\n/*\nUser agents MUST be able to return a non-null value for getPublicKey() when the credential public key has a COSEAlgorithmIdentifier value of:\n\n-7 (ES256), where kty is 2 (with uncompressed points) and crv is 1 (P-256).\n\n-257 (RS256).\n\n-8 (EdDSA), where crv is 6 (Ed25519).\n*/\nfunction getAlgoParams(algorithm: NamedAlgo): any {\n    switch (algorithm) {\n        case 'RS256':\n            return {\n                name: 'RSASSA-PKCS1-v1_5',\n                hash: 'SHA-256'\n            };\n        case 'ES256':\n            return {\n                name: 'ECDSA',\n                namedCurve: 'P-256',\n                hash: 'SHA-256',\n            };\n        // case 'EdDSA': Not supported by browsers\n        default:\n            throw new Error(`Unknown or unsupported crypto algorithm: ${algorithm}. Only 'RS256' and 'ES256' are supported.`)\n    }\n}\n\ntype AlgoParams = AlgorithmIdentifier | RsaHashedImportParams | EcKeyImportParams | HmacImportParams | AesKeyAlgorithm\n\nasync function parseCryptoKey(algoParams: AlgoParams, publicKey: string): Promise<CryptoKey> {\n    const buffer = utils.parseBase64url(publicKey)\n    return crypto.subtle.importKey('spki', buffer, algoParams, false, ['verify'])\n}\n\n\n\ntype VerifyParams = {\n    algorithm: NamedAlgo,\n    publicKey: string, // Base64url encoded\n    authenticatorData: string, // Base64url encoded\n    clientData: string, // Base64url encoded\n    signature: string, // Base64url encoded\n    verbose?: boolean, // Enables debug logs containing sensitive data like crypto keys\n}\n\n\n// https://w3c.github.io/webauthn/#sctn-verifying-assertion\n// https://w3c.github.io/webauthn/#sctn-signature-attestation-types\n/* Emphasis mine:\n\n6.5.6. Signature Formats for Packed Attestation, FIDO U2F Attestation, and **Assertion Signatures**\n\n[...] For COSEAlgorithmIdentifier -7 (ES256) [...] the sig value MUST be encoded as an ASN.1 [...]\n[...] For COSEAlgorithmIdentifier -257 (RS256) [...] The signature is not ASN.1 wrapped.\n[...] For COSEAlgorithmIdentifier -37 (PS256) [...] The signature is not ASN.1 wrapped.\n*/\n// see also https://gist.github.com/philholden/50120652bfe0498958fd5926694ba354\nexport async function verifySignature({ algorithm, publicKey, authenticatorData, clientData, signature, verbose }: VerifyParams): Promise<boolean> {\n    const algoParams = getAlgoParams(algorithm)\n    let cryptoKey = await parseCryptoKey(algoParams, publicKey)\n\n    if(verbose) {\n        console.debug(cryptoKey)\n    }\n\n    let clientHash = await utils.sha256(utils.parseBase64url(clientData));\n\n    // during \"login\", the authenticatorData is exactly 37 bytes\n    let comboBuffer = utils.concatenateBuffers(utils.parseBase64url(authenticatorData), clientHash)\n\n    if(verbose) {\n        console.debug('Crypto Algo: ' + JSON.stringify(algoParams))\n        console.debug('Public key: ' + publicKey)\n        console.debug('Data: ' + utils.toBase64url(comboBuffer))\n        console.debug('Signature: ' + signature)\n    }\n\n    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/verify\n    let signatureBuffer = utils.parseBase64url(signature)\n    if(algorithm == 'ES256')\n        signatureBuffer = convertASN1toRaw(signatureBuffer)\n\n    const isValid = await crypto.subtle.verify(algoParams, cryptoKey, signatureBuffer, comboBuffer)\n\n    return isValid\n}\n\nfunction convertASN1toRaw(signatureBuffer :ArrayBuffer) {\n    // Convert signature from ASN.1 sequence to \"raw\" format\n    const usignature = new Uint8Array(signatureBuffer);\n    const rStart = usignature[4] === 0 ? 5 : 4;\n    const rEnd = rStart + 32;\n    const sStart = usignature[rEnd + 2] === 0 ? rEnd + 3 : rEnd + 2;\n    const r = usignature.slice(rStart, rEnd);\n    const s = usignature.slice(sStart);\n    return new Uint8Array([...r, ...s]);\n}", "import * as authenticators from './authenticators.js'\nimport * as utils from './utils.js'\nimport { AuthenticatorInfo, ClientInfo, RegistrationEncoded, RegistrationParsed, AuthenticationEncoded, AuthenticationParsed } from './types'\n\nconst utf8Decoder = new TextDecoder('utf-8')\n\nexport function parseClient(data :string|ArrayBuffer) :ClientInfo {\n    if(typeof data == 'string')\n        data = utils.parseBase64url(data)\n    return JSON.parse(utf8Decoder.decode(data))\n}\n\n\nexport function parseAuthenticator(data :string|ArrayBuffer) :AuthenticatorInfo {\n    if(typeof data == 'string')\n        data = utils.parseBase64url(data)\n    return authenticators.parseAuthBuffer(data)\n}\n\n\nexport function parseAttestation(data :string|ArrayBuffer) :unknown {\n    //if(typeof data == 'string')\n    //    data = utils.parseBase64url(data)\n    // Useless comment, let's at least provide the raw value \n    // return \"The device attestation proves the authenticity of the device model / aaguid. It's not guaranteed to be included and really complex to parse / verify. Good luck with that one!\"\n    return data;\n}\n\n\n\nexport function parseRegistration(registration :RegistrationEncoded) :RegistrationParsed {\n    return {\n        username: registration.username,\n        credential: registration.credential,\n\n        client:        parseClient(registration.clientData),\n        authenticator: parseAuthenticator(registration.authenticatorData),\n        attestation:   registration.attestationData ? parseAttestation(registration.attestationData) : null\n    }\n}\n\nexport function parseAuthentication(authentication :AuthenticationEncoded) :AuthenticationParsed {\n    return {\n        credentialId:  authentication.credentialId,\n        client:        parseClient(authentication.clientData),\n        authenticator: parseAuthenticator(authentication.authenticatorData),\n        signature: authentication.signature\n    }\n}", "/**\n * The source comes from\n * \"official\" https://mds.fidoalliance.org/\n * and the\n * \"community-driven\" https://github.com/passkeydeveloper/passkey-authenticator-aaguids\n * combined together.\n */\nexport const authenticatorMetadata :Record<string, string> = {\n\t\"00000000-0000-0000-0000-000000000000\": \"Unknown authenticator\",\n\t\"0076631b-d4a0-427f-5773-0ec71c9e0279\": \"HYPR FIDO2 Authenticator\",\n\t\"07a9f89c-6407-4594-9d56-621d5f1e358b\": \"NXP Semiconductros FIDO2 Conformance Testing CTAP2 Authenticator\",\n\t\"08987058-cadc-4b81-b6e1-30de50dcbe96\": \"Windows Hello\",\n\t\"09591fc6-9811-48f7-8f57-b9f23df6413f\": \"Pone Biometrics OFFPAD Authenticator\",\n\t\"0acf3011-bc60-f375-fb53-6f05f43154e0\": \"Nymi FIDO2 Authenticator\",\n\t\"0bb43545-fd2c-4185-87dd-feb0b2916ace\": \"Security Key NFC by Yubico - Enterprise Edition\",\n\t\"0d9b2e56-566b-c393-2940-f821b7f15d6d\": \"Excelsecu eSecu FIDO2 Pro Security Key\",\n\t\"0ea242b4-43c4-4a1b-8b17-dd6d0b6baec6\": \"Keeper\",\n\t\"1105e4ed-af1d-02ff-ffff-ffffffffffff\": \"Egomet FIDO2 Authenticator for Android\",\n\t\"12ded745-4bed-47d4-abaa-e713f51d6393\": \"Feitian AllinOne FIDO2 Authenticator\",\n\t\"149a2021-8ef6-4133-96b8-81f8d5b7f1f5\": \"Security Key by Yubico with NFC\",\n\t\"17290f1e-c212-34d0-1423-365d729f09d9\": \"Thales PIN iOS SDK\",\n\t\"175cd298-83d2-4a26-b637-313c07a6434e\": \"Chunghwa Telecom FIDO2 Smart Card Authenticator\",\n\t\"1c086528-58d5-f211-823c-356786e36140\": \"Atos CardOS FIDO2\",\n\t\"20f0be98-9af9-986a-4b42-8eca4acb28e4\": \"Excelsecu eSecu FIDO2 Fingerprint Security Key\",\n\t\"2194b428-9397-4046-8f39-007a1605a482\": \"IDPrime 931 Fido\",\n\t\"23786452-f02d-4344-87ed-aaf703726881\": \"SafeNet eToken Fusion CC\",\n\t\"2c0df832-92de-4be1-8412-88a8f074df4a\": \"Feitian FIDO Smart Card\",\n\t\"2d3bec26-15ee-4f5d-88b2-53622490270b\": \"HID Crescendo Key V2\",\n\t\"2fc0579f-8113-47ea-b116-bb5a8db9202a\": \"YubiKey 5 Series with NFC\",\n\t\"2ffd6452-01da-471f-821b-ea4bf6c8676a\": \"IDPrime 941 Fido\",\n\t\"30b5035e-d297-4fc1-b00b-addc96ba6a97\": \"OneSpan FIDO Touch\",\n\t\"30b5035e-d297-4ff1-b00b-addc96ba6a98\": \"OneSpan DIGIPASS FX1 BIO\",\n\t\"341e4da9-3c2e-8103-5a9f-aad887135200\": \"Ledger Nano S FIDO2 Authenticator\",\n\t\"34f5766d-1536-4a24-9033-0e294e510fb0\": \"YubiKey 5 Series CTAP2.1 Preview Expired \",\n\t\"361a3082-0278-4583-a16f-72a527f973e4\": \"eWBM eFA500 FIDO2 Authenticator\",\n\t\"3789da91-f943-46bc-95c3-50ea2012f03a\": \"NEOWAVE Winkeo FIDO2\",\n\t\"39a5647e-1853-446c-a1f6-a79bae9f5bc7\": \"IDmelon\",\n\t\"3b1adb99-0dfe-46fd-90b8-7f7614a4de2a\": \"GoTrust Idem Key FIDO2 Authenticator\",\n\t\"3e078ffd-4c54-4586-8baa-a77da113aec5\": \"Hideez Key 3 FIDO2\",\n\t\"3e22415d-7fdf-4ea4-8a0c-dd60c4249b9d\": \"Feitian iePass FIDO Authenticator\",\n\t\"3f59672f-20aa-4afe-b6f4-7e5e916b6d98\": \"Arculus FIDO 2.1 Key Card [P71]\",\n\t\"42b4fb4a-2866-43b2-9bf7-6c6669c2e5d3\": \"Google Titan Security Key v2\",\n\t\"454e5346-4944-4ffd-6c93-8e9267193e9a\": \"Ensurity ThinC\",\n\t\"4b3f8944-d4f2-4d21-bb19-764a986ec160\": \"KeyXentic FIDO2 Secp256R1 FIDO2 CTAP2 Authenticator\",\n\t\"4c0cf95d-2f40-43b5-ba42-4c83a11c04ba\": \"Feitian BioPass FIDO2 Pro Authenticator\",\n\t\"4c50ff10-1057-4fc6-b8ed-43a529530c3c\": \"ImproveID Authenticator\",\n\t\"4d41190c-7beb-4a84-8018-adf265a6352d\": \"Thales IDPrime FIDO Bio\",\n\t\"4e768f2c-5fab-48b3-b300-220eb487752b\": \"Hideez Key 4 FIDO2 SDK\",\n\t\"504d7149-4e4c-3841-4555-55445a677357\": \"WiSECURE AuthTron USB FIDO2 Authenticator\",\n\t\"50a45b0c-80e7-f944-bf29-f552bfa2e048\": \"ACS FIDO Authenticator\",\n\t\"516d3969-5a57-5651-5958-4e7a49434167\": \"SmartDisplayer BobeePass FIDO2 Authenticator\",\n\t\"531126d6-e717-415c-9320-3d9aa6981239\": \"Dashlane\",\n\t\"53414d53-554e-4700-0000-000000000000\": \"Samsung Pass\",\n\t\"5343502d-5343-5343-6172-644649444f32\": \"ESS Smart Card Inc. Authenticator\",\n\t\"54d9fee8-e621-4291-8b18-7157b99c5bec\": \"HID Crescendo Enabled\",\n\t\"5626bed4-e756-430b-a7ff-ca78c8b12738\": \"VALMIDO PRO FIDO\",\n\t\"58b44d0b-0a7c-f33a-fd48-f7153c871352\": \"Ledger Nano S Plus FIDO2 Authenticator\",\n\t\"5ca1ab1e-1337-fa57-f1d0-a117e71ca702\": \"Allthenticator App: roaming BLE FIDO2 Allthenticator for Windows, Mac, Linux, and Allthenticate door readers\",\n\t\"5d629218-d3a5-11ed-afa1-0242ac120002\": \"Swissbit iShield Key Pro\",\n\t\"5fdb81b8-53f0-4967-a881-f5ec26fe4d18\": \"VinCSS FIDO2 Authenticator\",\n\t\"6002f033-3c07-ce3e-d0f7-0ffe5ed42543\": \"Excelsecu eSecu FIDO2 Fingerprint Key\",\n\t\"6028b017-b1d4-4c02-b4b3-afcdafc96bb2\": \"Windows Hello\",\n\t\"61250591-b2bc-4456-b719-0b17be90bb30\": \"eWBM eFPA FIDO2 Authenticator\",\n\t\"664d9f67-84a2-412a-9ff7-b4f7d8ee6d05\": \"OpenSK authenticator\",\n\t\"66a0ccb3-bd6a-191f-ee06-e375c50b9846\": \"Thales Bio iOS SDK\",\n\t\"692db549-7ae5-44d5-a1e5-dd20a493b723\": \"HID Crescendo Key\",\n\t\"69700f79-d1fb-472e-bd9b-a3a3b9a9eda0\": \"Pone Biometrics OFFPAD Authenticator\",\n\t\"6d44ba9b-f6ec-2e49-b930-0c8fe920cb73\": \"Security Key by Yubico with NFC\",\n\t\"73402251-f2a8-4f03-873e-3cb6db604b03\": \"uTrust FIDO2 Security Key\",\n\t\"73bb0cd4-e502-49b8-9c6f-b59445bf720b\": \"YubiKey 5 FIPS Series\",\n\t\"74820b05-a6c9-40f9-8fb0-9f86aca93998\": \"SafeNet eToken Fusion\",\n\t\"77010bd7-212a-4fc9-b236-d2ca5e9d4084\": \"Feitian BioPass FIDO2 Authenticator\",\n\t\"771b48fd-d3d4-4f74-9232-fc157ab0507a\": \"Edge on Mac\",\n\t\"7e3f3d30-3557-4442-bdae-139312178b39\": \"RSA DS100\",\n\t\"820d89ed-d65a-409e-85cb-f73f0578f82a\": \"IDmelon iOS Authenticator\",\n\t\"833b721a-ff5f-4d00-bb2e-bdda3ec01e29\": \"Feitian ePass FIDO2 Authenticator\",\n\t\"83c47309-aabb-4108-8470-8be838b573cb\": \"YubiKey Bio Series (Enterprise Profile)\",\n\t\"85203421-48f9-4355-9bc8-8a53846e5083\": \"YubiKey 5 FIPS Series with Lightning\",\n\t\"87dbc5a1-4c94-4dc8-8a47-97d800fd1f3c\": \"eWBM eFA320 FIDO2 Authenticator\",\n\t\"8836336a-f590-0921-301d-46427531eee6\": \"Thales Bio Android SDK\",\n\t\"8876631b-d4a0-427f-5773-0ec71c9e0279\": \"Solo Secp256R1 FIDO2 CTAP2 Authenticator\",\n\t\"88bbd2f0-342a-42e7-9729-dd158be5407a\": \"Precision InnaIT Key FIDO 2 Level 2 certified\",\n\t\"8976631b-d4a0-427f-5773-0ec71c9e0279\": \"Solo Tap Secp256R1 FIDO2 CTAP2 Authenticator\",\n\t\"89b19028-256b-4025-8872-255358d950e4\": \"Sentry Enterprises CTAP2 Authenticator\",\n\t\"8c97a730-3f7b-41a6-87d6-1e9b62bda6f0\": \"FT-JCOS FIDO Fingerprint Card\",\n\t\"8d1b1fcb-3c76-49a9-9129-5515b346aa02\": \"IDEMIA ID-ONE Card\",\n\t\"91ad6b93-264b-4987-8737-3a690cad6917\": \"Token Ring FIDO2 Authenticator\",\n\t\"931327dd-c89b-406c-a81e-ed7058ef36c6\": \"Swissbit iShield Key FIDO2\",\n\t\"95442b2e-f15e-4def-b270-efb106facb4e\": \"eWBM eFA310 FIDO2 Authenticator\",\n\t\"95e4d58c-056e-4a65-866d-f5a69659e880\": \"TruU Windows Authenticator\",\n\t\"973446ca-e21c-9a9b-99f5-9b985a67af0f\": \"ACS FIDO Authenticator Card\",\n\t\"9876631b-d4a0-427f-5773-0ec71c9e0279\": \"Somu Secp256R1 FIDO2 CTAP2 Authenticator\",\n\t\"998f358b-2dd2-4cbe-a43a-e8107438dfb3\": \"OnlyKey Secp256R1 FIDO2 CTAP2 Authenticator\",\n\t\"99bf4610-ec26-4252-b31f-7380ccd59db5\": \"ZTPass Card\",\n\t\"9c835346-796b-4c27-8898-d6032f515cc5\": \"Cryptnox FIDO2\",\n\t\"9d3df6ba-282f-11ed-a261-0242ac120002\": \"Arculus FIDO2/U2F Key Card\",\n\t\"9ddd1817-af5a-4672-a2b9-3e3dd95000a9\": \"Windows Hello\",\n\t\"9f0d8150-baa5-4c00-9299-ad62c8bb4e87\": \"GoTrust Idem Card FIDO2 Authenticator\",\n\t\"9f77e279-a6e2-4d58-b700-31e5943c6a98\": \"Hyper FIDO Pro\",\n\t\"a1f52be5-dfab-4364-b51c-2bd496b14a56\": \"OCTATCO EzFinger2 FIDO2 AUTHENTICATOR\",\n\t\"a3975549-b191-fd67-b8fb-017e2917fdb3\": \"Excelsecu eSecu FIDO2 NFC Security Key\",\n\t\"a4e9fc6d-4cbe-4758-b8ba-37598bb5bbaa\": \"Security Key NFC by Yubico\",\n\t\"ab32f0c6-2239-afbb-c470-d2ef4e254db6\": \"TEST (DUMMY RECORD)\",\n\t\"ab32f0c6-2239-afbb-c470-d2ef4e254db7\": \"TOKEN2 FIDO2 Security Key\",\n\t\"adce0002-35bc-c60a-648b-0b25f1f05503\": \"Chrome on Mac\",\n\t\"aeb6569c-f8fb-4950-ac60-24ca2bbe2e52\": \"HID Crescendo C2300\",\n\t\"b267239b-954f-4041-a01b-ee4f33c145b6\": \"authenton1 - CTAP2.1\",\n\t\"b50d5e0a-7f81-4959-9b12-f45407407503\": \"IDPrime 3940 FIDO\",\n\t\"b5397666-4885-aa6b-cebf-e52262a439a2\": \"Chromium Browser\",\n\t\"b6ede29c-3772-412c-8a78-539c1f4c62d2\": \"Feitian BioPass FIDO2 Plus Authenticator\",\n\t\"b84e4048-15dc-4dd0-8640-f4f60813c8af\": \"NordPass\",\n\t\"b92c3f9a-c014-4056-887f-140a2501163b\": \"Security Key by Yubico\",\n\t\"b93fd961-f2e6-462f-b122-82002247de78\": \"Android Authenticator with SafetyNet Attestation\",\n\t\"ba76a271-6eb6-4171-874d-b6428dbe3437\": \"ATKey.ProS\",\n\t\"ba86dc56-635f-4141-aef6-00227b1b9af6\": \"TruU Windows Authenticator\",\n\t\"bada5566-a7aa-401f-bd96-45619a55120d\": \"1Password\",\n\t\"bbf4b6a7-679d-f6fc-c4f2-8ac0ddf9015a\": \"Excelsecu eSecu FIDO2 PRO Security Key\",\n\t\"bc2fe499-0d8e-4ffe-96f3-94a82840cf8c\": \"OCTATCO EzQuant FIDO2 AUTHENTICATOR\",\n\t\"be727034-574a-f799-5c76-0929e0430973\": \"Crayonic KeyVault K1 (USB-NFC-BLE FIDO2 Authenticator)\",\n\t\"c1f9a0bc-1dd2-404a-b27f-8e29047a43fd\": \"YubiKey 5 FIPS Series with NFC\",\n\t\"c5703116-972b-4851-a3e7-ae1259843399\": \"NEOWAVE Badgeo FIDO2\",\n\t\"c5ef55ff-ad9a-4b9f-b580-adebafe026d0\": \"YubiKey 5 Series with Lightning\",\n\t\"c80dbd9a-533f-4a17-b941-1a2f1c7cedff\": \"HID Crescendo C3000\",\n\t\"ca4cff1b-5a81-4404-8194-59aabcf1660b\": \"IDPrime 3930 FIDO\",\n\t\"ca87cb70-4c1b-4579-a8e8-4efdd7c007e0\": \"FIDO Alliance TruU Sample FIDO2 Authenticator\",\n\t\"cb69481e-8ff7-4039-93ec-0a2729a154a8\": \"YubiKey 5 Series\",\n\t\"cd69adb5-3c7a-deb9-3177-6800ea6cb72a\": \"Thales PIN Android SDK\",\n\t\"cdbdaea2-c415-5073-50f7-c04e968640b6\": \"Excelsecu eSecu FIDO2 Security Key\",\n\t\"cfcb13a2-244f-4b36-9077-82b79d6a7de7\": \"USB/NFC Passcode Authenticator\",\n\t\"d384db22-4d50-ebde-2eac-5765cf1e2a44\": \"Excelsecu eSecu FIDO2 Fingerprint Security Key\",\n\t\"d41f5a69-b817-4144-a13c-9ebd6d9254d6\": \"ATKey.Card CTAP2.0\",\n\t\"d548826e-79b4-db40-a3d8-11116f7e8349\": \"Bitwarden\",\n\t\"d61d3b87-3e7c-4aea-9c50-441c371903ad\": \"KeyVault Secp256R1 FIDO2 CTAP2 Authenticator\",\n\t\"d7a423ad-3e19-4492-9200-78137dccc136\": \"VivoKey Apex FIDO2\",\n\t\"d821a7d4-e97c-4cb6-bd82-4237731fd4be\": \"Hyper FIDO Bio Security Key\",\n\t\"d8522d9f-575b-4866-88a9-ba99fa02f35b\": \"YubiKey Bio Series\",\n\t\"d91c5288-0ef0-49b7-b8ae-21ca0aa6b3f3\": \"KEY-ID FIDO2 Authenticator\",\n\t\"d94a29d9-52dd-4247-9c2d-8b818b610389\": \"VeriMark Guard Fingerprint Key\",\n\t\"da1fa263-8b25-42b6-a820-c0036f21ba7f\": \"ATKey.Card NFC\",\n\t\"dd4ec289-e01d-41c9-bb89-70fa845d4bf2\": \"iCloud Keychain (Managed)\",\n\t\"e1a96183-5016-4f24-b55b-e3ae23614cc6\": \"ATKey.Pro CTAP2.0\",\n\t\"e416201b-afeb-41ca-a03d-2281c28322aa\": \"ATKey.Pro CTAP2.1\",\n\t\"e86addcd-7711-47e5-b42a-c18257b0bf61\": \"IDCore 3121 Fido\",\n\t\"ea9b8d66-4d01-1d21-3ce4-b6b48cb575d4\": \"Google Password Manager\",\n\t\"eabb46cc-e241-80bf-ae9e-96fa6d2975cf\": \"TOKEN2 PIN Plus Security Key Series \",\n\t\"eb3b131e-59dc-536a-d176-cb7306da10f5\": \"ellipticSecure MIRkey USB Authenticator\",\n\t\"ec31b4cc-2acc-4b8e-9c01-bade00ccbe26\": \"KeyXentic FIDO2 Secp256R1 FIDO2 CTAP2 Authenticator\",\n\t\"ee041bce-25e5-4cdb-8f86-897fd6418464\": \"Feitian ePass FIDO2-NFC Authenticator\",\n\t\"ee882879-721c-4913-9775-3dfcce97072a\": \"YubiKey 5 Series\",\n\t\"efb96b10-a9ee-4b6c-a4a9-d32125ccd4a4\": \"Safenet eToken FIDO\",\n\t\"f3809540-7f14-49c1-a8b3-8f813b225541\": \"Enpass\",\n\t\"f4c63eff-d26c-4248-801c-3736c7eaa93a\": \"FIDO KeyPass S3\",\n\t\"f7c558a0-f465-11e8-b568-0800200c9a66\": \"KONAI Secp256R1 FIDO2 Conformance Testing CTAP2 Authenticator\",\n\t\"f8a011f3-8c0a-4d15-8006-17111f9edc7d\": \"Security Key by Yubico\",\n\t\"fa2b99dc-9e39-4257-8f92-4a30d23c4118\": \"YubiKey 5 Series with NFC\",\n\t\"fbefdf68-fe86-0106-213e-4d5fa24cbe2e\": \"Excelsecu eSecu FIDO2 NFC Security Key\",\n\t\"fbfc3007-154e-4ecc-8c0b-6e020557d7bd\": \"iCloud Keychain\",\n\t\"fcb1bcb4-f370-078c-6993-bc24d0ae3fbe\": \"Ledger Nano X FIDO2 Authenticator\",\n\t\"fec067a1-f1d0-4c5e-b4c0-cc3237475461\": \"KX701 SmartToken FIDO\",\n}", "import { authenticatorMetadata } from './authenticatorMetadata.js'\nimport * as utils from './utils.js'\n\n\nexport function parseAuthBuffer(authData :ArrayBuffer) {\n    //console.debug(authData)\n    let flags = new DataView(authData.slice(32,33)).getUint8(0)\n    //console.debug(flags)\n\n    // https://w3c.github.io/webauthn/#sctn-authenticator-data\n    let parsed :any = {\n        rpIdHash: utils.toBase64url(authData.slice(0,32)),\n        flags: {\n                userPresent: !!(flags & 1),\n                //reserved1: !!(flags & 2),\n                userVerified: !!(flags &  4),\n                backupEligibility: !!(flags & 8),\n                backupState: !!(flags & 16),\n                //reserved2: !!(flags & 32),\n                attestedData: !!(flags & 64),\n                extensionsIncluded: !!(flags & 128)\n        },\n        counter: new DataView(authData.slice(33,37)).getUint32(0, false),  // Big-Endian!\n    }\n\n    // this is more descriptive than \"backupState\"\n    parsed.synced = parsed.flags.backupState\n\n    if(authData.byteLength > 37) {\n        // registration contains additional data\n\n        const aaguid = extractAaguid(authData) // bytes 37->53\n        // https://w3c.github.io/webauthn/#attested-credential-data\n        parsed = {\n            ...parsed,\n            aaguid,\n            name: authenticatorMetadata[aaguid] ?? 'Unknown',\n            icon_light: 'https://webauthn.passwordless.id/authenticators/' + aaguid + '-light.png',\n            icon_dark: 'https://webauthn.passwordless.id/authenticators/' + aaguid + '-dark.png',\n        }\n    }\n\n    return parsed\n}\n\nexport function extractAaguid(authData :ArrayBuffer) :string {\n    return formatAaguid(authData.slice(37, 53)) // 16 bytes\n}\n\nfunction formatAaguid(buffer :ArrayBuffer) :string {\n    let aaguid = utils.bufferToHex(buffer)\n    aaguid = aaguid.substring(0,8) + '-' + aaguid.substring(8,12) + '-' + aaguid.substring(12,16) + '-' + aaguid.substring(16,20) + '-' + aaguid.substring(20,32)\n    return aaguid // example: \"d41f5a69-b817-4144-a13c-9ebd6d9254d6\"\n}\n\n\n\n\n/**\n * Kept for compatibility purposes.\n * @deprecated\n */\nexport function resolveAuthenticatorName(aaguid :string) :string {\n    const aaguidMetadata = updatedAuthenticatorMetadata ?? authenticatorMetadata //await getAaguidMetadata()\n    return aaguidMetadata[aaguid]\n}\n\nlet updatedAuthenticatorMetadata :any = null\n\n/**\n * Updates the built-in metadata according to raw data available at https://mds.fidoalliance.org/\n * This service delivers a list of AAGUIDs encoded as a JWT.\n * Kept for compatibility purposes.\n * @deprecated\n */\nexport async function updateDevicesMetadata() {\n    // this function is rather resource intensive and time consuming\n    // therefore, the result is cached in local storage\n    const jwt = await (await fetch(\"https://mds.fidoalliance.org\")).text()\n\n    // the response is a JWT including all AAGUIDs and their metadata\n    console.debug(jwt)\n\n    // let us ignore the JWT verification, since this is solely for descriptive purposes, not signed data\n    const payload = jwt.split('.')[1].replaceAll('-', '+').replaceAll('_', '/')\n    const json = JSON.parse(atob(payload))\n    console.debug(json)\n\n    let aaguidMetadata :any = {}\n    for(const e of json.entries) {\n        if(!e.aaguid || !e.metadataStatement)\n            continue\n\n        aaguidMetadata[e.aaguid] = e.metadataStatement.description\n    }\n\n    console.debug(aaguidMetadata)\n    updatedAuthenticatorMetadata = aaguidMetadata\n}\n", "/*\nexport * from './types'\nexport * from './webauthn'\nexport * from './parsers'\nexport * from './validation'\n*/\nimport * as client from './client.js';\nimport * as server from './server.js';\nimport * as parsers from './parsers.js';\nimport * as utils from './utils.js';\nimport { authenticatorMetadata } from './authenticatorMetadata.js'\n\nexport { client, server, parsers, utils, authenticatorMetadata }\nexport default { client, server, parsers, utils, authenticatorMetadata }\n", "import { client } from \"@passwordless-id/webauthn\";\nimport type { ThirdwebClient } from \"../../../../../client/client.js\";\nimport { webLocalStorage } from \"../../../../../utils/storage/webStorage.js\";\nimport {\n  base64ToString,\n  base64UrlToBase64,\n} from \"../../../../../utils/uint8-array.js\";\nimport type { EcosystemWalletId } from \"../../../../wallet-types.js\";\nimport { ClientScopedStorage } from \"../../../core/authentication/client-scoped-storage.js\";\nimport type {\n  AuthenticateResult,\n  PasskeyClient,\n  RegisterResult,\n  RpInfo,\n} from \"../../../core/authentication/passkeys.js\";\n\nexport class PasskeyWebClient implements PasskeyClient {\n  isAvailable(): boolean {\n    return client.isAvailable();\n  }\n\n  async register(args: {\n    name: string;\n    challenge: string;\n    rp: RpInfo;\n  }): Promise<RegisterResult> {\n    const { name, challenge, rp } = args;\n    const registration = await client.register(name, challenge, {\n      authenticatorType: \"auto\",\n      userVerification: \"required\",\n      domain: rp.id,\n      attestation: true,\n      debug: false,\n    });\n    const clientDataB64 = base64UrlToBase64(registration.clientData);\n    const clientDataParsed = JSON.parse(base64ToString(clientDataB64));\n    return {\n      authenticatorData: registration.authenticatorData,\n      credentialId: registration.credential.id,\n      clientData: registration.clientData,\n      credential: {\n        publicKey: registration.credential.publicKey,\n        algorithm: registration.credential.algorithm,\n      },\n      origin: clientDataParsed.origin,\n    };\n  }\n\n  async authenticate(args: {\n    credentialId: string | undefined;\n    challenge: string;\n    rp: RpInfo;\n  }): Promise<AuthenticateResult> {\n    const { credentialId, challenge, rp } = args;\n    const result = await client.authenticate(\n      credentialId ? [credentialId] : [],\n      challenge,\n      {\n        authenticatorType: \"auto\",\n        userVerification: \"required\",\n        domain: rp.id,\n      },\n    );\n    const clientDataB64 = base64UrlToBase64(result.clientData);\n    const clientDataParsed = JSON.parse(base64ToString(clientDataB64));\n    return {\n      authenticatorData: result.authenticatorData,\n      credentialId: result.credentialId,\n      clientData: result.clientData,\n      signature: result.signature,\n      origin: clientDataParsed.origin,\n    };\n  }\n}\n\n/**\n * Returns whether this device has a stored passkey ready to be used for sign-in\n * @param client - the thirdweb client\n * @returns whether the device has a stored passkey\n * @walletUtils\n */\nexport async function hasStoredPasskey(\n  client: ThirdwebClient,\n  ecosystemId?: EcosystemWalletId,\n) {\n  const storage = new ClientScopedStorage({\n    storage: webLocalStorage, // TODO (passkey) react native variant of this fn\n    clientId: client.clientId,\n    ecosystem: ecosystemId ? { id: ecosystemId } : undefined,\n  });\n  const credId = await storage.getPasskeyCredentialId();\n  return !!credId;\n}\n"],
  "mappings": "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",
  "names": ["client_exports", "__export", "authenticate", "isAvailable", "isLocalAuthenticator", "register", "utils_exports", "bufferToHex", "concatenateBuffers", "isBase64url", "parseBase64url", "parseBuffer", "randomChallenge", "sha256", "toBase64url", "toBuffer", "txt", "c", "buffer", "b", "buffer1", "buffer2", "tmp", "getAuthAttachment", "authType", "getAlgoName", "num", "username", "challenge", "options", "creationOptions", "credential", "response", "registration", "getTransports", "local", "roaming", "credentialIds", "transports", "authOptions", "id", "auth", "server_exports", "verifyAuthentication", "verifyRegistration", "verifySignature", "parsers_exports", "parseAttestation", "parseAuthentication", "parseAuthenticator", "parseClient", "parseRegistration", "authenticatorMetadata", "parseAuthBuffer", "authData", "flags", "parsed", "aaguid", "extractAaguid", "formatAaguid", "utf8Decoder", "data", "authentication", "isValid", "validator", "value", "res", "isNotValid", "registrationRaw", "expected", "authenticationRaw", "rpId", "expectedRpIdHash", "getAlgoParams", "algorithm", "parseCryptoKey", "algoParams", "publicKey", "authenticatorData", "clientData", "signature", "verbose", "cryptoKey", "clientHash", "comboBuffer", "signatureBuffer", "convertASN1toRaw", "usignature", "rStart", "rEnd", "sStart", "r", "s"]
}
