{
  "version": 3,
  "sources": ["../../node_modules/thirdweb/src/wallets/utils/chains.ts", "../../node_modules/thirdweb/src/wallets/utils/normalizeChainId.ts"],
  "sourcesContent": ["import type { ChainMetadata } from \"../../chains/types.js\";\n\n// TODO - move this to chains subfolder\n\n/**\n * Remove client id from RPC url for given chain\n * @internal\n */\nexport function getValidPublicRPCUrl(chain: ChainMetadata) {\n  return getValidChainRPCs(chain).map((rpc) => {\n    try {\n      const url = new URL(rpc);\n      // remove client id from url\n      if (url.hostname.endsWith(\".thirdweb.com\")) {\n        url.pathname = \"\";\n        url.search = \"\";\n      }\n      return url.toString();\n    } catch {\n      return rpc;\n    }\n  });\n}\n\n// TODO - move this to chains/\n/**\n * Get valid RPCs for given chain\n * @internal\n */\nfunction getValidChainRPCs(\n  chain: Pick<ChainMetadata, \"rpc\" | \"chainId\">,\n  clientId?: string,\n  mode: \"http\" | \"ws\" = \"http\",\n): string[] {\n  const processedRPCs: string[] = [];\n\n  for (const rpc of chain.rpc) {\n    // exclude RPC if mode mismatch\n    if (mode === \"http\" && !rpc.startsWith(\"http\")) {\n      continue;\n    }\n\n    if (mode === \"ws\" && !rpc.startsWith(\"ws\")) {\n      continue;\n    }\n\n    // Replace API_KEY placeholder with value\n    if (rpc.includes(\"${THIRDWEB_API_KEY}\")) {\n      if (clientId) {\n        processedRPCs.push(\n          rpc.replace(\"${THIRDWEB_API_KEY}\", clientId) +\n            (typeof globalThis !== \"undefined\" && \"APP_BUNDLE_ID\" in globalThis\n              ? // @ts-expect-error\n                `/?bundleId=${globalThis.APP_BUNDLE_ID}`\n              : \"\"),\n        );\n      } else {\n        // if no client id, let it through with empty string\n        // if secretKey is present, it will be used in header\n        // if none are passed, will have reduced access\n        processedRPCs.push(rpc.replace(\"${THIRDWEB_API_KEY}\", \"\"));\n      }\n    }\n\n    // exclude RPCs with unknown placeholder\n    else if (rpc.includes(\"${\")) {\n      // do nothing (just don't add it to the list)\n    }\n\n    // add as is\n    else {\n      processedRPCs.push(rpc);\n    }\n  }\n\n  if (processedRPCs.length === 0) {\n    throw new Error(\n      `No RPC available for chainId \"${chain.chainId}\" with mode ${mode}`,\n    );\n  }\n\n  return processedRPCs;\n}\n", "import { hexToNumber, isHex } from \"../../utils/encoding/hex.js\";\n\n/**\n * @internal\n */\nexport function normalizeChainId(chainId: string | number | bigint): number {\n  if (typeof chainId === \"number\") {\n    return chainId;\n  }\n  if (isHex(chainId)) {\n    return hexToNumber(chainId);\n  }\n  if (typeof chainId === \"bigint\") {\n    return Number(chainId);\n  }\n  return Number.parseInt(chainId, 10);\n}\n"],
  "mappings": ";;;;;;AAQM,SAAU,qBAAqB,OAAoB;AACvD,SAAO,kBAAkB,KAAK,EAAE,IAAI,CAAC,QAAO;AAC1C,QAAI;AACF,YAAM,MAAM,IAAI,IAAI,GAAG;AAEvB,UAAI,IAAI,SAAS,SAAS,eAAe,GAAG;AAC1C,YAAI,WAAW;AACf,YAAI,SAAS;MACf;AACA,aAAO,IAAI,SAAQ;IACrB,QAAQ;AACN,aAAO;IACT;EACF,CAAC;AACH;AAOA,SAAS,kBACP,OACA,UACA,OAAsB,QAAM;AAE5B,QAAM,gBAA0B,CAAA;AAEhC,aAAW,OAAO,MAAM,KAAK;AAE3B,QAAI,SAAS,UAAU,CAAC,IAAI,WAAW,MAAM,GAAG;AAC9C;IACF;AAEA,QAAI,SAAS,QAAQ,CAAC,IAAI,WAAW,IAAI,GAAG;AAC1C;IACF;AAGA,QAAI,IAAI,SAAS,qBAAqB,GAAG;AACvC,UAAI,UAAU;AACZ,sBAAc,KACZ,IAAI,QAAQ,uBAAuB,QAAQ,KACxC,OAAO,eAAe,eAAe,mBAAmB;;UAErD,cAAc,WAAW,aAAa;YACtC,GAAG;MAEb,OAAO;AAIL,sBAAc,KAAK,IAAI,QAAQ,uBAAuB,EAAE,CAAC;MAC3D;IACF,WAGS,IAAI,SAAS,IAAI,GAAG;IAE7B,OAGK;AACH,oBAAc,KAAK,GAAG;IACxB;EACF;AAEA,MAAI,cAAc,WAAW,GAAG;AAC9B,UAAM,IAAI,MACR,iCAAiC,MAAM,OAAO,eAAe,IAAI,EAAE;EAEvE;AAEA,SAAO;AACT;;;AC7EM,SAAU,iBAAiB,SAAiC;AAChE,MAAI,OAAO,YAAY,UAAU;AAC/B,WAAO;EACT;AACA,MAAI,MAAM,OAAO,GAAG;AAClB,WAAO,YAAY,OAAO;EAC5B;AACA,MAAI,OAAO,YAAY,UAAU;AAC/B,WAAO,OAAO,OAAO;EACvB;AACA,SAAO,OAAO,SAAS,SAAS,EAAE;AACpC;",
  "names": []
}
