{
  "version": 3,
  "sources": ["../../node_modules/thirdweb/src/extensions/erc1271/checkContractWalletSignedTypedData.ts"],
  "sourcesContent": ["import { type TypedData, type TypedDataDefinition, hashTypedData } from \"viem\";\nimport type { ThirdwebContract } from \"../../contract/contract.js\";\nimport { isHex } from \"../../utils/encoding/hex.js\";\nimport { isValidSignature } from \"./__generated__/isValidSignature/read/isValidSignature.js\";\n\n/**\n * @extension ERC1271\n */\nexport type CheckContractWalletSignTypedDataOptions<\n  typedData extends TypedData | Record<string, unknown>,\n  primaryType extends keyof typedData | \"EIP712Domain\" = keyof typedData,\n> = {\n  contract: ThirdwebContract;\n  data: TypedDataDefinition<typedData, primaryType>;\n  signature: string;\n};\nconst MAGIC_VALUE = \"0x1626ba7e\";\n\n/**\n * Checks if a contract wallet signature is valid.\n * @deprecated Use `verifyTypedData` instead\n * @param options - The options for the checkContractWalletSignature function.\n * @param options.contract - The contract to check the signature against.\n * @param options.message - The message to check the signature against.\n * @param options.signature - The signature to check.\n * @extension ERC1271\n * @example\n * ```ts\n * import { checkContractWalletSignedTypedData } from \"thirdweb/extensions/erc1271\";\n * const isValid = await checkContractWalletSignedTypedData({\n *  contract: myContract,\n *  data: {\n *   primaryType: \"EIP712Domain\",\n *   domain: {\n *     name: \"Example\",\n *     version: \"1\",\n *     chainId: 1,\n *     verifyingContract: myContract.address,\n *   },\n * });\n * ```\n * @returns A promise that resolves with a boolean indicating if the signature is valid.\n */\nexport async function checkContractWalletSignedTypedData<\n  typedData extends TypedData | Record<string, unknown>,\n  primaryType extends keyof typedData | \"EIP712Domain\" = keyof typedData,\n>(options: CheckContractWalletSignTypedDataOptions<typedData, primaryType>) {\n  if (!isHex(options.signature)) {\n    throw new Error(\"The signature must be a valid hex string.\");\n  }\n  const result = await isValidSignature({\n    contract: options.contract,\n    hash: hashTypedData(options.data),\n    signature: options.signature,\n  });\n  return result === MAGIC_VALUE;\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAgBA,IAAM,cAAc;AA2BpB,eAAsB,mCAGpB,SAAwE;AACxE,MAAI,CAAC,MAAM,QAAQ,SAAS,GAAG;AAC7B,UAAM,IAAI,MAAM,2CAA2C;EAC7D;AACA,QAAM,SAAS,MAAM,iBAAiB;IACpC,UAAU,QAAQ;IAClB,MAAM,cAAc,QAAQ,IAAI;IAChC,WAAW,QAAQ;GACpB;AACD,SAAO,WAAW;AACpB;",
  "names": []
}
