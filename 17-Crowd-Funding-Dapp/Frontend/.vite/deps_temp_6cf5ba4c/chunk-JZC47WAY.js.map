{
  "version": 3,
  "sources": ["../../node_modules/thirdweb/src/rpc/actions/eth_gasPrice.ts", "../../node_modules/thirdweb/src/rpc/actions/eth_maxPriorityFeePerGas.ts", "../../node_modules/thirdweb/src/gas/op-gas-fee-reducer.ts", "../../node_modules/thirdweb/src/contract/actions/resolve-abi.ts", "../../node_modules/thirdweb/src/transaction/extract-error.ts", "../../node_modules/thirdweb/src/transaction/actions/estimate-gas.ts", "../../node_modules/thirdweb/src/gas/get-gas-price.ts", "../../node_modules/thirdweb/src/gas/fee-data.ts", "../../node_modules/thirdweb/src/transaction/actions/to-serializable-transaction.ts"],
  "sourcesContent": ["import type { EIP1193RequestFn, EIP1474Methods } from \"viem\";\nimport { hexToBigInt } from \"../../utils/encoding/hex.js\";\n\n/**\n * Retrieves the current gas price from the Ethereum network.\n * @param request - The EIP1193 request function.\n * @returns A promise that resolves to the gas price as a bigint.\n * @rpc\n * @example\n * ```ts\n * import { getRpcClient, eth_gasPrice } from \"thirdweb/rpc\";\n * const rpcRequest = getRpcClient({ client, chain });\n * const gasPrice = await eth_gasPrice(rpcRequest);\n * ```\n */\nexport async function eth_gasPrice(\n  request: EIP1193RequestFn<EIP1474Methods>,\n): Promise<bigint> {\n  const result = await request({\n    method: \"eth_gasPrice\",\n  });\n  return hexToBigInt(result);\n}\n", "import type { EIP1193RequestFn, EIP1474Methods } from \"viem\";\nimport { hexToBigInt } from \"../../utils/encoding/hex.js\";\n\n/**\n * Retrieves the maximum priority fee per gas from the Ethereum network.\n * @param request - The EIP1193 request function.\n * @returns A promise that resolves to a bigint representing the maximum priority fee per gas.\n * @rpc\n * @example\n * ```ts\n * import { getRpcClient, eth_maxPriorityFeePerGas } from \"thirdweb/rpc\";\n * const rpcRequest = getRpcClient({ client, chain });\n * const maxPriorityFeePerGas = await eth_maxPriorityFeePerGas(rpcRequest);\n * ```\n */\nexport async function eth_maxPriorityFeePerGas(\n  request: EIP1193RequestFn<EIP1474Methods>,\n): Promise<bigint> {\n  const result = await request({\n    method: \"eth_maxPriorityFeePerGas\",\n  });\n  return hexToBigInt(result);\n}\n", "/**\n * Via: https://twitter.com/0xjustadev/status/1758973668011434062\n *\n * Increases the gas fee value to the nearest power of 2.\n * If the value is already a power of 2 or 0, it returns the value as is.\n * Otherwise, it finds the highest power of 2 that is bigger than the given value.\n * @param value - The gas fee value to be \"rounded up\".\n * @returns The *increased* gas value which will result in a lower L1 gas fee, overall reducing the gas fee.\n * @internal\n */\nexport function roundUpGas(value: bigint): bigint {\n  if (value === 0n || (value & (value - 1n)) === 0n) {\n    return value;\n  }\n\n  // Find the highest set bit by shifting until the value is 0.\n  let highestBit = 1n;\n  while (value > 0n) {\n    // biome-ignore lint/style/noParameterAssign: the whole point is that we modify the value in palce\n    value >>= 1n;\n    highestBit <<= 1n;\n  }\n\n  return highestBit;\n}\n", "import { type Abi, formatAbi, parseAbi } from \"abitype\";\nimport { download } from \"../../storage/download.js\";\nimport { getClientFetch } from \"../../utils/fetch.js\";\nimport type { ThirdwebContract } from \"../contract.js\";\n\nconst ABI_RESOLUTION_CACHE = new WeakMap<ThirdwebContract<Abi>, Promise<Abi>>();\n\n/**\n * Resolves the ABI (Application Binary Interface) for a given contract.\n * If the ABI is already cached, it returns the cached value.\n * Otherwise, it tries to resolve the ABI from the contract's API.\n * If that fails, it resolves the ABI from the contract's bytecode.\n * @param contract The contract for which to resolve the ABI.\n * @param contractApiBaseUrl The base URL of the contract API. Defaults to \"https://contract.thirdweb.com/abi\".\n * @returns A promise that resolves to the ABI of the contract.\n * @example\n * ```ts\n * import { createThirdwebClient, getContract } from \"thirdweb\";\n * import { resolveContractAbi } from \"thirdweb/contract\";\n * import { ethereum } from \"thirdweb/chains\";\n * const client = createThirdwebClient({ clientId: \"...\" });\n * const myContract = getContract({\n *  client,\n *  address: \"...\",\n *  chain: ethereum,\n * });\n * const abi = await resolveContractAbi(myContract);\n * ```\n * @contract\n */\nexport function resolveContractAbi<abi extends Abi>(\n  contract: ThirdwebContract<abi>,\n  contractApiBaseUrl = \"https://contract.thirdweb.com/abi\",\n): Promise<abi> {\n  if (ABI_RESOLUTION_CACHE.has(contract)) {\n    return ABI_RESOLUTION_CACHE.get(contract) as Promise<abi>;\n  }\n\n  const prom = (async () => {\n    // if the contract already HAS a user defined we always use that!\n    if (contract.abi) {\n      return contract.abi as abi;\n    }\n    // try to get it from the api\n    try {\n      return await resolveAbiFromContractApi(contract, contractApiBaseUrl);\n    } catch {\n      // if that fails, try to resolve it from the bytecode\n      return await resolveCompositeAbi(contract as ThirdwebContract);\n    }\n  })();\n  ABI_RESOLUTION_CACHE.set(contract, prom);\n  return prom as Promise<abi>;\n}\n\n/**\n * Resolves the ABI (Application Binary Interface) for a contract from the contract API.\n * @param contract The ThirdwebContract instance representing the contract.\n * @param contractApiBaseUrl The base URL of the contract API. Defaults to \"https://contract.thirdweb.com/abi\".\n * @returns A promise that resolves to the ABI of the contract.\n * @example\n * ```ts\n * import { createThirdwebClient, getContract } from \"thirdweb\";\n * import { resolveAbiFromContractApi } from \"thirdweb/contract\"\n * import { ethereum } from \"thirdweb/chains\";\n * const client = createThirdwebClient({ clientId: \"...\" });\n * const myContract = getContract({\n *  client,\n *  address: \"...\",\n *  chain: ethereum,\n * });\n * const abi = await resolveAbiFromContractApi(myContract);\n * ```\n * @contract\n */\nexport async function resolveAbiFromContractApi(\n  // biome-ignore lint/suspicious/noExplicitAny: library function that accepts any contract type\n  contract: ThirdwebContract<any>,\n  contractApiBaseUrl = \"https://contract.thirdweb.com/abi\",\n): Promise<Abi> {\n  const response = await getClientFetch(contract.client)(\n    `${contractApiBaseUrl}/${contract.chain.id}/${contract.address}`,\n  );\n  const json = await response.json();\n  if (!json || json.error) {\n    throw new Error(\n      `Failed to resolve ABI from contract API. ${json.error || \"\"}`,\n    );\n  }\n  return json;\n}\n\n/**\n * Resolves the ABI (Application Binary Interface) from the bytecode of a contract.\n * @param contract The ThirdwebContract instance.\n * @returns The resolved ABI as a generic type.\n * @throws Error if no IPFS URI is found in the bytecode.\n * @example\n * ```ts\n * import { createThirdwebClient, getContract } from \"thirdweb\";\n * import { resolveAbiFromBytecode } from \"thirdweb/contract\";\n * import { ethereum } from \"thirdweb/chains\";\n * const client = createThirdwebClient({ clientId: \"...\" });\n * const myContract = getContract({\n *  client,\n *  address: \"...\",\n *  chain: ethereum,\n * });\n * const abi = await resolveAbiFromBytecode(myContract);\n * ```\n * @contract\n */\nexport async function resolveAbiFromBytecode(\n  // biome-ignore lint/suspicious/noExplicitAny: library function that accepts any contract type\n  contract: ThirdwebContract<any>,\n): Promise<Abi> {\n  const [{ resolveImplementation }, { extractIPFSUri }] = await Promise.all([\n    import(\"../../utils/bytecode/resolveImplementation.js\"),\n    import(\"../../utils/bytecode/extractIPFS.js\"),\n  ]);\n  const { bytecode } = await resolveImplementation(contract);\n  if (bytecode === \"0x\") {\n    const { id, name } = contract.chain;\n    throw new Error(\n      `Failed to load contract bytecode. Make sure the contract [${\n        contract.address\n      }] exists on the chain [${name || \"Unknown Chain\"} (chain id: ${id})]`,\n    );\n  }\n  const ipfsUri = extractIPFSUri(bytecode);\n  if (!ipfsUri) {\n    // just early exit if we can't find an IPFS URI\n    return [];\n  }\n  try {\n    const res = await download({ uri: ipfsUri, client: contract.client });\n    const json = await res.json();\n    // ABI is at `json.output.abi`\n    return json.output.abi;\n  } catch {\n    // if we can't resolve the ABI from the IPFS URI, return an empty array\n    return [];\n  }\n}\n\nconst PLUGINS_ABI = {\n  inputs: [],\n  name: \"getAllPlugins\",\n  outputs: [\n    {\n      components: [\n        {\n          internalType: \"bytes4\",\n          name: \"functionSelector\",\n          type: \"bytes4\",\n        },\n        {\n          internalType: \"string\",\n          name: \"functionSignature\",\n          type: \"string\",\n        },\n        {\n          internalType: \"address\",\n          name: \"pluginAddress\",\n          type: \"address\",\n        },\n      ],\n      internalType: \"struct IPluginMap.Plugin[]\",\n      name: \"registered\",\n      type: \"tuple[]\",\n    },\n  ],\n  stateMutability: \"view\",\n  type: \"function\",\n} as const;\n\nconst BASE_ROUTER_ABI = {\n  inputs: [],\n  name: \"getAllExtensions\",\n  outputs: [\n    {\n      components: [\n        {\n          components: [\n            {\n              internalType: \"string\",\n              name: \"name\",\n              type: \"string\",\n            },\n            {\n              internalType: \"string\",\n              name: \"metadataURI\",\n              type: \"string\",\n            },\n            {\n              internalType: \"address\",\n              name: \"implementation\",\n              type: \"address\",\n            },\n          ],\n          internalType: \"struct IExtension.ExtensionMetadata\",\n          name: \"metadata\",\n          type: \"tuple\",\n        },\n        {\n          components: [\n            {\n              internalType: \"bytes4\",\n              name: \"functionSelector\",\n              type: \"bytes4\",\n            },\n            {\n              internalType: \"string\",\n              name: \"functionSignature\",\n              type: \"string\",\n            },\n          ],\n          internalType: \"struct IExtension.ExtensionFunction[]\",\n          name: \"functions\",\n          type: \"tuple[]\",\n        },\n      ],\n      internalType: \"struct IExtension.Extension[]\",\n      name: \"allExtensions\",\n      type: \"tuple[]\",\n    },\n  ],\n  stateMutability: \"view\",\n  type: \"function\",\n} as const;\n\nconst DIAMOND_ABI = {\n  inputs: [],\n  name: \"facets\",\n  outputs: [\n    {\n      components: [\n        {\n          internalType: \"address\",\n          name: \"facetAddress\",\n          type: \"address\",\n        },\n        {\n          internalType: \"bytes4[]\",\n          name: \"functionSelectors\",\n          type: \"bytes4[]\",\n        },\n      ],\n      type: \"tuple[]\",\n    },\n  ],\n  stateMutability: \"view\",\n  type: \"function\",\n} as const;\n\n/**\n * Resolves the ABI for a contract based on its bytecode.\n * If the contract follows the plugin-pattern or dynamic pattern, it resolves the ABIs for the plugins and merges them with the root ABI.\n * If the contract follows the base router pattern, it resolves the ABIs for the plugins and merges them with the root ABI.\n * If the contract follows the diamond pattern, it resolves the ABIs for the facets and merges them with the root ABI.\n * @param contract The contract for which to resolve the ABI.\n * @param rootAbi The root ABI to use for the contract. If not provided, it resolves the ABI from the contract's bytecode.\n * @param resolveSubAbi A function to resolve the ABI for a sub-contract. If not provided, it uses the default ABI resolution logic.\n * @returns The resolved ABI for the contract.\n * @example\n * ```ts\n * import { createThirdwebClient, getContract } from \"thirdweb\";\n * import { resolveCompositeAbiFromBytecode } from \"thirdweb/contract\";\n * import { ethereum } from \"thirdweb/chains\";\n * const client = createThirdwebClient({ clientId: \"...\" });\n * const myContract = getContract({\n *  client,\n *  address: \"...\",\n *  chain: ethereum,\n * });\n * const abi = await resolveCompositeAbiFromBytecode(myContract);\n * ```\n * @contract\n */\nexport async function resolveCompositeAbi(\n  contract: ThirdwebContract,\n  rootAbi?: Abi,\n  resolveSubAbi?: (contract: ThirdwebContract) => Promise<Abi>,\n) {\n  const [\n    rootAbi_,\n    pluginPatternAddresses,\n    baseRouterAddresses,\n    modularExtensionAddresses,\n    diamondFacetAddresses,\n  ] = await Promise.all([\n    rootAbi ? rootAbi : resolveAbiFromBytecode(contract),\n    // check these all at the same time\n    resolvePluginPatternAddresses(contract),\n    resolveBaseRouterAddresses(contract),\n    resolveModularModuleAddresses(contract),\n    resolveDiamondFacetAddresses(contract),\n  ]);\n\n  const mergedPlugins = [\n    ...new Set([\n      ...pluginPatternAddresses,\n      ...baseRouterAddresses,\n      ...modularExtensionAddresses,\n      ...diamondFacetAddresses,\n    ]),\n  ];\n\n  // no plugins\n  if (!mergedPlugins.length) {\n    return rootAbi_;\n  }\n  // get all the abis for the plugins\n  const pluginAbis = await getAbisForPlugins({\n    contract,\n    plugins: mergedPlugins,\n    resolveSubAbi,\n  });\n\n  // join them together\n  return joinAbis({ rootAbi: rootAbi_, pluginAbis });\n}\n\nasync function resolvePluginPatternAddresses(\n  contract: ThirdwebContract,\n): Promise<string[]> {\n  try {\n    const { readContract } = await import(\"../../transaction/read-contract.js\");\n    const pluginMap = await readContract({\n      contract,\n      method: PLUGINS_ABI,\n    });\n    // if there are no plugins, return the root ABI\n    if (!pluginMap.length) {\n      return [];\n    }\n    // get all the plugin addresses\n    return [...new Set(pluginMap.map((item) => item.pluginAddress))];\n  } catch {\n    // no-op, expected because not everything supports this\n  }\n  return [];\n}\n\nasync function resolveBaseRouterAddresses(\n  contract: ThirdwebContract,\n): Promise<string[]> {\n  try {\n    const { readContract } = await import(\"../../transaction/read-contract.js\");\n    const pluginMap = await readContract({\n      contract,\n      method: BASE_ROUTER_ABI,\n    });\n    // if there are no plugins, return the root ABI\n    if (!pluginMap.length) {\n      return [];\n    }\n    // get all the plugin addresses\n    return [...new Set(pluginMap.map((item) => item.metadata.implementation))];\n  } catch {\n    // no-op, expected because not everything supports this\n  }\n  return [];\n}\n\nasync function resolveModularModuleAddresses(\n  contract: ThirdwebContract,\n): Promise<string[]> {\n  try {\n    const { getInstalledModules } = await import(\n      \"../../extensions/modules/__generated__/IModularCore/read/getInstalledModules.js\"\n    );\n    const modules = await getInstalledModules({ contract });\n    // if there are no plugins, return the root ABI\n    if (!modules.length) {\n      return [];\n    }\n    // get all the plugin addresses\n    return [...new Set(modules.map((item) => item.implementation))];\n  } catch {\n    // no-op, expected because not everything supports this\n  }\n  return [];\n}\n\nasync function resolveDiamondFacetAddresses(\n  contract: ThirdwebContract,\n): Promise<string[]> {\n  try {\n    const { readContract } = await import(\"../../transaction/read-contract.js\");\n    const facets = await readContract({ contract, method: DIAMOND_ABI });\n    // if there are no facets, return the root ABI\n    if (!facets.length) {\n      return [];\n    }\n    // get all the plugin addresses\n    return facets.map((item) => item.facetAddress);\n  } catch {\n    // no-op, expected because not everything supports this\n  }\n  return [];\n}\n\ntype GetAbisForPluginsOptions = {\n  // biome-ignore lint/suspicious/noExplicitAny: library function that accepts any contract type\n  contract: ThirdwebContract<any>;\n  plugins: string[];\n  resolveSubAbi?: (contract: ThirdwebContract) => Promise<Abi>;\n};\n\nasync function getAbisForPlugins(\n  options: GetAbisForPluginsOptions,\n): Promise<Abi[]> {\n  return Promise.all(\n    options.plugins.map((pluginAddress) => {\n      const newContract = {\n        ...options.contract,\n        address: pluginAddress,\n      };\n      // if we have a method passed in that tells us how to resove the sub-api, use that\n      if (options.resolveSubAbi) {\n        return options.resolveSubAbi(newContract);\n      }\n      // otherwise default logic\n      return resolveAbiFromBytecode(newContract);\n    }),\n  );\n}\n\ntype JoinAbisOptions = {\n  pluginAbis: Abi[];\n  rootAbi?: Abi;\n};\n\nfunction joinAbis(options: JoinAbisOptions): Abi {\n  let mergedPlugins: Abi = options.pluginAbis\n    .flat()\n    .filter((item) => item.type !== \"constructor\");\n\n  if (options.rootAbi) {\n    mergedPlugins = [...options.rootAbi, ...mergedPlugins]\n      .filter((item) => item.type !== \"fallback\" && item.type !== \"receive\")\n      .filter(Boolean);\n  }\n\n  // unique by formatting every abi and then throwing them in a set\n  // TODO: this may not be super efficient...\n  const humanReadableAbi = [...new Set(formatAbi(mergedPlugins))];\n\n  // finally parse it back out\n  return parseAbi(humanReadableAbi);\n}\n", "import type { Abi } from \"abitype\";\nimport { type Hex, decodeErrorResult } from \"viem\";\nimport { resolveContractAbi } from \"../contract/actions/resolve-abi.js\";\nimport type { ThirdwebContract } from \"../contract/contract.js\";\nimport { isHex } from \"../utils/encoding/hex.js\";\nimport { stringify } from \"../utils/json.js\";\nimport { IS_DEV } from \"../utils/process.js\";\n\n/**\n * @internal\n */\nexport async function extractError<abi extends Abi>(args: {\n  error: unknown;\n  contract?: ThirdwebContract<abi>;\n}) {\n  const { error, contract } = args;\n  if (typeof error === \"object\") {\n    // try to parse RPC error\n    const errorObj = error as {\n      message?: string;\n      code?: number;\n      data?: Hex;\n    };\n    if (errorObj.data) {\n      if (errorObj.data !== \"0x\" && isHex(errorObj.data)) {\n        let abi = contract?.abi;\n        if (contract && !abi) {\n          abi = await resolveContractAbi(contract).catch(() => undefined);\n        }\n        const parsedError = decodeErrorResult({\n          data: errorObj.data,\n          abi,\n        });\n        return new TransactionError(\n          `${parsedError.errorName}${\n            parsedError.args ? ` - ${parsedError.args}` : \"\"\n          }`,\n          contract,\n        );\n      }\n      return new TransactionError(\n        `Execution Reverted: ${stringify(errorObj)}`,\n        contract,\n      );\n    }\n  }\n  return error;\n}\n\nclass TransactionError<abi extends Abi> extends Error {\n  public contractAddress: string | undefined;\n  public chainId: number | undefined;\n\n  constructor(reason: string, contract?: ThirdwebContract<abi>) {\n    let message = reason;\n    if (IS_DEV && contract) {\n      // show more infor in dev\n      message = [\n        reason,\n        \"\",\n        `contract: ${contract.address}`,\n        `chainId: ${contract.chain?.id}`,\n      ].join(\"\\n\");\n    }\n    super(message);\n    this.name = \"TransactionError\";\n    this.contractAddress = contract?.address;\n    this.chainId = contract?.chain?.id;\n    this.message = message;\n  }\n}\n", "import { formatTransactionRequest } from \"viem\";\nimport { roundUpGas } from \"../../gas/op-gas-fee-reducer.js\";\nimport { resolvePromisedValue } from \"../../utils/promise/resolve-promised-value.js\";\nimport type { Prettify } from \"../../utils/type-utils.js\";\nimport type { Account } from \"../../wallets/interfaces/wallet.js\";\nimport { extractError as parseEstimationError } from \"../extract-error.js\";\nimport type { PreparedTransaction } from \"../prepare-transaction.js\";\n\nexport type EstimateGasOptions = Prettify<\n  {\n    /**\n     * The prepared transaction to estimate the gas for.\n     */\n    // TODO: update this to `Transaction<\"prepared\">` once the type is available to ensure only prepared transactions are accepted\n    // biome-ignore lint/suspicious/noExplicitAny: library function that accepts any prepared transaction type\n    transaction: PreparedTransaction<any>;\n  } & (\n    | {\n        /**\n         * The account the transaction would be sent from.\n         */\n        account: Account;\n        from?: never;\n      }\n    | {\n        account?: never;\n        /**\n         * The address the transaction would be sent from.\n         */\n        from?: string;\n      }\n  )\n>;\n\nexport type EstimateGasResult = bigint;\n\nconst cache = new WeakMap<\n  PreparedTransaction & { from: string | undefined },\n  Promise<EstimateGasResult>\n>();\n\n/**\n * Estimates the gas required to execute a transaction. The gas is returned as a `bigint` and in gwei units.\n * @param options - The options for estimating gas.\n * @returns A promise that resolves to the estimated gas as a bigint.\n * @transaction\n * @example\n * ```ts\n * import { estimateGas } from \"thirdweb\";\n * const gas = await estimateGas({\n *  transaction,\n *  from: \"0x...\",\n * });\n * ```\n */\nexport async function estimateGas(\n  options: EstimateGasOptions,\n): Promise<EstimateGasResult> {\n  // from is:\n  // 1. the user specified from address\n  // 2. the passed in account address\n  // 3. the passed in wallet's account address\n  const from = options.from ?? options.account?.address ?? undefined;\n  const txWithFrom = { ...options.transaction, from };\n  if (cache.has(txWithFrom)) {\n    // biome-ignore lint/style/noNonNullAssertion: the `has` above ensures that this will always be set\n    return cache.get(txWithFrom)!;\n  }\n  const { account } = options;\n  const promise = (async () => {\n    const predefinedGas = await resolvePromisedValue(options.transaction.gas);\n    // if we have a predefined gas value in the TX -> always use that\n    if (predefinedGas !== undefined) {\n      return predefinedGas;\n    }\n\n    // if the wallet itself overrides the estimateGas function, use that\n    if (account?.estimateGas) {\n      try {\n        let gas = await account.estimateGas(options.transaction);\n        if (options.transaction.chain.experimental?.increaseZeroByteCount) {\n          gas = roundUpGas(gas);\n        }\n        return gas;\n      } catch (error) {\n        throw await parseEstimationError({\n          error,\n          contract: options.transaction.__contract,\n        });\n      }\n    }\n\n    // load up encode function if we need it\n    const { encode } = await import(\"./encode.js\");\n    const [encodedData, toAddress, value] = await Promise.all([\n      encode(options.transaction),\n      resolvePromisedValue(options.transaction.to),\n      resolvePromisedValue(options.transaction.value),\n    ]);\n\n    // load up the rpc client and the estimateGas function if we need it\n    const [{ getRpcClient }, { eth_estimateGas }] = await Promise.all([\n      import(\"../../rpc/rpc.js\"),\n      import(\"../../rpc/actions/eth_estimateGas.js\"),\n    ]);\n\n    const rpcRequest = getRpcClient(options.transaction);\n    try {\n      let gas = await eth_estimateGas(\n        rpcRequest,\n        formatTransactionRequest({\n          to: toAddress,\n          data: encodedData,\n          from,\n          value,\n        }),\n      );\n      if (options.transaction.chain.experimental?.increaseZeroByteCount) {\n        gas = roundUpGas(gas);\n      }\n      return gas;\n    } catch (error) {\n      throw await parseEstimationError({\n        error,\n        contract: options.transaction.__contract,\n      });\n    }\n  })();\n  cache.set(txWithFrom, promise);\n  return promise;\n}\n", "import type { Chain } from \"../chains/types.js\";\nimport type { ThirdwebClient } from \"../client/client.js\";\nimport { eth_gasPrice } from \"../rpc/actions/eth_gasPrice.js\";\nimport { getRpcClient } from \"../rpc/rpc.js\";\n\nexport type GetGasPriceOptions = {\n  client: ThirdwebClient;\n  chain: Chain;\n  percentMultiplier?: number;\n};\n\n/**\n * Retrieves the gas price for a transaction on a specific chain.\n * @param client - The Thirdweb client.\n * @param chain - The ID of the chain.\n * @returns A promise that resolves to the gas price as a bigint.\n * @example\n * ```ts\n * import { getGasPrice } from \"thirdweb\";\n *\n * const gasPrice = await getGasPrice({ client, chain });\n * ```\n * @utils\n */\nexport async function getGasPrice(\n  options: GetGasPriceOptions,\n): Promise<bigint> {\n  const { client, chain, percentMultiplier } = options;\n  const rpcClient = getRpcClient({ client, chain });\n  const gasPrice_ = await eth_gasPrice(rpcClient);\n  const extraTip = percentMultiplier\n    ? (gasPrice_ / BigInt(100)) * BigInt(percentMultiplier)\n    : 0n;\n  const txGasPrice = gasPrice_ + extraTip;\n  return txGasPrice;\n}\n", "import type { Chain } from \"../chains/types.js\";\nimport type { ThirdwebClient } from \"../client/client.js\";\nimport { eth_getBlockByNumber } from \"../rpc/actions/eth_getBlockByNumber.js\";\nimport { eth_maxPriorityFeePerGas } from \"../rpc/actions/eth_maxPriorityFeePerGas.js\";\nimport { getRpcClient } from \"../rpc/rpc.js\";\nimport type { PreparedTransaction } from \"../transaction/prepare-transaction.js\";\nimport { resolvePromisedValue } from \"../utils/promise/resolve-promised-value.js\";\nimport { toUnits } from \"../utils/units.js\";\nimport { getGasPrice } from \"./get-gas-price.js\";\nimport { roundUpGas } from \"./op-gas-fee-reducer.js\";\n\ntype FeeData = {\n  maxFeePerGas: null | bigint;\n  maxPriorityFeePerGas: null | bigint;\n};\n\ntype FeeDataParams =\n  | {\n      gasPrice?: never;\n      maxFeePerGas?: bigint;\n      maxPriorityFeePerGas?: bigint;\n    }\n  | {\n      gasPrice?: bigint;\n      maxFeePerGas?: never;\n      maxPriorityFeePerGas?: never;\n    };\n\n// for these chains - always force pre eip1559 transactions\nconst FORCE_GAS_PRICE_CHAIN_IDS = [\n  78600, // Vanar testnet\n  2040, // Vanar mainnet\n  248, // Oasys Mainnet\n  9372, // Oasys Testnet\n  841, // Taraxa Mainnet\n  842, // Taraxa Testnet\n  2016, // MainnetZ Mainnet\n  9768, // MainnetZ Testnet\n  2442, // Polygon zkEVM Cardona Testnet\n];\n\n/**\n *\n * @internal\n */\nexport async function getGasOverridesForTransaction(\n  transaction: PreparedTransaction,\n): Promise<FeeDataParams> {\n  // first check for explicit values\n  const [maxFeePerGas, maxPriorityFeePerGas, gasPrice] = await Promise.all([\n    resolvePromisedValue(transaction.maxFeePerGas),\n    resolvePromisedValue(transaction.maxPriorityFeePerGas),\n    resolvePromisedValue(transaction.gasPrice),\n  ]);\n\n  // Exit early if the user explicitly provided enough options\n  if (maxFeePerGas !== undefined && maxPriorityFeePerGas !== undefined) {\n    return {\n      maxFeePerGas,\n      maxPriorityFeePerGas,\n    };\n  }\n  if (gasPrice) {\n    return { gasPrice };\n  }\n\n  // If we don't have enough explicit values, get defaults\n  const defaultGasOverrides = await getDefaultGasOverrides(\n    transaction.client,\n    transaction.chain,\n  );\n\n  if (transaction.chain.experimental?.increaseZeroByteCount) {\n    // otherwise adjust each value\n    if (defaultGasOverrides.gasPrice) {\n      return { gasPrice: roundUpGas(defaultGasOverrides.gasPrice) };\n    }\n\n    return {\n      maxFeePerGas:\n        maxFeePerGas ?? roundUpGas(defaultGasOverrides.maxFeePerGas ?? 0n),\n      maxPriorityFeePerGas:\n        maxPriorityFeePerGas ??\n        roundUpGas(defaultGasOverrides.maxPriorityFeePerGas ?? 0n),\n    };\n  }\n\n  // return as is\n  if (defaultGasOverrides.gasPrice) {\n    return defaultGasOverrides;\n  }\n\n  // Still check for explicit values in case one is provided and not the other\n  return {\n    maxFeePerGas: maxFeePerGas ?? defaultGasOverrides.maxFeePerGas,\n    maxPriorityFeePerGas:\n      maxPriorityFeePerGas ?? defaultGasOverrides.maxPriorityFeePerGas,\n  };\n}\n\n/**\n * Retrieves the default gas overrides for a given client and chain ID.\n * If the fee data contains both maxFeePerGas and maxPriorityFeePerGas, it returns an object with those values.\n * Otherwise, it returns an object with the gasPrice obtained from the client and chain ID.\n * @param client - The ThirdwebClient instance.\n * @param chain - The chain ID.\n * @returns An object containing the default gas overrides.\n * @internal\n */\nexport async function getDefaultGasOverrides(\n  client: ThirdwebClient,\n  chain: Chain,\n) {\n  // if chain is in the force gas price list, always use gas price\n  if (!FORCE_GAS_PRICE_CHAIN_IDS.includes(chain.id)) {\n    const feeData = await getDynamicFeeData(client, chain);\n    if (\n      feeData.maxFeePerGas !== null &&\n      feeData.maxPriorityFeePerGas !== null\n    ) {\n      return {\n        maxFeePerGas: feeData.maxFeePerGas,\n        maxPriorityFeePerGas: feeData.maxPriorityFeePerGas,\n      };\n    }\n  }\n  return {\n    gasPrice: await getGasPrice({ client, chain, percentMultiplier: 10 }),\n  };\n}\n\n/**\n * Retrieves dynamic fee data for a given chain.\n * @param client - The Thirdweb client.\n * @param chain - The chain ID.\n * @returns A promise that resolves to the fee data.\n * @internal\n */\nasync function getDynamicFeeData(\n  client: ThirdwebClient,\n  chain: Chain,\n  percentMultiplier = 10,\n): Promise<FeeData> {\n  let maxFeePerGas: null | bigint = null;\n  let maxPriorityFeePerGas_: null | bigint = null;\n\n  const rpcRequest = getRpcClient({ client, chain });\n\n  const [block, maxPriorityFeePerGas] = await Promise.all([\n    eth_getBlockByNumber(rpcRequest, { blockTag: \"latest\" }),\n    eth_maxPriorityFeePerGas(rpcRequest).catch(() => null),\n  ]);\n\n  const baseBlockFee = block?.baseFeePerGas ?? 0n;\n\n  const chainId = chain.id;\n  // flag chain testnet & flag chain\n  if (chainId === 220 || chainId === 1220) {\n    // these does not support eip-1559, for some reason even though `eth_maxPriorityFeePerGas` is available?!?\n    // return null because otherwise TX break\n    return { maxFeePerGas: null, maxPriorityFeePerGas: null };\n    // mumbai & polygon\n  }\n  if (chainId === 80002 || chainId === 137) {\n    // for polygon, get fee data from gas station\n    maxPriorityFeePerGas_ = await getPolygonGasPriorityFee(chainId);\n  } else if (maxPriorityFeePerGas !== null) {\n    // prioritize fee from eth_maxPriorityFeePerGas\n    maxPriorityFeePerGas_ = maxPriorityFeePerGas;\n  }\n\n  if (maxPriorityFeePerGas_ == null) {\n    // chain does not support eip-1559, return null for both\n    return { maxFeePerGas: null, maxPriorityFeePerGas: null };\n  }\n\n  // add 10% tip to maxPriorityFeePerGas for faster processing\n  maxPriorityFeePerGas_ = getPreferredPriorityFee(\n    maxPriorityFeePerGas_,\n    percentMultiplier,\n  );\n  // eip-1559 formula, doubling the base fee ensures that the tx can be included in the next 6 blocks no matter how busy the network is\n  // good article on the subject: https://www.blocknative.com/blog/eip-1559-fees\n  maxFeePerGas = baseBlockFee * 2n + maxPriorityFeePerGas_;\n\n  // special cased for Celo gas fees\n  if (chainId === 42220 || chainId === 44787 || chainId === 62320) {\n    maxPriorityFeePerGas_ = maxFeePerGas;\n  }\n\n  return {\n    maxFeePerGas,\n    maxPriorityFeePerGas: maxPriorityFeePerGas_,\n  };\n}\n\n/**\n * Calculates the preferred priority fee based on the default priority fee per gas and a percent multiplier.\n * @param defaultPriorityFeePerGas - The default priority fee per gas.\n * @param percentMultiplier - The percent multiplier to calculate the extra tip. Default is 10.\n * @returns The total priority fee including the extra tip.\n * @internal\n */\nfunction getPreferredPriorityFee(\n  defaultPriorityFeePerGas: bigint,\n  percentMultiplier = 10,\n): bigint {\n  const extraTip =\n    (defaultPriorityFeePerGas / BigInt(100)) * BigInt(percentMultiplier);\n  const totalPriorityFee = defaultPriorityFeePerGas + extraTip;\n  return totalPriorityFee;\n}\n\n/**\n * @internal\n */\nfunction getGasStationUrl(chainId: 137 | 80002): string {\n  switch (chainId) {\n    case 137:\n      return \"https://gasstation.polygon.technology/v2\";\n    case 80002:\n      return \"https://gasstation-testnet.polygon.technology/v2\";\n  }\n}\n\nconst MIN_POLYGON_GAS_PRICE = 31n; // 31 gwei\n\n/**\n *\n * @returns The gas price\n * @internal\n */\nasync function getPolygonGasPriorityFee(chainId: 137 | 80002): Promise<bigint> {\n  const gasStationUrl = getGasStationUrl(chainId);\n  try {\n    const data = await (await fetch(gasStationUrl)).json();\n    // take the standard speed here, SDK options will define the extra tip\n    const priorityFee = data.fast.maxPriorityFee;\n    if (priorityFee > 0) {\n      const fixedFee = Number.parseFloat(priorityFee).toFixed(9);\n      return toUnits(fixedFee, 9);\n    }\n  } catch (e) {\n    console.error(\"failed to fetch gas\", e);\n  }\n  return MIN_POLYGON_GAS_PRICE;\n}\n", "import type { TransactionSerializable } from \"viem\";\nimport { getGasOverridesForTransaction } from \"../../gas/fee-data.js\";\nimport { getRpcClient } from \"../../rpc/rpc.js\";\nimport { getAddress } from \"../../utils/address.js\";\nimport { isZkSyncChain } from \"../../utils/any-evm/zksync/isZkSyncChain.js\";\nimport { resolvePromisedValue } from \"../../utils/promise/resolve-promised-value.js\";\nimport type { PreparedTransaction } from \"../prepare-transaction.js\";\nimport { encode } from \"./encode.js\";\nimport { estimateGas } from \"./estimate-gas.js\";\n\nexport type ToSerializableTransactionOptions = {\n  /**\n   * The transaction to convert to a serializable transaction.\n   */\n  // biome-ignore lint/suspicious/noExplicitAny: TODO: fix later\n  transaction: PreparedTransaction<any>;\n  /**\n   * The from address to use for gas estimation.\n   */\n  from?: string;\n};\n\n/**\n * Converts a prepared transaction to a transaction with populated options.\n * @param options - The transaction and additional options for conversion\n * @returns A serializable transaction for inspection or submission to an account.\n *\n * @note For easier transaction sending, {@see sendTransaction}\n * @example\n * ```ts\n * import { prepareTransaction, toSerializableTransaction } from \"thirdweb\";\n *\n * const transaction = await prepareTransaction({\n *   transaction: {\n *     to: \"0x...\",\n *     value: 100,\n *   },\n * });\n * const finalTx = await toSerializableTransaction({\n *   transaction,\n * });\n *\n * account.sendTransaction(finalTx);\n * ```\n * @transaction\n */\nexport async function toSerializableTransaction(\n  options: ToSerializableTransactionOptions,\n) {\n  // zk chains require a different rpc method for gas estimation and gas fees\n  const isZkSync = await isZkSyncChain(options.transaction.chain);\n  if (isZkSync) {\n    const { getZkGasFees } = await import(\n      \"./zksync/send-eip712-transaction.js\"\n    );\n    const { gas, maxFeePerGas, maxPriorityFeePerGas } = await getZkGasFees({\n      transaction: options.transaction,\n      from: options.from ? getAddress(options.from) : undefined,\n    });\n    // passing these values here will avoid re-fetching them below\n    options.transaction = {\n      ...options.transaction,\n      gas,\n      maxFeePerGas,\n      maxPriorityFeePerGas,\n    };\n  }\n\n  const rpcRequest = getRpcClient(options.transaction);\n  const chainId = options.transaction.chain.id;\n  const from = options.from;\n  let [data, nonce, gas, feeData, to, accessList, value] = await Promise.all([\n    encode(options.transaction),\n    (async () => {\n      // if the user has specified a nonce, use that\n      const resolvedNonce = await resolvePromisedValue(\n        options.transaction.nonce,\n      );\n      if (resolvedNonce !== undefined) {\n        return resolvedNonce;\n      }\n\n      return from // otherwise get the next nonce (import the method to do so)\n        ? await import(\"../../rpc/actions/eth_getTransactionCount.js\").then(\n            ({ eth_getTransactionCount }) =>\n              eth_getTransactionCount(rpcRequest, {\n                address: from,\n                blockTag: \"pending\",\n              }),\n          )\n        : undefined;\n    })(),\n    // takes the same options as the sendTransaction function thankfully!\n    estimateGas(options),\n    getGasOverridesForTransaction(options.transaction),\n    resolvePromisedValue(options.transaction.to),\n    resolvePromisedValue(options.transaction.accessList),\n    resolvePromisedValue(options.transaction.value),\n  ]);\n\n  const extraGas = await resolvePromisedValue(options.transaction.extraGas);\n  if (extraGas) {\n    gas += extraGas;\n  }\n\n  return {\n    to,\n    chainId,\n    data,\n    gas,\n    nonce,\n    accessList,\n    value,\n    ...feeData,\n  } satisfies TransactionSerializable;\n}\n"],
  "mappings": "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",
  "names": ["_a", "encode", "getRpcClient", "gas"]
}
