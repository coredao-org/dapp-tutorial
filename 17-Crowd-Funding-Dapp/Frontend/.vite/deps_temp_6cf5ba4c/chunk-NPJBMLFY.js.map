{
  "version": 3,
  "sources": ["../../node_modules/thirdweb/src/utils/abi/prepare-method.ts", "../../node_modules/thirdweb/src/transaction/utils.ts"],
  "sourcesContent": ["import { type AbiFunction, type ParseAbiItem, parseAbiItem } from \"abitype\";\nimport { toFunctionSelector } from \"viem\";\nimport { LruMap } from \"../caching/lru.js\";\nimport type { Hex } from \"../encoding/hex.js\";\nimport { stringify } from \"../json.js\";\n\ntype ParseMethod<method extends AbiFunction | `function ${string}`> =\n  // if the method IS an AbiFunction, return it\n  method extends AbiFunction\n    ? method\n    : method extends `function ${string}`\n      ? ParseAbiItem<method> extends AbiFunction\n        ? ParseAbiItem<method>\n        : never\n      : never;\n\nexport type PreparedMethod<TMethod extends AbiFunction | `function ${string}`> =\n  // [\"fn signature\", \"inputs\", \"outputs\"]\n  [Hex, ParseMethod<TMethod>[\"inputs\"], ParseMethod<TMethod>[\"outputs\"]];\n\nconst prepareMethodCache = new LruMap<PreparedMethod<AbiFunction>>(4096);\n\n/**\n * Prepares a method for usage by converting it into a prepared method object.\n * @param method The method to prepare.\n * @returns The prepared method object.\n * @example\n * ```ts\n * import { prepareMethod } from \"thirdweb/utils\";\n * const method = \"function transfer(address to, uint256 value)\";\n * const preparedMethod = prepareMethod(method);\n * ```\n * @contract\n */\nexport function prepareMethod<\n  const TMethod extends AbiFunction | `function ${string}`,\n>(method: TMethod): PreparedMethod<TMethod> {\n  const key = typeof method === \"string\" ? method : stringify(method);\n  if (prepareMethodCache.has(key)) {\n    return prepareMethodCache.get(key) as PreparedMethod<TMethod>;\n  }\n  type ParsedAbiFn = ParseMethod<TMethod>;\n\n  const abiFn =\n    typeof method === \"string\"\n      ? // @ts-expect-error - we're sure it's a string...\n        (parseAbiItem(method) as ParsedAbiFn)\n      : (method as ParsedAbiFn);\n\n  // encode the method signature\n  const sig = toFunctionSelector(abiFn);\n\n  const ret: PreparedMethod<TMethod> = [sig, abiFn.inputs, abiFn.outputs];\n  prepareMethodCache.set(key, ret);\n  return ret;\n}\n", "import type { AbiFunction } from \"abitype\";\n\n/**\n * @internal\n */\nexport function isAbiFunction(item: unknown): item is AbiFunction {\n  return !!(\n    item &&\n    typeof item === \"object\" &&\n    \"type\" in item &&\n    item.type === \"function\"\n  );\n}\n"],
  "mappings": ";;;;;;;;;;;;AAoBA,IAAM,qBAAqB,IAAI,OAAoC,IAAI;AAcjE,SAAU,cAEd,QAAe;AACf,QAAM,MAAM,OAAO,WAAW,WAAW,SAAS,UAAU,MAAM;AAClE,MAAI,mBAAmB,IAAI,GAAG,GAAG;AAC/B,WAAO,mBAAmB,IAAI,GAAG;EACnC;AAGA,QAAM,QACJ,OAAO,WAAW;;IAEb,aAAa,MAAM;MACnB;AAGP,QAAM,MAAM,mBAAmB,KAAK;AAEpC,QAAM,MAA+B,CAAC,KAAK,MAAM,QAAQ,MAAM,OAAO;AACtE,qBAAmB,IAAI,KAAK,GAAG;AAC/B,SAAO;AACT;;;AClDM,SAAU,cAAc,MAAa;AACzC,SAAO,CAAC,EACN,QACA,OAAO,SAAS,YAChB,UAAU,QACV,KAAK,SAAS;AAElB;",
  "names": []
}
