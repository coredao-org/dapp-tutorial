{
  "version": 3,
  "sources": ["../../node_modules/thirdweb/src/extensions/marketplace/utils.ts", "../../node_modules/thirdweb/src/extensions/marketplace/direct-listings/utils.ts", "../../node_modules/thirdweb/src/extensions/marketplace/__generated__/IDirectListings/read/getListing.ts", "../../node_modules/thirdweb/src/extensions/marketplace/direct-listings/read/getListing.ts"],
  "sourcesContent": ["import type { BaseTransactionOptions } from \"../../transaction/types.js\";\nimport type { NFT } from \"../../utils/nft/parseNft.js\";\nimport { isERC721 } from \"../erc721/read/isERC721.js\";\nimport { isERC1155 } from \"../erc1155/read/isERC1155.js\";\nimport type { ListingStatus } from \"./types.js\";\n\n/**\n * @extension MARKETPLACE\n */\ntype GetAssetParams = {\n  tokenId: bigint;\n};\n\n/**\n * Retrieves the NFT asset based on the provided options.\n * @param options The transaction options.\n * @returns A promise that resolves to the NFT asset.\n * @extension MARKETPLACE\n * @example\n * ```ts\n * import { getNFTAsset } from \"thirdweb/extensions/marketplace\";\n *\n * const nft = await getNFTAsset({ contract, tokenId: 1n });\n * ```\n */\nexport async function getNFTAsset(\n  options: BaseTransactionOptions<GetAssetParams>,\n): Promise<NFT> {\n  const [erc721, erc1155] = await Promise.all([\n    isERC721(options),\n    isERC1155(options),\n  ]);\n  switch (true) {\n    case erc721: {\n      const { getNFT } = await import(\"../erc721/read/getNFT.js\");\n      return getNFT(options);\n    }\n    case erc1155: {\n      const { getNFT } = await import(\"../erc1155/read/getNFT.js\");\n      return getNFT(options);\n    }\n    default: {\n      throw new Error(\"Contract is neither ERC721 nor ERC1155.\");\n    }\n  }\n}\n\nexport function computeStatus(options: {\n  listingStatus: number;\n  blockTimeStamp: bigint;\n  startTimestamp: bigint;\n  endTimestamp: bigint;\n}): ListingStatus {\n  switch (options.listingStatus) {\n    case 1: {\n      if (options.startTimestamp > options.blockTimeStamp) {\n        return \"CREATED\";\n      }\n      if (options.endTimestamp < options.blockTimeStamp) {\n        return \"EXPIRED\";\n      }\n      return \"ACTIVE\";\n    }\n    case 2: {\n      return \"COMPLETED\";\n    }\n    case 3: {\n      return \"CANCELLED\";\n    }\n    default: {\n      throw new Error(`Invalid listing status: \"${options.listingStatus}\"`);\n    }\n  }\n}\n\n/**\n * @internal\n */\nexport async function getAllInBatches<const T>(\n  fn: (start: bigint, end: bigint) => Promise<T>,\n  options: {\n    start: bigint;\n    end: bigint;\n    maxSize: bigint;\n  },\n): Promise<T[]> {\n  let start = options.start;\n  const batches: Promise<T>[] = [];\n  while (options.end - start > options.maxSize) {\n    batches.push(fn(start, options.end + options.maxSize - 1n));\n    start += options.maxSize;\n  }\n  batches.push(fn(start, options.end - 1n));\n\n  return await Promise.all(batches);\n}\n", "import { getContract } from \"../../../contract/contract.js\";\nimport type { BaseTransactionOptions } from \"../../../transaction/types.js\";\nimport { toTokens } from \"../../../utils/units.js\";\nimport { getCurrencyMetadata } from \"../../erc20/read/getCurrencyMetadata.js\";\nimport { isERC721 } from \"../../erc721/read/isERC721.js\";\nimport { isERC1155 } from \"../../erc1155/read/isERC1155.js\";\nimport type { getListing } from \"../__generated__/IDirectListings/read/getListing.js\";\nimport { computeStatus, getNFTAsset } from \"../utils.js\";\nimport type { DirectListing } from \"./types.js\";\n\n/**\n * @internal\n */\nexport async function mapDirectListing(\n  options: BaseTransactionOptions<{\n    latestBlock: { timestamp: bigint };\n    rawListing: Awaited<ReturnType<typeof getListing>>;\n  }>,\n): Promise<DirectListing> {\n  const { latestBlock, rawListing } = options;\n  // process the listing\n  const status = computeStatus({\n    listingStatus: rawListing.status,\n    blockTimeStamp: latestBlock.timestamp,\n    startTimestamp: rawListing.startTimestamp,\n    endTimestamp: rawListing.endTimestamp,\n  });\n\n  const [currencyValuePerToken, nftAsset] = await Promise.all([\n    getCurrencyMetadata({\n      contract: getContract({\n        ...options.contract,\n        address: rawListing.currency,\n      }),\n    }),\n    getNFTAsset({\n      ...options,\n      contract: getContract({\n        ...options.contract,\n        address: rawListing.assetContract,\n      }),\n      tokenId: rawListing.tokenId,\n    }),\n  ]);\n\n  return {\n    id: rawListing.listingId,\n    creatorAddress: rawListing.listingCreator,\n    assetContractAddress: rawListing.assetContract,\n    tokenId: rawListing.tokenId,\n    quantity: rawListing.quantity,\n    currencyContractAddress: rawListing.currency,\n    currencyValuePerToken: {\n      ...currencyValuePerToken,\n      value: rawListing.pricePerToken,\n      displayValue: toTokens(\n        rawListing.pricePerToken,\n        currencyValuePerToken.decimals,\n      ),\n    },\n    pricePerToken: rawListing.pricePerToken,\n    asset: nftAsset,\n    startTimeInSeconds: rawListing.startTimestamp,\n    endTimeInSeconds: rawListing.endTimestamp,\n    isReservedListing: rawListing.reserved,\n    status,\n    type: \"direct-listing\",\n  };\n}\n\ntype IsListingValidParams = {\n  listing: DirectListing;\n  quantity?: bigint;\n};\ntype ValidReturn = { valid: true } | { valid: false; reason: string };\n\nexport async function isListingValid(\n  options: BaseTransactionOptions<IsListingValidParams>,\n): Promise<ValidReturn> {\n  const assetContract = getContract({\n    ...options.contract,\n    address: options.listing.assetContractAddress,\n  });\n\n  const [erc721, erc1155] = await Promise.all([\n    isERC721({ contract: assetContract }),\n    isERC1155({ contract: assetContract }),\n  ]);\n\n  // if the asset is an erc721 token\n  if (erc721) {\n    const [{ isApprovedForAll }, { getApproved }, { ownerOf }] =\n      await Promise.all([\n        import(\"../../erc721/__generated__/IERC721A/read/isApprovedForAll.js\"),\n        import(\"../../erc721/__generated__/IERC721A/read/getApproved.js\"),\n        import(\"../../erc721/__generated__/IERC721A/read/ownerOf.js\"),\n      ]);\n    // check for token approval\n    const [approvedForAll, approvedOperator, tokenOwner] = await Promise.all([\n      isApprovedForAll({\n        contract: assetContract,\n        owner: options.listing.creatorAddress,\n        // the marketplace contract address has to be approved to transfer the token\n        operator: options.contract.address,\n      }),\n      getApproved({\n        contract: assetContract,\n        tokenId: options.listing.tokenId,\n      }).catch(() => \"\"),\n      ownerOf({\n        contract: assetContract,\n        tokenId: options.listing.tokenId,\n      }),\n    ]);\n    // if the marketplace is not approved for all and the marketplace contract is not the approved operator for the token\n    // -> the listing is not valid\n    if (!approvedForAll && approvedOperator !== options.contract.address) {\n      return { valid: false, reason: \"Asset not approved for marketplace.\" };\n    }\n    // if the token owner is not the creator of the listing\n    // -> the listing is not valid\n    if (tokenOwner !== options.listing.creatorAddress) {\n      return {\n        valid: false,\n        reason: \"Listing creator no longer owns this token.\",\n      };\n    }\n    // otherwise the listing is valid\n    return {\n      valid: true,\n    };\n  }\n  // if the asset is an erc1155 token\n  if (erc1155) {\n    const [{ isApprovedForAll }, { balanceOf }] = await Promise.all([\n      import(\"../../erc1155/__generated__/IERC1155/read/isApprovedForAll.js\"),\n      import(\"../../erc1155/__generated__/IERC1155/read/balanceOf.js\"),\n    ]);\n\n    const [approvedForAll, balance] = await Promise.all([\n      isApprovedForAll({\n        contract: assetContract,\n        owner: options.listing.creatorAddress,\n        // the marketplace contract address has to be approved to transfer the token\n        operator: options.contract.address,\n      }),\n      balanceOf({\n        contract: assetContract,\n        owner: options.listing.creatorAddress,\n        tokenId: options.listing.tokenId,\n      }),\n    ]);\n\n    // if the marketplace is not approved for all\n    // -> the listing is not valid\n    if (!approvedForAll) {\n      return { valid: false, reason: \"Asset not approved for marketplace.\" };\n    }\n    // if the balance is less than the quantity the user is trying to purchase or the listing quantity\n    // -> the listing is not valid\n    const quantityWanted = options.quantity || options.listing.quantity;\n    if (balance < quantityWanted) {\n      return {\n        valid: false,\n        reason:\n          \"Seller does not have enough balance of token to fulfill order.\",\n      };\n    }\n    return {\n      valid: true,\n    };\n  }\n  // if the asset is neither ERC721 nor ERC1155\n\n  return {\n    valid: false,\n    reason: \"AssetContract must implement ERC 1155 or ERC 721.\",\n  };\n}\n", "import type { AbiParameterToPrimitiveType } from \"abitype\";\nimport { readContract } from \"../../../../../transaction/read-contract.js\";\nimport type { BaseTransactionOptions } from \"../../../../../transaction/types.js\";\nimport { encodeAbiParameters } from \"../../../../../utils/abi/encodeAbiParameters.js\";\nimport { decodeAbiParameters } from \"viem\";\nimport type { Hex } from \"../../../../../utils/encoding/hex.js\";\nimport { detectMethod } from \"../../../../../utils/bytecode/detectExtension.js\";\n\n/**\n * Represents the parameters for the \"getListing\" function.\n */\nexport type GetListingParams = {\n  listingId: AbiParameterToPrimitiveType<{\n    type: \"uint256\";\n    name: \"_listingId\";\n  }>;\n};\n\nexport const FN_SELECTOR = \"0x107a274a\" as const;\nconst FN_INPUTS = [\n  {\n    type: \"uint256\",\n    name: \"_listingId\",\n  },\n] as const;\nconst FN_OUTPUTS = [\n  {\n    type: \"tuple\",\n    name: \"listing\",\n    components: [\n      {\n        type: \"uint256\",\n        name: \"listingId\",\n      },\n      {\n        type: \"uint256\",\n        name: \"tokenId\",\n      },\n      {\n        type: \"uint256\",\n        name: \"quantity\",\n      },\n      {\n        type: \"uint256\",\n        name: \"pricePerToken\",\n      },\n      {\n        type: \"uint128\",\n        name: \"startTimestamp\",\n      },\n      {\n        type: \"uint128\",\n        name: \"endTimestamp\",\n      },\n      {\n        type: \"address\",\n        name: \"listingCreator\",\n      },\n      {\n        type: \"address\",\n        name: \"assetContract\",\n      },\n      {\n        type: \"address\",\n        name: \"currency\",\n      },\n      {\n        type: \"uint8\",\n        name: \"tokenType\",\n      },\n      {\n        type: \"uint8\",\n        name: \"status\",\n      },\n      {\n        type: \"bool\",\n        name: \"reserved\",\n      },\n    ],\n  },\n] as const;\n\n/**\n * Checks if the `getListing` method is supported by the given contract.\n * @param availableSelectors An array of 4byte function selectors of the contract. You can get this in various ways, such as using \"whatsabi\" or if you have the ABI of the contract available you can use it to generate the selectors.\n * @returns A boolean indicating if the `getListing` method is supported.\n * @extension MARKETPLACE\n * @example\n * ```ts\n * import { isGetListingSupported } from \"thirdweb/extensions/marketplace\";\n * const supported = isGetListingSupported([\"0x...\"]);\n * ```\n */\nexport function isGetListingSupported(availableSelectors: string[]) {\n  return detectMethod({\n    availableSelectors,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n  });\n}\n\n/**\n * Encodes the parameters for the \"getListing\" function.\n * @param options - The options for the getListing function.\n * @returns The encoded ABI parameters.\n * @extension MARKETPLACE\n * @example\n * ```ts\n * import { encodeGetListingParams } from \"thirdweb/extensions/marketplace\";\n * const result = encodeGetListingParams({\n *  listingId: ...,\n * });\n * ```\n */\nexport function encodeGetListingParams(options: GetListingParams) {\n  return encodeAbiParameters(FN_INPUTS, [options.listingId]);\n}\n\n/**\n * Encodes the \"getListing\" function into a Hex string with its parameters.\n * @param options - The options for the getListing function.\n * @returns The encoded hexadecimal string.\n * @extension MARKETPLACE\n * @example\n * ```ts\n * import { encodeGetListing } from \"thirdweb/extensions/marketplace\";\n * const result = encodeGetListing({\n *  listingId: ...,\n * });\n * ```\n */\nexport function encodeGetListing(options: GetListingParams) {\n  // we do a \"manual\" concat here to avoid the overhead of the \"concatHex\" function\n  // we can do this because we know the specific formats of the values\n  return (FN_SELECTOR +\n    encodeGetListingParams(options).slice(\n      2,\n    )) as `${typeof FN_SELECTOR}${string}`;\n}\n\n/**\n * Decodes the result of the getListing function call.\n * @param result - The hexadecimal result to decode.\n * @returns The decoded result as per the FN_OUTPUTS definition.\n * @extension MARKETPLACE\n * @example\n * ```ts\n * import { decodeGetListingResult } from \"thirdweb/extensions/marketplace\";\n * const result = decodeGetListingResultResult(\"...\");\n * ```\n */\nexport function decodeGetListingResult(result: Hex) {\n  return decodeAbiParameters(FN_OUTPUTS, result)[0];\n}\n\n/**\n * Calls the \"getListing\" function on the contract.\n * @param options - The options for the getListing function.\n * @returns The parsed result of the function call.\n * @extension MARKETPLACE\n * @example\n * ```ts\n * import { getListing } from \"thirdweb/extensions/marketplace\";\n *\n * const result = await getListing({\n *  contract,\n *  listingId: ...,\n * });\n *\n * ```\n */\nexport async function getListing(\n  options: BaseTransactionOptions<GetListingParams>,\n) {\n  return readContract({\n    contract: options.contract,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n    params: [options.listingId],\n  });\n}\n", "import { eth_getBlockByNumber } from \"../../../../rpc/actions/eth_getBlockByNumber.js\";\nimport { getRpcClient } from \"../../../../rpc/rpc.js\";\nimport type { BaseTransactionOptions } from \"../../../../transaction/types.js\";\nimport * as GetListing from \"../../__generated__/IDirectListings/read/getListing.js\";\nimport type { DirectListing } from \"../types.js\";\nimport { mapDirectListing } from \"../utils.js\";\n\n/**\n * @extension MARKETPLACE\n */\nexport type GetListingParams = GetListing.GetListingParams;\n\n/**\n * Retrieves a direct listing based on the provided options.\n * @param options - The options for retrieving the listing.\n * @returns A promise that resolves to the direct listing.\n * @extension MARKETPLACE\n * @example\n *\n * ```ts\n * import { getListing } from \"thirdweb/extensions/marketplace\";\n *\n * const listing = await getListing({ contract, listingId: 1n });\n * ```\n */\nexport async function getListing(\n  options: BaseTransactionOptions<GetListingParams>,\n): Promise<DirectListing> {\n  const rpcClient = getRpcClient(options.contract);\n  const [rawListing, latestBlock] = await Promise.all([\n    GetListing.getListing(options),\n    eth_getBlockByNumber(rpcClient, {\n      blockTag: \"latest\",\n    }),\n  ]);\n\n  return mapDirectListing({\n    contract: options.contract,\n    latestBlock,\n    rawListing,\n  });\n}\n\n/**\n * Checks if the `isGetListingSupported` method is supported by the given contract.\n * @param availableSelectors An array of 4byte function selectors of the contract. You can get this in various ways, such as using \"whatsabi\" or if you have the ABI of the contract available you can use it to generate the selectors.\n * @returns A boolean indicating if the `isGetListingSupported` method is supported.\n * @extension MARKETPLACE\n * @example\n * ```ts\n * import { isGetListingSupported } from \"thirdweb/extensions/marketplace\";\n *\n * const supported = isGetListingSupported([\"0x...\"]);\n * ```\n */\nexport function isGetListingSupported(availableSelectors: string[]) {\n  return GetListing.isGetListingSupported(availableSelectors);\n}\n"],
  "mappings": "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",
  "names": ["getListing", "isGetListingSupported"]
}
