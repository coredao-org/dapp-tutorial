{
  "version": 3,
  "sources": ["../../node_modules/thirdweb/src/wallets/wallet-connect/controller.ts"],
  "sourcesContent": ["import type { EthereumProvider } from \"@walletconnect/ethereum-provider\";\nimport type { Address } from \"abitype\";\nimport {\n  type ProviderRpcError,\n  type SignTypedDataParameters,\n  SwitchChainError,\n  UserRejectedRequestError,\n  getTypesForEIP712Domain,\n  serializeTypedData,\n  validateTypedData,\n} from \"viem\";\nimport { trackTransaction } from \"../../analytics/track/transaction.js\";\nimport type { Chain } from \"../../chains/types.js\";\nimport {\n  getCachedChain,\n  getChainMetadata,\n  getRpcUrlForChain,\n} from \"../../chains/utils.js\";\nimport type { ThirdwebClient } from \"../../client/client.js\";\nimport { getAddress } from \"../../utils/address.js\";\nimport {\n  type Hex,\n  numberToHex,\n  stringToHex,\n  uint8ArrayToHex,\n} from \"../../utils/encoding/hex.js\";\nimport { stringify } from \"../../utils/json.js\";\nimport { parseTypedData } from \"../../utils/signatures/helpers/parseTypedData.js\";\nimport type { AsyncStorage } from \"../../utils/storage/AsyncStorage.js\";\nimport {\n  getSavedConnectParamsFromStorage,\n  saveConnectParamsToStorage,\n} from \"../../utils/storage/walletStorage.js\";\nimport { formatWalletConnectUrl } from \"../../utils/url.js\";\nimport { getWalletInfo } from \"../__generated__/getWalletInfo.js\";\nimport type { WCSupportedWalletIds } from \"../__generated__/wallet-ids.js\";\nimport type {\n  Account,\n  SendTransactionOption,\n  Wallet,\n} from \"../interfaces/wallet.js\";\nimport type { DisconnectFn, SwitchChainFn } from \"../types.js\";\nimport { getValidPublicRPCUrl } from \"../utils/chains.js\";\nimport { getDefaultAppMetadata } from \"../utils/defaultDappMetadata.js\";\nimport { normalizeChainId } from \"../utils/normalizeChainId.js\";\nimport type { WalletEmitter } from \"../wallet-emitter.js\";\nimport type { WalletId } from \"../wallet-types.js\";\nimport { DEFAULT_PROJECT_ID, NAMESPACE } from \"./constants.js\";\nimport type { WCAutoConnectOptions, WCConnectOptions } from \"./types.js\";\n\ntype WCProvider = InstanceType<typeof EthereumProvider>;\n\ntype SavedConnectParams = {\n  optionalChains?: Chain[];\n  chain?: Chain;\n  pairingTopic?: string;\n};\n\nconst ADD_ETH_CHAIN_METHOD = \"wallet_addEthereumChain\";\n\nconst defaultShowQrModal = true;\n\nconst storageKeys = {\n  requestedChains: \"tw.wc.requestedChains\",\n  lastUsedChainId: \"tw.wc.lastUsedChainId\",\n};\n\n/**\n * Checks if the provided wallet is a Wallet Connect wallet.\n *\n * @param wallet - The wallet to check.\n * @returns True if the wallet is a Wallet Connect wallet, false otherwise.\n */\nexport function isWalletConnect(\n  wallet: Wallet<WalletId>,\n): wallet is Wallet<\"walletConnect\"> {\n  return wallet.id === \"walletConnect\";\n}\n\n/**\n * @internal\n */\nexport async function connectWC(\n  options: WCConnectOptions,\n  emitter: WalletEmitter<WCSupportedWalletIds>,\n  walletId: WCSupportedWalletIds | \"walletConnect\",\n  storage: AsyncStorage,\n  sessionHandler?: (uri: string) => void,\n): Promise<ReturnType<typeof onConnect>> {\n  const provider = await initProvider(options, walletId, sessionHandler);\n  const wcOptions = options.walletConnect;\n\n  let { onDisplayUri } = wcOptions || {};\n\n  // use default sessionHandler unless onDisplayUri is explicitly provided\n  if (!onDisplayUri && sessionHandler && walletId !== \"walletConnect\") {\n    const walletInfo = await getWalletInfo(walletId);\n    const deeplinkHandler = (uri: string) => {\n      const appUrl = walletInfo.mobile.native || walletInfo.mobile.universal;\n      if (!appUrl) {\n        throw new Error(\"No app url found for wallet connect to redirect to.\");\n      }\n      const fullUrl = formatWalletConnectUrl(appUrl, uri).redirect;\n      sessionHandler(fullUrl);\n    };\n    onDisplayUri = deeplinkHandler;\n  }\n\n  if (onDisplayUri) {\n    provider.events.addListener(\"display_uri\", onDisplayUri);\n  }\n\n  let optionalChains: Chain[] | undefined = wcOptions?.optionalChains;\n  let chainToRequest = options.chain;\n\n  // ignore the given options chains - and set the safe supported chains\n  if (walletId === \"global.safe\") {\n    optionalChains = chainsToRequestForSafe.map(getCachedChain);\n    if (chainToRequest && !optionalChains.includes(chainToRequest)) {\n      chainToRequest = undefined;\n    }\n  }\n\n  const {\n    rpcMap,\n    requiredChain,\n    optionalChains: chainsToRequest,\n  } = getChainsToRequest({\n    client: options.client,\n    chain: chainToRequest,\n    optionalChains: optionalChains,\n  });\n\n  if (provider.session) {\n    await provider.connect({\n      ...(wcOptions?.pairingTopic\n        ? { pairingTopic: wcOptions?.pairingTopic }\n        : {}),\n      optionalChains: chainsToRequest,\n      chains: requiredChain ? [requiredChain.id] : undefined,\n      rpcMap: rpcMap,\n    });\n  }\n\n  setRequestedChainsIds(chainsToRequest, storage);\n  // If session exists and chains are authorized, enable provider for required chain\n  const addresses = await provider.enable();\n  const address = addresses[0];\n  if (!address) {\n    throw new Error(\"No accounts found on provider.\");\n  }\n\n  const providerChainId = normalizeChainId(provider.chainId);\n\n  const chain =\n    options.chain && options.chain.id === providerChainId\n      ? options.chain\n      : getCachedChain(providerChainId);\n\n  if (options) {\n    const savedParams: SavedConnectParams = {\n      optionalChains: options.walletConnect?.optionalChains,\n      chain: options.chain,\n      pairingTopic: options.walletConnect?.pairingTopic,\n    };\n\n    if (storage) {\n      saveConnectParamsToStorage(storage, walletId, savedParams);\n    }\n  }\n\n  if (wcOptions?.onDisplayUri) {\n    provider.events.removeListener(\"display_uri\", wcOptions.onDisplayUri);\n  }\n\n  return onConnect(address, chain, provider, emitter, storage, options.client);\n}\n\n/**\n * Auto connect to already connected wallet connect session.\n * @internal\n */\nexport async function autoConnectWC(\n  options: WCAutoConnectOptions,\n  emitter: WalletEmitter<WCSupportedWalletIds>,\n  walletId: WCSupportedWalletIds | \"walletConnect\",\n  storage: AsyncStorage,\n  sessionHandler?: (uri: string) => void,\n): Promise<ReturnType<typeof onConnect>> {\n  const savedConnectParams: SavedConnectParams | null = storage\n    ? await getSavedConnectParamsFromStorage(storage, walletId)\n    : null;\n\n  const provider = await initProvider(\n    savedConnectParams\n      ? {\n          chain: savedConnectParams.chain,\n          client: options.client,\n          walletConnect: {\n            pairingTopic: savedConnectParams.pairingTopic,\n            optionalChains: savedConnectParams.optionalChains,\n          },\n        }\n      : {\n          client: options.client,\n          walletConnect: {},\n        },\n    walletId,\n    sessionHandler,\n    true, // is auto connect\n  );\n\n  const address = provider.accounts[0];\n\n  if (!address) {\n    throw new Error(\"No accounts found on provider.\");\n  }\n\n  const providerChainId = normalizeChainId(provider.chainId);\n\n  const chain =\n    options.chain && options.chain.id === providerChainId\n      ? options.chain\n      : getCachedChain(providerChainId);\n\n  return onConnect(address, chain, provider, emitter, storage, options.client);\n}\n\n// Connection utils -----------------------------------------------------------------------------------------------\n\nasync function initProvider(\n  options: WCConnectOptions,\n  walletId: WCSupportedWalletIds | \"walletConnect\",\n  sessionRequestHandler?: (uri: string) => void | Promise<void>,\n  isAutoConnect = false,\n) {\n  const walletInfo = await getWalletInfo(walletId);\n  const wcOptions = options.walletConnect;\n  const { EthereumProvider, OPTIONAL_EVENTS, OPTIONAL_METHODS } = await import(\n    \"@walletconnect/ethereum-provider\"\n  );\n\n  let optionalChains: Chain[] | undefined = wcOptions?.optionalChains;\n  let chainToRequest = options.chain;\n\n  // ignore the given options chains - and set the safe supported chains\n  if (walletId === \"global.safe\") {\n    optionalChains = chainsToRequestForSafe.map(getCachedChain);\n    if (chainToRequest && !optionalChains.includes(chainToRequest)) {\n      chainToRequest = undefined;\n    }\n  }\n\n  const {\n    rpcMap,\n    requiredChain,\n    optionalChains: chainsToRequest,\n  } = getChainsToRequest({\n    client: options.client,\n    chain: chainToRequest,\n    optionalChains: optionalChains,\n  });\n\n  const provider = await EthereumProvider.init({\n    showQrModal:\n      wcOptions?.showQrModal === undefined\n        ? sessionRequestHandler\n          ? false\n          : defaultShowQrModal\n        : wcOptions.showQrModal,\n    projectId: wcOptions?.projectId || DEFAULT_PROJECT_ID,\n    optionalMethods: OPTIONAL_METHODS,\n    optionalEvents: OPTIONAL_EVENTS,\n    optionalChains: chainsToRequest,\n    chains: requiredChain ? [requiredChain.id] : undefined,\n    metadata: {\n      name: wcOptions?.appMetadata?.name || getDefaultAppMetadata().name,\n      description:\n        wcOptions?.appMetadata?.description ||\n        getDefaultAppMetadata().description,\n      url: wcOptions?.appMetadata?.url || getDefaultAppMetadata().url,\n      icons: [\n        wcOptions?.appMetadata?.logoUrl || getDefaultAppMetadata().logoUrl,\n      ],\n    },\n    rpcMap: rpcMap,\n    qrModalOptions: wcOptions?.qrModalOptions,\n    disableProviderPing: true,\n  });\n\n  provider.events.setMaxListeners(Number.POSITIVE_INFINITY);\n\n  // disconnect the provider if chains are stale when (if not auto connecting)\n  if (!isAutoConnect) {\n    // const isStale = await isChainsStale(provider, chainsToRequest);\n\n    if (provider.session) {\n      await provider.disconnect();\n    }\n  }\n\n  if (walletId !== \"walletConnect\") {\n    async function handleSessionRequest() {\n      const walletLinkToOpen =\n        provider.session?.peer?.metadata?.redirect?.native ||\n        walletInfo.mobile.native ||\n        walletInfo.mobile.universal;\n\n      if (sessionRequestHandler && walletLinkToOpen) {\n        // TODO: propagate error when this fails\n        await sessionRequestHandler(walletLinkToOpen);\n      }\n    }\n\n    provider.signer.client.on(\"session_request_sent\", handleSessionRequest);\n    provider.events.addListener(\"disconnect\", () => {\n      provider.signer.client.off(\"session_request_sent\", handleSessionRequest);\n    });\n  }\n\n  return provider;\n}\n\nfunction createAccount({\n  provider,\n  address,\n  client,\n}: {\n  provider: WCProvider;\n  address: string;\n  client: ThirdwebClient;\n}) {\n  const account: Account = {\n    address: address,\n    async sendTransaction(tx: SendTransactionOption) {\n      const transactionHash = (await provider.request({\n        method: \"eth_sendTransaction\",\n        params: [\n          {\n            gas: tx.gas ? numberToHex(tx.gas) : undefined,\n            value: tx.value ? numberToHex(tx.value) : undefined,\n            from: getAddress(address),\n            to: tx.to as Address,\n            data: tx.data,\n          },\n        ],\n      })) as Hex;\n\n      trackTransaction({\n        client: client,\n        walletAddress: getAddress(address),\n        walletType: \"walletConnect\",\n        transactionHash,\n        chainId: tx.chainId,\n        contractAddress: tx.to ?? undefined,\n        gasPrice: tx.gasPrice,\n      });\n\n      return {\n        transactionHash,\n      };\n    },\n    async signMessage({ message }) {\n      const messageToSign = (() => {\n        if (typeof message === \"string\") {\n          return stringToHex(message);\n        }\n        if (message.raw instanceof Uint8Array) {\n          return uint8ArrayToHex(message.raw);\n        }\n        return message.raw;\n      })();\n      return provider.request({\n        method: \"personal_sign\",\n        params: [messageToSign, this.address],\n      });\n    },\n    async signTypedData(_data) {\n      const data = parseTypedData(_data);\n      const { domain, message, primaryType } =\n        data as unknown as SignTypedDataParameters;\n\n      const types = {\n        EIP712Domain: getTypesForEIP712Domain({ domain }),\n        ...data.types,\n      };\n\n      // Need to do a runtime validation check on addresses, byte ranges, integer ranges, etc\n      // as we can't statically check this with TypeScript.\n      validateTypedData({ domain, message, primaryType, types });\n\n      const typedData = serializeTypedData({\n        domain: domain ?? {},\n        message,\n        primaryType,\n        types,\n      });\n\n      return await provider.request({\n        method: \"eth_signTypedData_v4\",\n        params: [this.address, typedData],\n      });\n    },\n  };\n\n  return account;\n}\n\nfunction onConnect(\n  address: string,\n  chain: Chain,\n  provider: WCProvider,\n  emitter: WalletEmitter<WCSupportedWalletIds>,\n  storage: AsyncStorage,\n  client: ThirdwebClient,\n): [Account, Chain, DisconnectFn, SwitchChainFn] {\n  const account = createAccount({ provider, address, client });\n\n  async function disconnect() {\n    provider.removeListener(\"accountsChanged\", onAccountsChanged);\n    provider.removeListener(\"chainChanged\", onChainChanged);\n    provider.removeListener(\"disconnect\", onDisconnect);\n    await provider.disconnect();\n  }\n\n  function onDisconnect() {\n    setRequestedChainsIds([], storage);\n    storage?.removeItem(storageKeys.lastUsedChainId);\n    disconnect();\n    emitter.emit(\"disconnect\", undefined);\n  }\n\n  function onAccountsChanged(accounts: string[]) {\n    if (accounts[0]) {\n      const newAccount = createAccount({\n        provider,\n        address: getAddress(accounts[0]),\n        client,\n      });\n      emitter.emit(\"accountChanged\", newAccount);\n      emitter.emit(\"accountsChanged\", accounts);\n    } else {\n      onDisconnect();\n    }\n  }\n\n  function onChainChanged(newChainId: string) {\n    const newChain = getCachedChain(normalizeChainId(newChainId));\n    emitter.emit(\"chainChanged\", newChain);\n    storage?.setItem(storageKeys.lastUsedChainId, String(newChainId));\n  }\n\n  provider.on(\"accountsChanged\", onAccountsChanged);\n  provider.on(\"chainChanged\", onChainChanged);\n  provider.on(\"disconnect\", onDisconnect);\n  provider.on(\"session_delete\", onDisconnect);\n\n  return [\n    account,\n    chain,\n    disconnect,\n    (newChain) => switchChainWC(provider, newChain, storage),\n  ];\n}\n\n// Storage utils  -----------------------------------------------------------------------------------------------\n\nfunction getNamespaceMethods(provider: WCProvider) {\n  return provider.session?.namespaces[NAMESPACE]?.methods || [];\n}\n\nfunction getNamespaceChainsIds(provider: WCProvider): number[] {\n  const chainIds = provider.session?.namespaces[NAMESPACE]?.chains?.map(\n    (chain) => Number.parseInt(chain.split(\":\")[1] || \"\"),\n  );\n\n  return chainIds ?? [];\n}\n\nasync function switchChainWC(\n  provider: WCProvider,\n  chain: Chain,\n  storage: AsyncStorage,\n) {\n  const chainId = chain.id;\n  try {\n    const namespaceChains = getNamespaceChainsIds(provider);\n    const namespaceMethods = getNamespaceMethods(provider);\n    const isChainApproved = namespaceChains.includes(chainId);\n\n    if (!isChainApproved && namespaceMethods.includes(ADD_ETH_CHAIN_METHOD)) {\n      const apiChain = await getChainMetadata(chain);\n\n      const blockExplorerUrls = [\n        ...new Set([\n          ...(chain.blockExplorers?.map((x) => x.url) || []),\n          ...(apiChain.explorers?.map((x) => x.url) || []),\n        ]),\n      ];\n\n      await provider.request({\n        method: ADD_ETH_CHAIN_METHOD,\n        params: [\n          {\n            chainId: numberToHex(apiChain.chainId),\n            chainName: apiChain.name,\n            nativeCurrency: apiChain.nativeCurrency,\n            rpcUrls: getValidPublicRPCUrl(apiChain), // no clientId on purpose\n            blockExplorerUrls:\n              blockExplorerUrls.length > 0 ? blockExplorerUrls : undefined,\n          },\n        ],\n      });\n      const requestedChains = await getRequestedChainsIds(storage);\n      requestedChains.push(chainId);\n      setRequestedChainsIds(requestedChains, storage);\n    }\n    await provider.request({\n      method: \"wallet_switchEthereumChain\",\n      params: [{ chainId: numberToHex(chainId) }],\n    });\n  } catch (error) {\n    const message =\n      typeof error === \"string\" ? error : (error as ProviderRpcError)?.message;\n    if (/user rejected request/i.test(message)) {\n      throw new UserRejectedRequestError(error as Error);\n    }\n\n    throw new SwitchChainError(error as Error);\n  }\n}\n\n/**\n * Set the requested chains to the storage.\n * @internal\n */\nfunction setRequestedChainsIds(\n  chains: number[] | undefined,\n  storage: AsyncStorage,\n) {\n  storage?.setItem(storageKeys.requestedChains, stringify(chains));\n}\n\n/**\n * Get the last requested chains from the storage.\n * @internal\n */\nasync function getRequestedChainsIds(storage: AsyncStorage): Promise<number[]> {\n  const data = await storage.getItem(storageKeys.requestedChains);\n  return data ? JSON.parse(data) : [];\n}\n\ntype ArrayOneOrMore<T> = {\n  0: T;\n} & Array<T>;\n\nfunction getChainsToRequest(options: {\n  chain?: Chain;\n  optionalChains?: Chain[];\n  client: ThirdwebClient;\n}): {\n  rpcMap: Record<number, string>;\n  requiredChain: Chain | undefined;\n  optionalChains: ArrayOneOrMore<number>;\n} {\n  const rpcMap: Record<number, string> = {};\n\n  if (options.chain) {\n    rpcMap[options.chain.id] = getRpcUrlForChain({\n      chain: options.chain,\n      client: options.client,\n    });\n  }\n\n  // limit optional chains to 10\n  const optionalChains = (options?.optionalChains || []).slice(0, 10);\n\n  for (const chain of optionalChains) {\n    rpcMap[chain.id] = getRpcUrlForChain({\n      chain: chain,\n      client: options.client,\n    });\n  }\n\n  if (!options.chain && optionalChains.length === 0) {\n    rpcMap[1] = getCachedChain(1).rpc;\n  }\n\n  return {\n    rpcMap,\n    requiredChain: options.chain ? options.chain : undefined,\n    optionalChains:\n      optionalChains.length > 0\n        ? (optionalChains.map((x) => x.id) as ArrayOneOrMore<number>)\n        : [1],\n  };\n}\n\nconst chainsToRequestForSafe = [\n  1, // Ethereum Mainnet\n  11155111, // Sepolia Testnet\n  42161, // Arbitrum One Mainnet\n  43114, // Avalanche Mainnet\n  8453, // Base Mainnet\n  1313161554, // Aurora Mainnet\n  84532, // Base Sepolia Testnet\n  56, // Binance Smart Chain Mainnet\n  42220, // Celo Mainnet\n  100, // Gnosis Mainnet\n  10, // Optimism Mainnet\n  137, // Polygon Mainnet\n  1101, // Polygon zkEVM Mainnet\n  324, // zkSync Era mainnet\n  534352, // Scroll mainnet\n];\n"],
  "mappings": "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",
  "names": ["_a", "_b", "_c", "_d"]
}
