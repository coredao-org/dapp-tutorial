{
  "version": 3,
  "sources": ["../../node_modules/thirdweb/src/merkletree/MerkleTree.ts", "../../node_modules/thirdweb/src/utils/extensions/drops/convert-quantity.ts", "../../node_modules/thirdweb/src/utils/extensions/drops/hash-entry.ts", "../../node_modules/thirdweb/src/utils/extensions/drops/fetch-proofs-for-claimers.ts"],
  "sourcesContent": ["// ADAPTED FROM https://github.com/merkletreejs/merkletreejs\nimport { type Hex, uint8ArrayToHex } from \"../utils/encoding/hex.js\";\nimport { hexToBytes } from \"../utils/encoding/to-bytes.js\";\nimport { keccak256 } from \"../utils/hashing/keccak256.js\";\nimport {\n  areUint8ArraysEqual,\n  compareUint8Arrays,\n  concatUint8Arrays,\n} from \"../utils/uint8-array.js\";\n\n// TODO: clean this up more, there is probably something to be said to move this entirely out of a class\n\ntype TLeaf = Uint8Array;\ntype TLayer = Uint8Array[];\n\n/**\n * Class reprensenting a Merkle Tree\n * @namespace MerkleTree\n */\nexport class MerkleTree {\n  private leaves: TLeaf[] = [];\n  private layers: TLayer[] = [];\n\n  constructor(leaves: (Uint8Array | Hex)[]) {\n    this.leaves = leaves.map((el) =>\n      el instanceof Uint8Array ? el : hexToBytes(el),\n    );\n\n    this.leaves = this.leaves.sort(compareUint8Arrays);\n\n    this.createHashes(this.leaves);\n  }\n\n  public getHexRoot(): `0x${string}` {\n    return uint8ArrayToHex(this.getRoot());\n  }\n\n  public getHexProof(leaf: Uint8Array | Hex, index?: number): `0x${string}`[] {\n    return this.getProof(leaf, index).map((item) => uint8ArrayToHex(item.data));\n  }\n\n  // private below\n\n  private createHashes(nodes: Uint8Array[]) {\n    this.layers = [nodes];\n    while (nodes.length > 1) {\n      const layerIndex = this.layers.length;\n\n      this.layers.push([]);\n\n      const layerLimit = nodes.length;\n\n      for (let i = 0; i < nodes.length; i += 2) {\n        if (i >= layerLimit) {\n          // biome-ignore lint/style/noNonNullAssertion: in bounds\n          this.layers[layerIndex]!.push(...nodes.slice(layerLimit));\n          break;\n        }\n        if (i + 1 === nodes.length) {\n          if (nodes.length % 2 === 1) {\n            // push copy of hash and continue iteration\n            // biome-ignore lint/style/noNonNullAssertion: in bounds\n            this.layers[layerIndex]!.push(nodes[i]!);\n            continue;\n          }\n        }\n\n        // biome-ignore lint/style/noNonNullAssertion: in bounds\n        const left = nodes[i]!;\n        // biome-ignore lint/style/noNonNullAssertion: in bounds\n        const right = i + 1 === nodes.length ? left : nodes[i + 1]!;\n        const combined = [left, right];\n\n        combined.sort(compareUint8Arrays);\n\n        const hash = keccak256(concatUint8Arrays(combined), \"bytes\");\n\n        // biome-ignore lint/style/noNonNullAssertion: in bounds\n        this.layers[layerIndex]!.push(hash);\n      }\n      // biome-ignore lint/style/noParameterAssign: part of the functionality\n      // biome-ignore lint/style/noNonNullAssertion: in bounds\n      nodes = this.layers[layerIndex]!;\n    }\n  }\n\n  private getRoot(): Uint8Array {\n    if (this.layers.length === 0) {\n      return new Uint8Array();\n    }\n\n    // biome-ignore lint/style/noNonNullAssertion: in bounds\n    return this.layers[this.layers.length - 1]![0] || new Uint8Array();\n  }\n\n  private getProof(\n    leaf: Uint8Array | Hex,\n    index?: number,\n  ): { position: \"left\" | \"right\"; data: Uint8Array }[] {\n    if (typeof leaf === \"undefined\") {\n      throw new Error(\"leaf is required\");\n    }\n    // biome-ignore lint/style/noParameterAssign: part of the functionality\n    leaf = leaf instanceof Uint8Array ? leaf : hexToBytes(leaf);\n    const proof = [];\n\n    if (!Number.isInteger(index)) {\n      // biome-ignore lint/style/noParameterAssign: part of the functionality\n      index = -1;\n\n      for (let i = 0; i < this.leaves.length; i++) {\n        // biome-ignore lint/style/noNonNullAssertion: within bounds\n        if (areUint8ArraysEqual(leaf, this.leaves[i]!)) {\n          // biome-ignore lint/style/noParameterAssign: part of the functionality\n          index = i;\n        }\n      }\n    }\n\n    // @ts-expect-error - issue from original code\n    if (index <= -1) {\n      return [];\n    }\n\n    for (let i = 0; i < this.layers.length; i++) {\n      // biome-ignore lint/style/noNonNullAssertion: in bounds\n      const layer = this.layers[i]!;\n      // @ts-expect-error - issue from original code\n      const isRightNode = index % 2;\n      const pairIndex = isRightNode\n        ? // @ts-expect-error - issue from original code\n          index - 1\n        : // Proof Generation for Non-Bitcoin Trees\n          // @ts-expect-error - issue from original code\n          index + 1;\n\n      if (pairIndex < layer.length) {\n        proof.push({\n          position: isRightNode ? \"left\" : \"right\",\n          data: layer[pairIndex],\n        });\n      }\n\n      // set index to parent index\n      // @ts-expect-error - issue from original code\n      // biome-ignore lint/style/noParameterAssign: part of the functionality\n      index = (index / 2) | 0;\n    }\n\n    // @ts-expect-error - issue from original code\n    return proof;\n  }\n}\n", "import { maxUint256 } from \"viem\";\nimport { toUnits } from \"../../units.js\";\n\nexport function convertQuantity(options: {\n  quantity: string;\n  tokenDecimals: number;\n}) {\n  const { quantity, tokenDecimals } = options;\n  if (quantity === \"unlimited\") {\n    return maxUint256;\n  }\n  return toUnits(quantity, tokenDecimals);\n}\n", "import { encodePacked } from \"viem\";\nimport type { Chain } from \"../../../chains/types.js\";\nimport type { ThirdwebClient } from \"../../../client/client.js\";\nimport {\n  ZERO_ADDRESS,\n  isNativeTokenAddress,\n} from \"../../../constants/addresses.js\";\nimport { keccak256 } from \"../../hashing/keccak256.js\";\nimport { convertQuantity } from \"./convert-quantity.js\";\nimport type { OverrideEntry } from \"./types.js\";\n\nexport async function hashEntry(options: {\n  entry: OverrideEntry;\n  chain: Chain;\n  client: ThirdwebClient;\n  tokenDecimals: number;\n}) {\n  const currencyAddress = options.entry.currencyAddress || ZERO_ADDRESS;\n  const currencyDecimals = await (async () => {\n    if (\n      isNativeTokenAddress(currencyAddress) ||\n      currencyAddress === ZERO_ADDRESS\n    ) {\n      return 18;\n    }\n    const [{ getContract }, { decimals: getDecimals }] = await Promise.all([\n      import(\"../../../contract/contract.js\"),\n      import(\"../../../extensions/erc20/read/decimals.js\"),\n    ]);\n    const currencyContract = getContract({\n      address: currencyAddress,\n      chain: options.chain,\n      client: options.client,\n    });\n    return await getDecimals({ contract: currencyContract });\n  })();\n\n  return keccak256(\n    encodePacked(\n      [\"address\", \"uint256\", \"uint256\", \"address\"],\n      [\n        options.entry.address,\n        convertQuantity({\n          quantity: options.entry.maxClaimable || \"unlimited\",\n          tokenDecimals: options.tokenDecimals,\n        }),\n        convertQuantity({\n          quantity: options.entry.price || \"unlimited\",\n          tokenDecimals: currencyDecimals,\n        }),\n        currencyAddress,\n      ],\n    ),\n  );\n}\n", "import type { Chain } from \"../../../chains/types.js\";\nimport type { ThirdwebClient } from \"../../../client/client.js\";\nimport {\n  ZERO_ADDRESS,\n  isNativeTokenAddress,\n} from \"../../../constants/addresses.js\";\nimport type { ThirdwebContract } from \"../../../contract/contract.js\";\nimport { MerkleTree } from \"../../../merkletree/MerkleTree.js\";\nimport { download } from \"../../../storage/download.js\";\nimport type { Address } from \"../../address.js\";\nimport type { Hex } from \"../../encoding/hex.js\";\nimport { convertQuantity } from \"./convert-quantity.js\";\nimport { hashEntry } from \"./hash-entry.js\";\nimport type {\n  OverrideEntry,\n  OverrideProof,\n  ShardData,\n  ShardedMerkleTreeInfo,\n} from \"./types.js\";\n\nexport async function fetchProofsForClaimer(options: {\n  contract: ThirdwebContract;\n  claimer: string;\n  merkleTreeUri: string;\n  tokenDecimals: number;\n  hashEntry?: (options: {\n    entry: OverrideEntry;\n    chain: Chain;\n    client: ThirdwebClient;\n    tokenDecimals: number;\n  }) => Promise<Hex>;\n}): Promise<OverrideProof | null> {\n  const { contract, merkleTreeUri, claimer } = options;\n  const hashEntryFn = options.hashEntry || hashEntry;\n\n  // 2. download snapshot data\n  const response = await download({\n    client: contract.client,\n    uri: merkleTreeUri,\n  });\n  const merkleInfo: ShardedMerkleTreeInfo = await response.json();\n\n  // 3. download shard data based off the user address\n  const shardId = claimer.slice(2, 2 + merkleInfo.shardNybbles).toLowerCase();\n  const uri = merkleInfo.baseUri.endsWith(\"/\")\n    ? merkleInfo.baseUri\n    : `${merkleInfo.baseUri}/`;\n  let shardData: ShardData;\n\n  try {\n    const constructedShardUri = `${uri}${shardId}.json`;\n    const shard = await download({\n      client: contract.client,\n      uri: constructedShardUri,\n    });\n    shardData = await shard.json();\n  } catch {\n    // if the file can't be fetched it means claimer not in merkle tree\n    return null;\n  }\n\n  // 4. hash all the entries in that shard and construct the sub merkle tree\n  const hashedEntries = await Promise.all(\n    shardData.entries.map(async (entry) => {\n      return hashEntryFn({\n        entry,\n        chain: contract.chain,\n        client: contract.client,\n        tokenDecimals: options.tokenDecimals,\n      });\n    }),\n  );\n  // 5. get the proof for the claimer + the sub merkle tree root\n  const tree = new MerkleTree(hashedEntries);\n  const entry = shardData.entries.find(\n    (i) => i.address.toLowerCase() === claimer.toLowerCase(),\n  );\n  if (!entry) {\n    return null;\n  }\n  const proof = tree\n    .getHexProof(\n      await hashEntryFn({\n        entry,\n        chain: contract.chain,\n        client: contract.client,\n        tokenDecimals: options.tokenDecimals,\n      }),\n    )\n    .concat(shardData.proofs);\n  // 6. return the proof and the entry data for the contract call\n  const currencyAddress = (entry.currencyAddress || ZERO_ADDRESS) as Address;\n  const currencyDecimals = await (async () => {\n    if (\n      isNativeTokenAddress(currencyAddress) ||\n      currencyAddress === ZERO_ADDRESS\n    ) {\n      return 18;\n    }\n    const [{ getContract }, { decimals: getDecimals }] = await Promise.all([\n      import(\"../../../contract/contract.js\"),\n      import(\"../../../extensions/erc20/read/decimals.js\"),\n    ]);\n    const currencyContract = getContract({\n      address: currencyAddress,\n      chain: contract.chain,\n      client: contract.client,\n    });\n    return await getDecimals({ contract: currencyContract });\n  })();\n\n  return {\n    proof,\n    quantityLimitPerWallet: convertQuantity({\n      quantity: entry.maxClaimable || \"unlimited\",\n      tokenDecimals: options.tokenDecimals,\n    }),\n    pricePerToken: convertQuantity({\n      quantity: entry.price || \"unlimited\",\n      tokenDecimals: currencyDecimals,\n    }),\n    currency: currencyAddress,\n  };\n}\n"],
  "mappings": "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",
  "names": ["entry"]
}
