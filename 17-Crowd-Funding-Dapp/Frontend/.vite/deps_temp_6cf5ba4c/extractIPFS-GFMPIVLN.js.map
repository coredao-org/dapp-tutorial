{
  "version": 3,
  "sources": ["../../node_modules/thirdweb/src/utils/base58/alphabet.ts", "../../node_modules/thirdweb/src/utils/base58/encode.ts", "../../node_modules/thirdweb/src/utils/bytecode/cbor-decode.ts", "../../node_modules/thirdweb/src/utils/bytecode/prefix.ts", "../../node_modules/thirdweb/src/utils/bytecode/extractIPFS.ts"],
  "sourcesContent": ["export const ALPHABET =\n  \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\" as const;\n", "import { ALPHABET } from \"./alphabet.js\";\n\nconst BASE = ALPHABET.length;\nconst LEADER = /* @__PURE__ */ (() => ALPHABET.charAt(0))();\nconst iFACTOR = /* @__PURE__ */ (() => Math.log(256) / Math.log(BASE))(); // log(256) / log(BASE), rounded up\n\n/**\n * Encodes a Uint8Array into a base58 string.\n * @param source - The Uint8Array to encode.\n * @returns The base58 encoded string.\n * @throws {TypeError} If the source is not a Uint8Array.\n * @throws {Error} If there is a non-zero carry during the encoding process.\n * @example\n * ```ts\n * import { base58Encode } from \"thirdweb/utils;\n * const source = new Uint8Array([0, 1, 2, 3, 4, 5]);\n * const encoded = base58Encode(source);\n * console.log(encoded);\n * ```\n */\nexport function base58Encode(source: Uint8Array): string {\n  if (!(source instanceof Uint8Array)) {\n    throw new TypeError(\"Expected Uint8Array\");\n  }\n  if (source.length === 0) {\n    return \"\";\n  }\n  // Skip & count leading zeroes.\n  let zeroes = 0;\n  let length = 0;\n  let pbegin = 0;\n  const pend = source.length;\n  while (pbegin !== pend && source[pbegin] === 0) {\n    pbegin++;\n    zeroes++;\n  }\n  // Allocate enough space in big-endian base58 representation.\n  const size = ((pend - pbegin) * iFACTOR + 1) >>> 0;\n  const b58 = new Uint8Array(size);\n  // Process the bytes.\n  while (pbegin !== pend) {\n    let carry = source[pbegin] || 0;\n    // Apply \"b58 = b58 * 256 + ch\".\n    let i = 0;\n    for (\n      let it1 = size - 1;\n      (carry !== 0 || i < length) && it1 !== -1;\n      it1--, i++\n    ) {\n      carry += (256 * (b58[it1] || 0)) >>> 0;\n      b58[it1] = (carry % BASE) >>> 0;\n      carry = (carry / BASE) >>> 0;\n    }\n    if (carry !== 0) {\n      throw new Error(\"Non-zero carry\");\n    }\n    length = i;\n    pbegin++;\n  }\n  // Skip leading zeroes in base58 result.\n  let it2 = size - length;\n  while (it2 !== size && b58[it2] === 0) {\n    it2++;\n  }\n  // Translate the result into a string.\n  let str = LEADER.repeat(zeroes);\n  for (; it2 < size; ++it2) {\n    str += ALPHABET.charAt(b58[it2] || 0);\n  }\n  return str;\n}\n", "// original source: https://github.com/kriszyp/cbor-x/blob/master/decode.js\n// heavily modified to remove all non-essential code\n\n// TODO: re-enable typescript and properly type this\n\n// @ts-nocheck - TODO: re-enable typescript and properly type this\n\nlet src;\nlet srcEnd;\nlet position = 0;\n\nconst EMPTY_ARRAY = [];\n\nlet strings = EMPTY_ARRAY;\n\nlet stringPosition = 0;\nlet currentDecoder = {};\nlet currentStructures;\nlet srcString;\nconst srcStringStart = 0;\nlet srcStringEnd = 0;\nlet bundledStrings;\nlet referenceMap;\nconst currentExtensions = [];\n\nlet packedValues;\n\nlet dataView;\n\nconst defaultOptions = {\n  useRecords: false,\n  mapsAsObjects: true,\n};\n\nfunction readFixedString(length) {\n\tlet result\n\tif (length < 16) {\n\t\tif (result = shortStringInJS(length))\n\t\t\treturn result\n\t}\n\tif (length > 64 && decoder)\n\t\treturn decoder.decode(src.subarray(position, position += length))\n\tconst end = position + length\n\tconst units = []\n\tresult = ''\n\twhile (position < end) {\n\t\tconst byte1 = src[position++]\n\t\tif ((byte1 & 0x80) === 0) {\n\t\t\t// 1 byte\n\t\t\tunits.push(byte1)\n\t\t} else if ((byte1 & 0xe0) === 0xc0) {\n\t\t\t// 2 bytes\n\t\t\tconst byte2 = src[position++] & 0x3f\n\t\t\tunits.push(((byte1 & 0x1f) << 6) | byte2)\n\t\t} else if ((byte1 & 0xf0) === 0xe0) {\n\t\t\t// 3 bytes\n\t\t\tconst byte2 = src[position++] & 0x3f\n\t\t\tconst byte3 = src[position++] & 0x3f\n\t\t\tunits.push(((byte1 & 0x1f) << 12) | (byte2 << 6) | byte3)\n\t\t} else if ((byte1 & 0xf8) === 0xf0) {\n\t\t\t// 4 bytes\n\t\t\tconst byte2 = src[position++] & 0x3f\n\t\t\tconst byte3 = src[position++] & 0x3f\n\t\t\tconst byte4 = src[position++] & 0x3f\n\t\t\tlet unit = ((byte1 & 0x07) << 0x12) | (byte2 << 0x0c) | (byte3 << 0x06) | byte4\n\t\t\tif (unit > 0xffff) {\n\t\t\t\tunit -= 0x10000\n\t\t\t\tunits.push(((unit >>> 10) & 0x3ff) | 0xd800)\n\t\t\t\tunit = 0xdc00 | (unit & 0x3ff)\n\t\t\t}\n\t\t\tunits.push(unit)\n\t\t} else {\n\t\t\tunits.push(byte1)\n\t\t}\n\n\t\tif (units.length >= 0x1000) {\n\t\t\tresult += fromCharCode.apply(String, units)\n\t\t\tunits.length = 0\n\t\t}\n\t}\n\n\tif (units.length > 0) {\n\t\tresult += fromCharCode.apply(String, units)\n\t}\n\n\treturn result\n}\n\nclass Decoder {\n  constructor() {\n    Object.assign(this, defaultOptions);\n  }\n\n  decodeKey(key) {\n    return key;\n  }\n\n  decode(source, end? = -1) {\n    srcEnd = end > -1 ? end : source.length;\n    position = 0;\n    stringPosition = 0;\n    srcStringEnd = 0;\n    srcString = null;\n    strings = EMPTY_ARRAY;\n    bundledStrings = null;\n    src = source;\n    // this provides cached access to the data view for a buffer if it is getting reused, which is a recommend\n    // technique for getting data from a database where it can be copied into an existing buffer instead of creating\n    // new ones\n    try {\n      dataView =\n        source.dataView ||\n        (source.dataView = new DataView(\n          source.buffer,\n          source.byteOffset,\n          source.byteLength,\n        ));\n    } catch (error) {\n      // if it doesn't have a buffer, maybe it is the wrong type of object\n      src = null;\n      if (source instanceof Uint8Array) {\n        throw error;\n      }\n      throw new Error(\n        `Source must be a Uint8Array or Buffer but was a ${source && typeof source === \"object\"\n            ? source.constructor.name\n            : typeof source}`,\n      );\n    }\n    if (this instanceof Decoder) {\n      currentDecoder = this;\n      packedValues =\n        this.sharedValues &&\n        (this.pack\n          ? new Array(this.maxPrivatePackedValues || 16).concat(\n              this.sharedValues,\n            )\n          : this.sharedValues);\n      if (!currentStructures || currentStructures.length > 0) {\n        currentStructures = [];\n      }\n    } else {\n      currentDecoder = defaultOptions;\n      if (!currentStructures || currentStructures.length > 0) {\n        currentStructures = [];\n      }\n      packedValues = null;\n    }\n    return checkedRead();\n  }\n}\n\nfunction checkedRead() {\n  try {\n    const result = read();\n    if (bundledStrings) {\n      if (position >= bundledStrings.postBundlePosition) {\n        const error = new Error(\"Unexpected bundle position\");\n        error.incomplete = true;\n        throw error;\n      }\n      // bundled strings to skip past\n      position = bundledStrings.postBundlePosition;\n      bundledStrings = null;\n    }\n\n    if (position === srcEnd) {\n      // finished reading this source, cleanup references\n      currentStructures = null;\n      src = null;\n      if (referenceMap) {\n        referenceMap = null;\n      }\n    } else if (position > srcEnd) {\n      // over read\n      const error = new Error(\"Unexpected end of CBOR data\");\n      error.incomplete = true;\n      throw error;\n    } else {\n      throw new Error(\"Data read, but end of buffer not reached\");\n    }\n    // else more to read, but we are reading sequentially, so don't clear source yet\n    return result;\n  } catch (error) {\n    clearSource();\n    if (\n      error instanceof RangeError ||\n      error.message.startsWith(\"Unexpected end of buffer\")\n    ) {\n      error.incomplete = true;\n    }\n    throw error;\n  }\n}\n\nfunction read() {\n  let token = src[position++];\n  const majorType = token >> 5;\n  token = token & 0x1f;\n  if (token > 0x17) {\n    switch (token) {\n      case 0x18:\n        token = src[position++];\n        break;\n\n      default:\n        throw new Error(`Unknown token ${token}`);\n    }\n  }\n  switch (majorType) {\n    case 0: // positive int\n      return token;\n    case 1: // negative int\n      return ~token;\n    case 2: // buffer\n      return readBin(token);\n    case 3: // string\n      if (srcStringEnd >= position) {\n        return srcString.slice(\n          position - srcStringStart,\n          (position += token) - srcStringStart,\n        );\n      }\n      if (srcStringEnd === 0 && srcEnd < 140 && token < 32) {\n        // for small blocks, avoiding the overhead of the extract call is helpful\n        const string =\n          token < 16 ? shortStringInJS(token) : longStringInJS(token);\n        if (string !== null) {\n          return string;\n        }\n      }\n      return readFixedString(token);\n    case 4: { // array\n      const array = new Array(token);\n      for (let i = 0; i < token; i++) {\n        array[i] = read();\n      }\n      return array;\n    }\n\n    case 5: { // map\n      const object = {};\n      for (let i = 0; i < token; i++) {\n        object[safeKey(read())] = read();\n      }\n      return object;\n    }\n    default: // negative int\n      if (Number.isNaN(token)) {\n        const error = new Error(\"Unexpected end of CBOR data\");\n        error.incomplete = true;\n        throw error;\n      }\n      throw new Error(`Unknown CBOR token ${token}`);\n  }\n}\n\nfunction safeKey(key) {\n  // protect against prototype pollution\n  if (typeof key === \"string\") {\n    return key === \"__proto__\" ? \"__proto_\" : key;\n  }\n  if (typeof key !== \"object\") {\n    return key.toString();\n  }\n  // protect against expensive (DoS) string conversions\n  throw new Error(`Invalid property name type ${typeof key}`);\n}\n\nconst fromCharCode = String.fromCharCode;\nfunction longStringInJS(length) {\n  const start = position;\n  const bytes = new Array(length);\n  for (let i = 0; i < length; i++) {\n    const byte = src[position++];\n    if ((byte & 0x80) > 0) {\n      position = start;\n      return;\n    }\n    bytes[i] = byte;\n  }\n  return fromCharCode.apply(String, bytes);\n}\nfunction shortStringInJS(length) {\n  if (length < 4) {\n    if (length < 2) {\n      if (length === 0) {\n        return \"\";\n      }\n        const a = src[position++];\n        if ((a & 0x80) > 1) {\n          position -= 1;\n          return;\n        }\n        return fromCharCode(a);\n    }\n      const a = src[position++];\n      const b = src[position++];\n      if ((a & 0x80) > 0 || (b & 0x80) > 0) {\n        position -= 2;\n        return;\n      }\n      if (length < 3) {\n        return fromCharCode(a, b);\n      }\n      const c = src[position++];\n      if ((c & 0x80) > 0) {\n        position -= 3;\n        return;\n      }\n      return fromCharCode(a, b, c);\n  }\n    const a = src[position++];\n    const b = src[position++];\n    const c = src[position++];\n    const d = src[position++];\n    if ((a & 0x80) > 0 || (b & 0x80) > 0 || (c & 0x80) > 0 || (d & 0x80) > 0) {\n      position -= 4;\n      return;\n    }\n    if (length < 6) {\n      if (length === 4) {\n        return fromCharCode(a, b, c, d);\n      }\n        const e = src[position++];\n        if ((e & 0x80) > 0) {\n          position -= 5;\n          return;\n        }\n        return fromCharCode(a, b, c, d, e);\n    }if (length < 8) {\n      const e = src[position++];\n      const f = src[position++];\n      if ((e & 0x80) > 0 || (f & 0x80) > 0) {\n        position -= 6;\n        return;\n      }\n      if (length < 7) {\n        return fromCharCode(a, b, c, d, e, f);\n      }\n      const g = src[position++];\n      if ((g & 0x80) > 0) {\n        position -= 7;\n        return;\n      }\n      return fromCharCode(a, b, c, d, e, f, g);\n    }\n      const e = src[position++];\n      const f = src[position++];\n      const g = src[position++];\n      const h = src[position++];\n      if (\n        (e & 0x80) > 0 ||\n        (f & 0x80) > 0 ||\n        (g & 0x80) > 0 ||\n        (h & 0x80) > 0\n      ) {\n        position -= 8;\n        return;\n      }\n      if (length < 10) {\n        if (length === 8) {\n          return fromCharCode(a, b, c, d, e, f, g, h);\n        }\n          const i = src[position++];\n          if ((i & 0x80) > 0) {\n            position -= 9;\n            return;\n          }\n          return fromCharCode(a, b, c, d, e, f, g, h, i);\n      }if (length < 12) {\n        const i = src[position++];\n        const j = src[position++];\n        if ((i & 0x80) > 0 || (j & 0x80) > 0) {\n          position -= 10;\n          return;\n        }\n        if (length < 11) {\n          return fromCharCode(a, b, c, d, e, f, g, h, i, j);\n        }\n        const k = src[position++];\n        if ((k & 0x80) > 0) {\n          position -= 11;\n          return;\n        }\n        return fromCharCode(a, b, c, d, e, f, g, h, i, j, k);\n      }\n        const i = src[position++];\n        const j = src[position++];\n        const k = src[position++];\n        const l = src[position++];\n        if (\n          (i & 0x80) > 0 ||\n          (j & 0x80) > 0 ||\n          (k & 0x80) > 0 ||\n          (l & 0x80) > 0\n        ) {\n          position -= 12;\n          return;\n        }\n        if (length < 14) {\n          if (length === 12) {\n            return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l);\n          }\n            const m = src[position++];\n            if ((m & 0x80) > 0) {\n              position -= 13;\n              return;\n            }\n            return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m);\n        }\n          const m = src[position++];\n          const n = src[position++];\n          if ((m & 0x80) > 0 || (n & 0x80) > 0) {\n            position -= 14;\n            return;\n          }\n          if (length < 15) {\n            return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n);\n          }\n          const o = src[position++];\n          if ((o & 0x80) > 0) {\n            position -= 15;\n            return;\n          }\n          return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o);\n}\n\nfunction readBin(length) {\n  return currentDecoder.copyBuffers\n    ? // specifically use the copying slice (not the node one)\n      Uint8Array.prototype.slice.call(src, position, (position += length))\n    : src.subarray(position, (position += length));\n}\n\nconst glbl = { Error, RegExp };\ncurrentExtensions[27] = (data) => {\n  // http://cbor.schmorp.de/generic-object\n  return (glbl[data[0]] || Error)(data[1], data[2]);\n};\nconst packedTable = (read_) => {\n  if (src[position++] !== 0x84) {\n    const error = new Error(\n      \"Packed values structure must be followed by a 4 element array\",\n    );\n    if (src.length < position) {\n      error.incomplete = true;\n    }\n    throw error;\n  }\n  const newPackedValues = read_(); // packed values\n  if (!newPackedValues || !newPackedValues.length) {\n    const error = new Error(\n      \"Packed values structure must be followed by a 4 element array\",\n    );\n    error.incomplete = true;\n    throw error;\n  }\n  packedValues = packedValues\n    ? newPackedValues.concat(packedValues.slice(newPackedValues.length))\n    : newPackedValues;\n  packedValues.prefixes = read_();\n  packedValues.suffixes = read_();\n  return read_(); // read the rump\n};\npackedTable.handlesRead = true;\n\ncurrentExtensions[28] = (read_) => {\n  // shareable http://cbor.schmorp.de/value-sharing (for structured clones)\n  if (!referenceMap) {\n    referenceMap = new Map();\n    referenceMap.id = 0;\n  }\n  const id = referenceMap.id++;\n  const token = src[position];\n  let target;\n  // TODO: handle Maps, Sets, and other types that can cycle; this is complicated, because you potentially need to read\n  // ahead past references to record structure definitions\n  if (token >> 5 === 4) {\n    target = [];\n  } else {\n    target = {};\n  }\n\n  const refEntry = { target }; // a placeholder object\n  referenceMap.set(id, refEntry);\n  const targetProperties = read_(); // read the next value as the target object to id\n  if (refEntry.used) {\n    // there is a cycle, so we have to assign properties to original target\n    return Object.assign(target, targetProperties);\n  }\n  refEntry.target = targetProperties; // the placeholder wasn't used, replace with the deserialized one\n  return targetProperties; // no cycle, can just use the returned read object\n};\n\nfunction clearSource() {\n  src = null;\n  referenceMap = null;\n  currentStructures = null;\n}\n\nconst mult10 = new Array(147); // this is a table matching binary exponents to the multiplier to determine significant digit rounding\nfor (let i = 0; i < 256; i++) {\n  mult10[i] = /* @__PURE__ */ (() =>\n    Number(`1e${Math.floor(45.15 - i * 0.30103)}`))();\n}\nconst defaultDecoder = new Decoder();\nexport const decode = defaultDecoder.decode;", "import { type Hex, isHex } from \"../encoding/hex.js\";\n\n/**\n * Ensures that the given bytecode has the correct prefix.\n * If the bytecode already starts with \"0x\", it is returned as is.\n * Otherwise, the prefix \"0x\" is added to the bytecode.\n * @param bytecode - The bytecode to ensure the prefix for.\n * @returns The bytecode with the correct prefix.\n * @example\n * ```ts\n * import { ensureBytecodePrefix } from \"thirdweb/utils/bytecode/prefix\";\n * const bytecode = \"363d3d373d3d3d363d30545af43d82803e903d91601857fd5bf3\";\n * const prefixedBytecode = ensureBytecodePrefix(bytecode);\n * console.log(prefixedBytecode);\n * ```\n * @utils\n */\nexport function ensureBytecodePrefix(bytecode: string): Hex {\n  if (isHex(bytecode, { strict: false })) {\n    return bytecode;\n  }\n  return `0x${bytecode}`;\n}\n", "import { base58Encode } from \"../base58/encode.js\";\nimport { hexToBytes } from \"../encoding/to-bytes.js\";\nimport { decode } from \"./cbor-decode.js\";\nimport { ensureBytecodePrefix } from \"./prefix.js\";\n\n/**\n * Extracts the IPFS URI from the given bytecode.\n * @param bytecode - The bytecode to extract the IPFS URI from.\n * @returns The IPFS URI if found, otherwise undefined.\n * @example\n * ```ts\n * import { extractIPFSUri } from \"thirdweb/utils/bytecode/extractIPFS\";\n * const bytecode = \"0x363d3d373d3d3d363d30545af43d82803e903d91601857fd5bf3\";\n * const ipfsHash = extractIPFSUri(bytecode);\n * console.log(ipfsHash);\n * ```\n * @utils\n */\nexport function extractIPFSUri(bytecode: string): string | undefined {\n  const numericBytecode = hexToBytes(ensureBytecodePrefix(bytecode));\n\n  const cborLength =\n    // @ts-expect-error - TS doesn't like this, but it's fine\n    numericBytecode[numericBytecode.length - 2] * 0x100 +\n    // @ts-expect-error - TS doesn't like this, but it's fine\n    numericBytecode[numericBytecode.length - 1];\n  const cborStart = numericBytecode.length - 2 - cborLength;\n  // if the cborStart is invalid, return undefined\n  if (cborStart < 0 || cborStart > numericBytecode.length) {\n    return undefined;\n  }\n  const bytecodeBuffer = numericBytecode.slice(cborStart, -2);\n\n  const cborData = decode(bytecodeBuffer);\n  if (\"ipfs\" in cborData) {\n    return `ipfs://${base58Encode(cborData.ipfs)}`;\n  }\n\n  return undefined;\n}\n"],
  "mappings": ";;;;;;;;;;;AAAO,IAAM,WACX;;;ACCF,IAAM,OAAO,SAAS;AACtB,IAAM,UAA0B,MAAM,SAAS,OAAO,CAAC,GAAE;AACzD,IAAM,WAA2B,MAAM,KAAK,IAAI,GAAG,IAAI,KAAK,IAAI,IAAI,GAAE;AAgBhE,SAAU,aAAa,QAAkB;AAC7C,MAAI,EAAE,kBAAkB,aAAa;AACnC,UAAM,IAAI,UAAU,qBAAqB;EAC3C;AACA,MAAI,OAAO,WAAW,GAAG;AACvB,WAAO;EACT;AAEA,MAAI,SAAS;AACb,MAAI,SAAS;AACb,MAAI,SAAS;AACb,QAAM,OAAO,OAAO;AACpB,SAAO,WAAW,QAAQ,OAAO,MAAM,MAAM,GAAG;AAC9C;AACA;EACF;AAEA,QAAM,QAAS,OAAO,UAAU,UAAU,MAAO;AACjD,QAAM,MAAM,IAAI,WAAW,IAAI;AAE/B,SAAO,WAAW,MAAM;AACtB,QAAI,QAAQ,OAAO,MAAM,KAAK;AAE9B,QAAI,IAAI;AACR,aACM,MAAM,OAAO,IAChB,UAAU,KAAK,IAAI,WAAW,QAAQ,IACvC,OAAO,KACP;AACA,eAAU,OAAO,IAAI,GAAG,KAAK,OAAQ;AACrC,UAAI,GAAG,IAAK,QAAQ,SAAU;AAC9B,cAAS,QAAQ,SAAU;IAC7B;AACA,QAAI,UAAU,GAAG;AACf,YAAM,IAAI,MAAM,gBAAgB;IAClC;AACA,aAAS;AACT;EACF;AAEA,MAAI,MAAM,OAAO;AACjB,SAAO,QAAQ,QAAQ,IAAI,GAAG,MAAM,GAAG;AACrC;EACF;AAEA,MAAI,MAAM,OAAO,OAAO,MAAM;AAC9B,SAAO,MAAM,MAAM,EAAE,KAAK;AACxB,WAAO,SAAS,OAAO,IAAI,GAAG,KAAK,CAAC;EACtC;AACA,SAAO;AACT;;;AC/DA,IAAI;AACJ,IAAI;AACJ,IAAI,WAAW;AAEf,IAAM,cAAc,CAAA;AAEpB,IAAI,UAAU;AAEd,IAAI,iBAAiB;AACrB,IAAI,iBAAiB,CAAA;AACrB,IAAI;AACJ,IAAI;AACJ,IAAM,iBAAiB;AACvB,IAAI,eAAe;AACnB,IAAI;AACJ,IAAI;AACJ,IAAM,oBAAoB,CAAA;AAE1B,IAAI;AAEJ,IAAI;AAEJ,IAAM,iBAAiB;EACrB,YAAY;EACZ,eAAe;;AAGjB,SAAS,gBAAgB,QAAM;AAC9B,MAAI;AACJ,MAAI,SAAS,IAAI;AAChB,QAAI,SAAS,gBAAgB,MAAM;AAClC,aAAO;EACT;AACA,MAAI,SAAS,MAAM;AAClB,WAAO,QAAQ,OAAO,IAAI,SAAS,UAAU,YAAY,MAAM,CAAC;AACjE,QAAM,MAAM,WAAW;AACvB,QAAM,QAAQ,CAAA;AACd,WAAS;AACT,SAAO,WAAW,KAAK;AACtB,UAAM,QAAQ,IAAI,UAAU;AAC5B,SAAK,QAAQ,SAAU,GAAG;AAEzB,YAAM,KAAK,KAAK;IACjB,YAAY,QAAQ,SAAU,KAAM;AAEnC,YAAM,QAAQ,IAAI,UAAU,IAAI;AAChC,YAAM,MAAO,QAAQ,OAAS,IAAK,KAAK;IACzC,YAAY,QAAQ,SAAU,KAAM;AAEnC,YAAM,QAAQ,IAAI,UAAU,IAAI;AAChC,YAAM,QAAQ,IAAI,UAAU,IAAI;AAChC,YAAM,MAAO,QAAQ,OAAS,KAAO,SAAS,IAAK,KAAK;IACzD,YAAY,QAAQ,SAAU,KAAM;AAEnC,YAAM,QAAQ,IAAI,UAAU,IAAI;AAChC,YAAM,QAAQ,IAAI,UAAU,IAAI;AAChC,YAAM,QAAQ,IAAI,UAAU,IAAI;AAChC,UAAI,QAAS,QAAQ,MAAS,KAAS,SAAS,KAAS,SAAS,IAAQ;AAC1E,UAAI,OAAO,OAAQ;AAClB,gBAAQ;AACR,cAAM,KAAO,SAAS,KAAM,OAAS,KAAM;AAC3C,eAAO,QAAU,OAAO;MACzB;AACA,YAAM,KAAK,IAAI;IAChB,OAAO;AACN,YAAM,KAAK,KAAK;IACjB;AAEA,QAAI,MAAM,UAAU,MAAQ;AAC3B,gBAAU,aAAa,MAAM,QAAQ,KAAK;AAC1C,YAAM,SAAS;IAChB;EACD;AAEA,MAAI,MAAM,SAAS,GAAG;AACrB,cAAU,aAAa,MAAM,QAAQ,KAAK;EAC3C;AAEA,SAAO;AACR;AAEA,IAAM,UAAN,MAAM,SAAO;EACX,cAAA;AACE,WAAO,OAAO,MAAM,cAAc;EACpC;EAEA,UAAU,KAAG;AACX,WAAO;EACT;EAEA,OAAO,QAAQ,MAAO,IAAE;AACtB,aAAS,MAAM,KAAK,MAAM,OAAO;AACjC,eAAW;AACX,qBAAiB;AACjB,mBAAe;AACf,gBAAY;AACZ,cAAU;AACV,qBAAiB;AACjB,UAAM;AAIN,QAAI;AACF,iBACE,OAAO,aACN,OAAO,WAAW,IAAI,SACrB,OAAO,QACP,OAAO,YACP,OAAO,UAAU;IAEvB,SAAS,OAAO;AAEd,YAAM;AACN,UAAI,kBAAkB,YAAY;AAChC,cAAM;MACR;AACA,YAAM,IAAI,MACR,mDAAmD,UAAU,OAAO,WAAW,WACzE,OAAO,YAAY,OACnB,OAAO,MAAM,EAAE;IAEzB;AACA,QAAI,gBAAgB,UAAS;AAC3B,uBAAiB;AACjB,qBACE,KAAK,iBACJ,KAAK,OACF,IAAI,MAAM,KAAK,0BAA0B,EAAE,EAAE,OAC3C,KAAK,YAAY,IAEnB,KAAK;AACX,UAAI,CAAC,qBAAqB,kBAAkB,SAAS,GAAG;AACtD,4BAAoB,CAAA;MACtB;IACF,OAAO;AACL,uBAAiB;AACjB,UAAI,CAAC,qBAAqB,kBAAkB,SAAS,GAAG;AACtD,4BAAoB,CAAA;MACtB;AACA,qBAAe;IACjB;AACA,WAAO,YAAW;EACpB;;AAGF,SAAS,cAAW;AAClB,MAAI;AACF,UAAM,SAAS,KAAI;AACnB,QAAI,gBAAgB;AAClB,UAAI,YAAY,eAAe,oBAAoB;AACjD,cAAM,QAAQ,IAAI,MAAM,4BAA4B;AACpD,cAAM,aAAa;AACnB,cAAM;MACR;AAEA,iBAAW,eAAe;AAC1B,uBAAiB;IACnB;AAEA,QAAI,aAAa,QAAQ;AAEvB,0BAAoB;AACpB,YAAM;AACN,UAAI,cAAc;AAChB,uBAAe;MACjB;IACF,WAAW,WAAW,QAAQ;AAE5B,YAAM,QAAQ,IAAI,MAAM,6BAA6B;AACrD,YAAM,aAAa;AACnB,YAAM;IACR,OAAO;AACL,YAAM,IAAI,MAAM,0CAA0C;IAC5D;AAEA,WAAO;EACT,SAAS,OAAO;AACd,gBAAW;AACX,QACE,iBAAiB,cACjB,MAAM,QAAQ,WAAW,0BAA0B,GACnD;AACA,YAAM,aAAa;IACrB;AACA,UAAM;EACR;AACF;AAEA,SAAS,OAAI;AACX,MAAI,QAAQ,IAAI,UAAU;AAC1B,QAAM,YAAY,SAAS;AAC3B,UAAQ,QAAQ;AAChB,MAAI,QAAQ,IAAM;AAChB,YAAQ,OAAO;MACb,KAAK;AACH,gBAAQ,IAAI,UAAU;AACtB;MAEF;AACE,cAAM,IAAI,MAAM,iBAAiB,KAAK,EAAE;IAC5C;EACF;AACA,UAAQ,WAAW;IACjB,KAAK;AACH,aAAO;IACT,KAAK;AACH,aAAO,CAAC;IACV,KAAK;AACH,aAAO,QAAQ,KAAK;IACtB,KAAK;AACH,UAAI,gBAAgB,UAAU;AAC5B,eAAO,UAAU,MACf,WAAW,iBACV,YAAY,SAAS,cAAc;MAExC;AACA,UAAI,iBAAiB,KAAK,SAAS,OAAO,QAAQ,IAAI;AAEpD,cAAM,SACJ,QAAQ,KAAK,gBAAgB,KAAK,IAAI,eAAe,KAAK;AAC5D,YAAI,WAAW,MAAM;AACnB,iBAAO;QACT;MACF;AACA,aAAO,gBAAgB,KAAK;IAC9B,KAAK,GAAG;AACN,YAAM,QAAQ,IAAI,MAAM,KAAK;AAC7B,eAAS,IAAI,GAAG,IAAI,OAAO,KAAK;AAC9B,cAAM,CAAC,IAAI,KAAI;MACjB;AACA,aAAO;IACT;IAEA,KAAK,GAAG;AACN,YAAM,SAAS,CAAA;AACf,eAAS,IAAI,GAAG,IAAI,OAAO,KAAK;AAC9B,eAAO,QAAQ,KAAI,CAAE,CAAC,IAAI,KAAI;MAChC;AACA,aAAO;IACT;IACA;AACE,UAAI,OAAO,MAAM,KAAK,GAAG;AACvB,cAAM,QAAQ,IAAI,MAAM,6BAA6B;AACrD,cAAM,aAAa;AACnB,cAAM;MACR;AACA,YAAM,IAAI,MAAM,sBAAsB,KAAK,EAAE;EACjD;AACF;AAEA,SAAS,QAAQ,KAAG;AAElB,MAAI,OAAO,QAAQ,UAAU;AAC3B,WAAO,QAAQ,cAAc,aAAa;EAC5C;AACA,MAAI,OAAO,QAAQ,UAAU;AAC3B,WAAO,IAAI,SAAQ;EACrB;AAEA,QAAM,IAAI,MAAM,8BAA8B,OAAO,GAAG,EAAE;AAC5D;AAEA,IAAM,eAAe,OAAO;AAC5B,SAAS,eAAe,QAAM;AAC5B,QAAM,QAAQ;AACd,QAAM,QAAQ,IAAI,MAAM,MAAM;AAC9B,WAAS,IAAI,GAAG,IAAI,QAAQ,KAAK;AAC/B,UAAM,OAAO,IAAI,UAAU;AAC3B,SAAK,OAAO,OAAQ,GAAG;AACrB,iBAAW;AACX;IACF;AACA,UAAM,CAAC,IAAI;EACb;AACA,SAAO,aAAa,MAAM,QAAQ,KAAK;AACzC;AACA,SAAS,gBAAgB,QAAM;AAC7B,MAAI,SAAS,GAAG;AACd,QAAI,SAAS,GAAG;AACd,UAAI,WAAW,GAAG;AAChB,eAAO;MACT;AACE,YAAMA,KAAI,IAAI,UAAU;AACxB,WAAKA,KAAI,OAAQ,GAAG;AAClB,oBAAY;AACZ;MACF;AACA,aAAO,aAAaA,EAAC;IACzB;AACE,UAAMA,KAAI,IAAI,UAAU;AACxB,UAAMC,KAAI,IAAI,UAAU;AACxB,SAAKD,KAAI,OAAQ,MAAMC,KAAI,OAAQ,GAAG;AACpC,kBAAY;AACZ;IACF;AACA,QAAI,SAAS,GAAG;AACd,aAAO,aAAaD,IAAGC,EAAC;IAC1B;AACA,UAAMC,KAAI,IAAI,UAAU;AACxB,SAAKA,KAAI,OAAQ,GAAG;AAClB,kBAAY;AACZ;IACF;AACA,WAAO,aAAaF,IAAGC,IAAGC,EAAC;EAC/B;AACE,QAAM,IAAI,IAAI,UAAU;AACxB,QAAM,IAAI,IAAI,UAAU;AACxB,QAAM,IAAI,IAAI,UAAU;AACxB,QAAM,IAAI,IAAI,UAAU;AACxB,OAAK,IAAI,OAAQ,MAAM,IAAI,OAAQ,MAAM,IAAI,OAAQ,MAAM,IAAI,OAAQ,GAAG;AACxE,gBAAY;AACZ;EACF;AACA,MAAI,SAAS,GAAG;AACd,QAAI,WAAW,GAAG;AAChB,aAAO,aAAa,GAAG,GAAG,GAAG,CAAC;IAChC;AACE,UAAMC,KAAI,IAAI,UAAU;AACxB,SAAKA,KAAI,OAAQ,GAAG;AAClB,kBAAY;AACZ;IACF;AACA,WAAO,aAAa,GAAG,GAAG,GAAG,GAAGA,EAAC;EACrC;AAAC,MAAI,SAAS,GAAG;AACf,UAAMA,KAAI,IAAI,UAAU;AACxB,UAAMC,KAAI,IAAI,UAAU;AACxB,SAAKD,KAAI,OAAQ,MAAMC,KAAI,OAAQ,GAAG;AACpC,kBAAY;AACZ;IACF;AACA,QAAI,SAAS,GAAG;AACd,aAAO,aAAa,GAAG,GAAG,GAAG,GAAGD,IAAGC,EAAC;IACtC;AACA,UAAMC,KAAI,IAAI,UAAU;AACxB,SAAKA,KAAI,OAAQ,GAAG;AAClB,kBAAY;AACZ;IACF;AACA,WAAO,aAAa,GAAG,GAAG,GAAG,GAAGF,IAAGC,IAAGC,EAAC;EACzC;AACE,QAAM,IAAI,IAAI,UAAU;AACxB,QAAM,IAAI,IAAI,UAAU;AACxB,QAAM,IAAI,IAAI,UAAU;AACxB,QAAM,IAAI,IAAI,UAAU;AACxB,OACG,IAAI,OAAQ,MACZ,IAAI,OAAQ,MACZ,IAAI,OAAQ,MACZ,IAAI,OAAQ,GACb;AACA,gBAAY;AACZ;EACF;AACA,MAAI,SAAS,IAAI;AACf,QAAI,WAAW,GAAG;AAChB,aAAO,aAAa,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,CAAC;IAC5C;AACE,UAAMC,KAAI,IAAI,UAAU;AACxB,SAAKA,KAAI,OAAQ,GAAG;AAClB,kBAAY;AACZ;IACF;AACA,WAAO,aAAa,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAGA,EAAC;EACjD;AAAC,MAAI,SAAS,IAAI;AAChB,UAAMA,KAAI,IAAI,UAAU;AACxB,UAAMC,KAAI,IAAI,UAAU;AACxB,SAAKD,KAAI,OAAQ,MAAMC,KAAI,OAAQ,GAAG;AACpC,kBAAY;AACZ;IACF;AACA,QAAI,SAAS,IAAI;AACf,aAAO,aAAa,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAGD,IAAGC,EAAC;IAClD;AACA,UAAMC,KAAI,IAAI,UAAU;AACxB,SAAKA,KAAI,OAAQ,GAAG;AAClB,kBAAY;AACZ;IACF;AACA,WAAO,aAAa,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAGF,IAAGC,IAAGC,EAAC;EACrD;AACE,QAAM,IAAI,IAAI,UAAU;AACxB,QAAM,IAAI,IAAI,UAAU;AACxB,QAAM,IAAI,IAAI,UAAU;AACxB,QAAM,IAAI,IAAI,UAAU;AACxB,OACG,IAAI,OAAQ,MACZ,IAAI,OAAQ,MACZ,IAAI,OAAQ,MACZ,IAAI,OAAQ,GACb;AACA,gBAAY;AACZ;EACF;AACA,MAAI,SAAS,IAAI;AACf,QAAI,WAAW,IAAI;AACjB,aAAO,aAAa,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,CAAC;IACxD;AACE,UAAMC,KAAI,IAAI,UAAU;AACxB,SAAKA,KAAI,OAAQ,GAAG;AAClB,kBAAY;AACZ;IACF;AACA,WAAO,aAAa,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAGA,EAAC;EAC7D;AACE,QAAM,IAAI,IAAI,UAAU;AACxB,QAAM,IAAI,IAAI,UAAU;AACxB,OAAK,IAAI,OAAQ,MAAM,IAAI,OAAQ,GAAG;AACpC,gBAAY;AACZ;EACF;AACA,MAAI,SAAS,IAAI;AACf,WAAO,aAAa,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,CAAC;EAC9D;AACA,QAAM,IAAI,IAAI,UAAU;AACxB,OAAK,IAAI,OAAQ,GAAG;AAClB,gBAAY;AACZ;EACF;AACA,SAAO,aAAa,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,CAAC;AACzE;AAEA,SAAS,QAAQ,QAAM;AACrB,SAAO,eAAe;;IAElB,WAAW,UAAU,MAAM,KAAK,KAAK,UAAW,YAAY,MAAO;MACnE,IAAI,SAAS,UAAW,YAAY,MAAO;AACjD;AAEA,IAAM,OAAO,EAAE,OAAO,OAAM;AAC5B,kBAAkB,EAAE,IAAI,CAAC,SAAQ;AAE/B,UAAQ,KAAK,KAAK,CAAC,CAAC,KAAK,OAAO,KAAK,CAAC,GAAG,KAAK,CAAC,CAAC;AAClD;AACA,IAAM,cAAc,CAAC,UAAS;AAC5B,MAAI,IAAI,UAAU,MAAM,KAAM;AAC5B,UAAM,QAAQ,IAAI,MAChB,+DAA+D;AAEjE,QAAI,IAAI,SAAS,UAAU;AACzB,YAAM,aAAa;IACrB;AACA,UAAM;EACR;AACA,QAAM,kBAAkB,MAAK;AAC7B,MAAI,CAAC,mBAAmB,CAAC,gBAAgB,QAAQ;AAC/C,UAAM,QAAQ,IAAI,MAChB,+DAA+D;AAEjE,UAAM,aAAa;AACnB,UAAM;EACR;AACA,iBAAe,eACX,gBAAgB,OAAO,aAAa,MAAM,gBAAgB,MAAM,CAAC,IACjE;AACJ,eAAa,WAAW,MAAK;AAC7B,eAAa,WAAW,MAAK;AAC7B,SAAO,MAAK;AACd;AACA,YAAY,cAAc;AAE1B,kBAAkB,EAAE,IAAI,CAAC,UAAS;AAEhC,MAAI,CAAC,cAAc;AACjB,mBAAe,oBAAI,IAAG;AACtB,iBAAa,KAAK;EACpB;AACA,QAAM,KAAK,aAAa;AACxB,QAAM,QAAQ,IAAI,QAAQ;AAC1B,MAAI;AAGJ,MAAI,SAAS,MAAM,GAAG;AACpB,aAAS,CAAA;EACX,OAAO;AACL,aAAS,CAAA;EACX;AAEA,QAAM,WAAW,EAAE,OAAM;AACzB,eAAa,IAAI,IAAI,QAAQ;AAC7B,QAAM,mBAAmB,MAAK;AAC9B,MAAI,SAAS,MAAM;AAEjB,WAAO,OAAO,OAAO,QAAQ,gBAAgB;EAC/C;AACA,WAAS,SAAS;AAClB,SAAO;AACT;AAEA,SAAS,cAAW;AAClB,QAAM;AACN,iBAAe;AACf,sBAAoB;AACtB;AAEA,IAAM,SAAS,IAAI,MAAM,GAAG;AAC5B,SAAS,IAAI,GAAG,IAAI,KAAK,KAAK;AAC5B,SAAO,CAAC,KAAqB,MAC3B,OAAO,KAAK,KAAK,MAAM,QAAQ,IAAI,OAAO,CAAC,EAAE,GAAE;AACnD;AACA,IAAM,iBAAiB,IAAI,QAAO;AAC3B,IAAM,SAAS,eAAe;;;AC1e/B,SAAU,qBAAqB,UAAgB;AACnD,MAAI,MAAM,UAAU,EAAE,QAAQ,MAAK,CAAE,GAAG;AACtC,WAAO;EACT;AACA,SAAO,KAAK,QAAQ;AACtB;;;ACJM,SAAU,eAAe,UAAgB;AAC7C,QAAM,kBAAkB,WAAW,qBAAqB,QAAQ,CAAC;AAEjE,QAAM;;IAEJ,gBAAgB,gBAAgB,SAAS,CAAC,IAAI;IAE9C,gBAAgB,gBAAgB,SAAS,CAAC;;AAC5C,QAAM,YAAY,gBAAgB,SAAS,IAAI;AAE/C,MAAI,YAAY,KAAK,YAAY,gBAAgB,QAAQ;AACvD,WAAO;EACT;AACA,QAAM,iBAAiB,gBAAgB,MAAM,WAAW,EAAE;AAE1D,QAAM,WAAW,OAAO,cAAc;AACtC,MAAI,UAAU,UAAU;AACtB,WAAO,UAAU,aAAa,SAAS,IAAI,CAAC;EAC9C;AAEA,SAAO;AACT;",
  "names": ["a", "b", "c", "e", "f", "g", "i", "j", "k", "m"]
}
